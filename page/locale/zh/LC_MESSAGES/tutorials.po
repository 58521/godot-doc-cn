# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2016, Juan Linietsky, Ariel Manzur and the Godot
# community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-08-22 20:31+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../tutorials/2d/_2d.rst:2
msgid "2D tutorials"
msgstr ""

#: ../../tutorials/2d/_2d_graphics.rst:2 ../../tutorials/3d/_3d_graphics.rst:2
msgid "Graphics"
msgstr ""

#: ../../tutorials/2d/_2d_gui.rst:2
msgid "Graphical user interface (GUI)"
msgstr ""

#: ../../tutorials/2d/_2d_physics.rst:2 ../../tutorials/3d/_3d_physics.rst:2
msgid "Physics"
msgstr ""

#: ../../tutorials/2d/canvas_layers.rst:4
msgid "画布层(Canvas layers)"
msgstr ""

#: ../../tutorials/2d/canvas_layers.rst:7
msgid "视窗与画布项(Viewport and Canvas items)"
msgstr ""

#: ../../tutorials/2d/canvas_layers.rst:8
msgid ""
"一般的2D节点, 如 :ref:`Node2D <class_Node2D>` 或 :ref:`Control <class_Control>` "
"都继承自 :ref:`CanvasItem <class_CanvasItem>`, 这是所有2D节点的基类。 CanvasItem "
"按次序地放置在一个树形结构内，它们都会继承其坐标信息。这意味着，当父节点移动时，子节点也将移动。"
msgstr ""

#: ../../tutorials/2d/canvas_layers.rst:13
msgid "这些节点可以直接或间接地放置于:ref:`Viewport <class_Viewport>`内, 并通过其显示出来。"
msgstr ""

#: ../../tutorials/2d/canvas_layers.rst:15
msgid ""
"视窗有一个 \"canvas_transform\" :ref:`Viewport.set_canvas_transform() "
"<class_Viewport_set_canvas_transform>` 属性， 此属性允许通过自定义的 :ref:`Matrix32 "
"<class_Matrix32>` 设置层级下所有 CanvasItem 的坐标信息。 节点，如:ref:`Camera2D "
"<class_Camera2D>`通过改变这个坐标，同样有效。"
msgstr ""

#: ../../tutorials/2d/canvas_layers.rst:19
msgid "设置画布坐标非常有用，因为这比移动节点更加高效。 画布坐标只是一个简单的保存了2D绘图偏移量的矩阵信息，因此这是滚动的最佳方式。"
msgstr ""

#: ../../tutorials/2d/canvas_layers.rst:24
msgid "还不够..."
msgstr ""

#: ../../tutorials/2d/canvas_layers.rst:26
msgid "但这还不够。在游戏或应用中经常有 不需要所有的东西都通过canvas_transform移动 的情况，如："
msgstr ""

#: ../../tutorials/2d/canvas_layers.rst:29
msgid "**视差滚动**: 背景比舞台上的其他东西移动地更慢。"
msgstr ""

#: ../../tutorials/2d/canvas_layers.rst:30
msgid "**HUD**: 显示在角色上方的信息，或者GUI. 当游戏内容移动时，生命计数，分数等必须保持静止。"
msgstr ""

#: ../../tutorials/2d/canvas_layers.rst:31
msgid "**过渡效果(Transitions)**: 过渡效果 (渐隐，混合等) 也许需要保持其位置不变。"
msgstr ""

#: ../../tutorials/2d/canvas_layers.rst:33
msgid "在单个场景树中如何解决这些问题？"
msgstr ""

#: ../../tutorials/2d/canvas_layers.rst:36
msgid "画布层(CanvasLayers)"
msgstr ""

#: ../../tutorials/2d/canvas_layers.rst:38
msgid ""
"答案是 :ref:`CanvasLayer <class_CanvasLayer>`。 "
"CanvasLayers为其所有的子节点添加了一个2D渲染层用以分割。默认情况下，视窗下的所有子节点都被绘制在 layer0 "
"上，然而CanvasLayer可在所有标明的 layer 上绘制。 编号越大的层将绘制在越上面（这号理解）。CanvasLayers "
"同样有其自身的坐标系统，而且不依赖其他层的坐标，当游戏内容移动时，这个特性可以保持 UI 位置固定。"
msgstr ""

#: ../../tutorials/2d/canvas_layers.rst:42
msgid "视差滚动就是一个经典例子。背景绘制在 layer-1，分数、生命和暂停按钮绘制在 layer1。"
msgstr ""

#: ../../tutorials/2d/canvas_layers.rst:44
msgid "下面的图显示了这个工作流程："
msgstr ""

#: ../../tutorials/2d/canvas_layers.rst:48
msgid "对于树形结构，CanvasLayers 是独立的，不参与排序，它们只受 layer编号的影响。因此，在需要的时候，尽情实例化他们吧~~"
msgstr ""

#: ../../tutorials/2d/canvas_layers.rst:51
msgid "性能"
msgstr ""

#: ../../tutorials/2d/canvas_layers.rst:52
msgid ""
"即使没有任何性能限制，我们也不建议使用过多的 layer 来绘制节点。最佳方式就是通树形结构排序来绘制节点。 2d节点同样可以通过 "
":ref:`Node2D.set_z() <class_Node2D_set_z> 来设置绘制顺序。"
msgstr ""

#: ../../tutorials/2d/custom_drawing_in_2d.rst:4
msgid "自定义2D绘图"
msgstr ""

#: ../../tutorials/2d/custom_drawing_in_2d.rst:7
msgid "有必要？"
msgstr ""

#: ../../tutorials/2d/custom_drawing_in_2d.rst:9
msgid ""
"Godot通过节点来绘制精灵(sprites)，多边形(polygons)，粒子(particles)和其他所有的类型。 "
"大多数情况下这已经足够创作者的需求，但不是全部。如果有些需要的功能但godot又不支持的话，在你因为需要某些特殊的东西需要绘制但又无法实现而哭鼻子之前，你需要了解下通过自定义命令来绘制2d节点(:ref:`Control"
" <class_Control>` or :ref:`Node2D <class_Node2D>`) 。而且，这*非常*容易实现。"
msgstr ""

#: ../../tutorials/2d/custom_drawing_in_2d.rst:13
msgid "另外..."
msgstr ""

#: ../../tutorials/2d/custom_drawing_in_2d.rst:15
msgid ""
"手动绘制节点非常有用。看看下面的例子： -  绘制形状或者某些特殊的节点（如：绘制圆，图片轨迹(image with "
"trails)，带有动画的多边形等等）。 -  一些与节点不兼容的东西（如：俄罗斯方块）。它使用了自定义的方法来绘制方块。 -  "
"管理大量（如：子弹）逻辑性但非常简单的东西。考虑到性能问题，最好不要用大量的节点来绘制这些东西。相反，绘制回调(draw "
"calls)就显得非常高效。可以查看demo里面的\"Shower of Bullets\"。 -  "
"创建自定义UI。godot提供了大量现成的控件，但也许你仍然需要绘制一个新的。"
msgstr ""

#: ../../tutorials/2d/custom_drawing_in_2d.rst:22
msgid "该怎么做？"
msgstr ""

#: ../../tutorials/2d/custom_drawing_in_2d.rst:23
msgid ""
"为任何派生自 :ref:`CanvasItem <class_CanvasItem>` 的节点添加脚本，如：:ref:`Control "
"<class_Control>` 或 :ref:`Node2D <class_Node2D>`. 重写 _draw() 方法。"
msgstr ""

#: ../../tutorials/2d/custom_drawing_in_2d.rst:34
msgid ""
"查看 :ref:`CanvasItem <class_CanvasItem>` 来了解都有哪些绘制命令(draw "
"commands)，相信我，真的有很多。"
msgstr ""

#: ../../tutorials/2d/custom_drawing_in_2d.rst:37
msgid "更新(Updating)"
msgstr ""

#: ../../tutorials/2d/custom_drawing_in_2d.rst:39
msgid "_draw() 方法只会被调用一次，然后绘制命令就被保存起来，因此不需要再次调用。"
msgstr ""

#: ../../tutorials/2d/custom_drawing_in_2d.rst:41
msgid ""
"如果因为状态或其他什么改变导致节点确实需要重新绘制的时候，只需要简单的调用 :ref:`CanvasItem.update() "
"<class_CanvasItem_update>` ，之后一个新的 _draw() 将会被调用。"
msgstr ""

#: ../../tutorials/2d/custom_drawing_in_2d.rst:43
msgid "下面是一些更复杂的例子。节点将在 texture 属性改变时重新绘制："
msgstr ""

#: ../../tutorials/2d/custom_drawing_in_2d.rst:60
msgid "在有些情况下，实现这样的效果可能需要每帧都进行绘制。但在这个例子中，只需要在 _process() 中调用 update() 方法，就像这样："
msgstr ""

#: ../../tutorials/2d/custom_drawing_in_2d.rst:76
msgid "好了！这就是基本的用法！发挥想象，绘制你的专属节点吧！"
msgstr ""

#: ../../tutorials/2d/custom_drawing_in_2d.rst:79
msgid "工具"
msgstr ""

#: ../../tutorials/2d/custom_drawing_in_2d.rst:81
msgid "在编辑器中，可能需要预览自定义绘制的行为功能。"
msgstr ""

#: ../../tutorials/2d/custom_drawing_in_2d.rst:83
msgid "记住，只在脚本顶部需要使用 \"tool\" 关键字，如果你忘记了怎么用，查看 :ref:`doc_gdscript`。"
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:4
msgid "Custom GUI controls"
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:7
msgid "So many controls..."
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:9
msgid ""
"Yet there are never enough. Creating your own custom controls that act "
"just the way you want them is an obsession of almost every GUI "
"programmer. Godot provides plenty of them, but they may not work exactly "
"the way you want. Before contacting the developers with a pull-request to"
" support diagonal scrollbars, at least it will be good to know how to "
"create these controls easily from script."
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:17
msgid "Drawing"
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:19
msgid ""
"For drawing, it is recommended to check the "
":ref:`doc_custom_drawing_in_2d` tutorial. The same applies. Some "
"functions are worth mentioning due to their usefulness when drawing, so "
"they will be detailed next:"
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:24
msgid "Checking control size"
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:26
msgid ""
"Unlike 2D nodes, \"size\" is very important with controls, as it helps to"
" organize them in proper layouts. For this, the :ref:`Control.get_size() "
"<class_Control_get_size>` method is provided. Checking it during _draw() "
"is vital to ensure everything is kept in-bounds."
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:33
msgid "Checking focus"
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:35
msgid ""
"Some controls (such as buttons or text editors) might provide input focus"
" for keyboard or joypad input. Examples of this are entering text or "
"pressing a button. This is controlled with the "
":ref:`Control.set_focus_mode() <class_Control_set_focus_mode>` function. "
"When drawing, and if the control supports input focus, it is always "
"desired to show some sort of indicator (highight, box, etc) to indicate "
"that this is the currently focused control. To check for this status, the"
" :ref:`Control.has_focus() <class_Control_has_focus>` exists. Example"
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:54
msgid "Sizing"
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:56
msgid ""
"As mentioned before, size is very important to controls. This allows them"
" to lay out properly, when set into grids, containers, or anchored. "
"Controls most of the time provide a *minimum size* to help to properly "
"lay them out. For example, if controls are placed vertically on top of "
"each other using a :ref:`VBoxContainer <class_VBoxContainer>`, the "
"minimum size will make sure your custom control is not squished by the "
"other controls in the container."
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:64
msgid ""
"To provide this callback, just override :ref:`Control.get_minimum_size() "
"<class_Control_get_minimum_size>`, for example:"
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:73
msgid "Or alternatively, set it via function:"
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:81
msgid "Input"
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:83
msgid ""
"Controls provide a few helpers to make managing input events much easier "
"than regular nodes."
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:87
msgid "Input events"
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:89
msgid ""
"There are a few tutorials about input before this one, but it's worth "
"mentioning that controls have a special input method that only works "
"when:"
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:93
msgid "The mouse pointer is over the control."
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:94
msgid ""
"The button was pressed over this control (control always captures input "
"until button is released)"
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:96
msgid ""
"Control provides keyboard/joypad focus via :ref:`Control.set_focus_mode()"
" <class_Control_set_focus_mode>`."
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:99
msgid ""
"This function is :ref:`Control._input_event() "
"<class_Control__input_event>`. Simply override it in your control. No "
"processing needs to be set."
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:111
msgid ""
"For more information about events themselves, check the "
":ref:`doc_inputevent` tutorial."
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:115
msgid "Notifications"
msgstr ""

#: ../../tutorials/2d/custom_gui_controls.rst:117
msgid ""
"Controls also have many useful notifications for which no callback "
"exists, but can be checked with the _notification callback:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:4
msgid "Cutout animation"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:7
msgid "What is it?"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:9
msgid ""
"Cut-out is a technique of animating in 2D where pieces of paper (or "
"similar material) are cut in special shapes and laid one over the other. "
"The papers are animated and photographed, frame by frame using a stop "
"motion technique (more info `here "
"<http://en.wikipedia.org/wiki/Cutout_animation)>`__)."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:15
msgid ""
"With the advent of the digital age, this technique became possible using "
"computers, which resulted in an increased amount of animation TV shows "
"using digital Cut-out. Notable examples are `South Park "
"<http://en.wikipedia.org/wiki/South_Park>`__ or `Jake and the Never Land "
"Pirates <http://en.wikipedia.org/wiki/Jake_and_the_Never_Land_Pirates>`__"
" ."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:23
msgid ""
"In video games, this technique also become very popular. Examples of this"
" are `Paper Mario <http://en.wikipedia.org/wiki/Super_Paper_Mario>`__ or "
"`Rayman Origins <http://en.wikipedia.org/wiki/Rayman_Origins>`__ ."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:29
msgid "Cutout in Godot"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:31
msgid ""
"Godot provides a few tools for working with these kind of assets, but "
"it's overall design makes it ideal for the workflow. The reason is that, "
"unlike other tools meant for this, Godot has the following advantages:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:35
msgid ""
"**The animation system is fully integrated with the engine**: This means,"
" animations can control much more than just motion of objects, such as "
"textures, sprite sizes, pivots, opacity, color modulation, etc. "
"Everything can be animated and blended."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:39
msgid ""
"**Mix with Traditional**: AnimatedSprite allows traditional animation to "
"be mixed, very useful for complex objects, such as shape of hands and "
"foot, changing facial expression, etc."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:42
msgid ""
"**Custom Shaped Elements**: Can be created with :ref:`Polygon2D "
"<class_Polygon2D>` allowing the mixing of UV animation, deformations, "
"etc."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:45
msgid ""
"**Particle Systems**: Can also be mixed with the traditional animation "
"hierarchy, useful for magic effects, jetpacks, etc."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:47
msgid ""
"**Custom Colliders**: Set colliders and influence areas in different "
"parts of the skeletons, great for bosses, fighting games, etc."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:49
msgid ""
"**Animation Tree**: Allows complex combinations and blendings of several "
"animations, the same way it works in 3D."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:52
#: ../../tutorials/3d/shader_materials.rst:19
msgid "And much more!"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:55
msgid "Making of GBot!"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:57
msgid ""
"For this tutorial, we will use as demo content the pieces of the `GBot "
"<https://www.youtube.com/watch?v=S13FrWuBMx4&list=UUckpus81gNin1aV8WSffRKw>`__"
" character, created by Andreas Esau."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:63
msgid ""
"Get your assets: :download:`gbot_resources.zip "
"</files/gbot_resources.zip>`."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:66
msgid "Setting up the rig"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:68
msgid "Create an empty Node2D as root of the scene, we will work under it:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:72
msgid ""
"OK, the first node of the model that we will create will be the hip. "
"Generally, both in 2D and 3D, the hip is the root of the skeleton. This "
"makes it easier to animate:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:78
msgid ""
"Next will be the torso. The torso needs to be a child of the hip, so "
"create a child sprite and load the torso, later accommodate it properly:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:83
msgid ""
"This looks good. Let's see if our hierarchy works as a skeleton by "
"rotating the torso:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:88
msgid ""
"Ouch, that doesn't look good! The rotation pivot is wrong, this means it "
"needs to be adjusted."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:91
msgid ""
"This small little cross in the middle of the :ref:`Sprite <class_Sprite>`"
" is the rotation pivot:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:98
msgid "Adjusting the pivot"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:100
msgid "The pivot can be adjusted by changing the *offset* property in the Sprite:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:105
msgid ""
"However, there is a way to do it more *visually*. While hovering over the"
" desired pivot point, simply press the \"v\" key to move the pivot there "
"for the selected Sprite. Alternately, there is a tool in the tool bar "
"that has a similar function."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:112
msgid ""
"Now it looks good! Let's continue adding body pieces, starting by the "
"right arm. Make sure to put the sprites in hierarchy, so their rotations "
"and translations are relative to the parent:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:118
msgid ""
"This seems easy, so continue with the right arm. The rest should be "
"simple! Or maybe not:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:123
msgid ""
"Right. Remember your tutorials, Luke. In 2D, parent nodes appear below "
"children nodes. Well, this sucks. It seems Godot does not support cutout "
"rigs after all. Come back next year, maybe for 3.0.. no wait. Just "
"Kidding! It works just fine."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:128
msgid ""
"But how can this problem be solved? We want the left arm to appear behind"
" the hip and the torso. For this, we can move the nodes behind the hip "
"(note that you can bypass this by setting the Node2D Z property, but then"
" you won't learn about all this!):"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:135
msgid ""
"But then, we lose the hierarchy layout, which allows to control the "
"skeleton like.. a skeleton. Is there any hope?.. Of Course!"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:139
msgid "RemoteTransform2D node"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:141
msgid ""
"Godot provides a special node, :ref:`RemoteTransform2D "
"<class_RemoteTransform2D>`. This node will transform nodes that are "
"sitting somewhere else in the hierarchy, by applying the transform to the"
" remote nodes."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:145
msgid "This enables to have a visibility order independent from the hierarchy."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:148
msgid ""
"Simply create two more nodes as children from torso, remote_arm_l and "
"remote_hand_l and link them to the actual sprites:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:153
msgid ""
"Moving the remote transform nodes will move the sprites, allowing you to "
"easily animate and pose the character:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:159
msgid "Completing the skeleton"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:161
msgid ""
"Complete the skeleton by following the same steps for the rest of the "
"parts. The resulting scene should look similar to this:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:166
msgid ""
"The resulting rig will be easy to animate. By selecting the nodes and "
"rotating them you can animate forward kinematics (FK) efficiently."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:169
msgid ""
"For simple objects and rigs this is fine, however the following problems "
"are common:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:172
msgid ""
"Selecting sprites can become difficult for complex rigs, and the scene "
"tree ends being used due to the difficulty of clicking over the proper "
"sprite."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:175
msgid "Inverse Kinematics is often desired for extremities."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:177
msgid "To solve these problems, Godot supports a simple method of skeletons."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:180
msgid "Skeletons"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:182
msgid ""
"Godot doesn't actually support *true* Skeketons, but it does feature a "
"helper to create \"bones\" between nodes. This is enough for most cases, "
"but the way it works is not completely obvious."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:188
msgid ""
"As an example, let's turn the right arm into a skeleton. To create "
"skeletons, a chain of nodes must be selected from top to bottom:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:193
msgid "Then, the option to create a skeleton is located at Edit > Make Bones:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:197
msgid ""
"This will add bones covering the arm, but the result is not quite what is"
" expected."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:202
msgid ""
"It looks like the bones are shifted up in the hierarchy. The hand "
"connects to the arm, and the arm to the body. So the question is:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:205
msgid "Why does the hand lack a bone?"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:206
msgid "Why does the arm connect to the body?"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:208
msgid ""
"This might seem strange at first, but will make sense later on. In "
"traditional skeleton systems, bones have a position, an orientation and a"
" length. In Godot, bones are mostly helpers so they connect the current "
"node with the parent. Because of this, **toggling a node as a bone will "
"just connect it to the parent**."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:214
msgid ""
"So, with this knowledge. Let's do the same again so we have an actual, "
"useful skeleton."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:217
msgid ""
"The first step is creating an endpoint node. Any kind of node will do, "
"but :ref:`Position2D <class_Position2D>` is preferred because it's "
"visible in the editor. The endpoint node will ensure that the last bone "
"has orientation."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:224
msgid "Now select the whole chain, from the endpoint to the arm and create bones:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:229
msgid ""
"The result resembles a skeleton a lot more, and now the arm and forearm "
"can be selected and animated."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:232
msgid ""
"Finally, create endpoints in all meaningful extremities and connect the "
"whole skeleton with bones up to the hip:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:237
msgid ""
"Finally! the whole skeleton is rigged! On close look, it is noticeable "
"that there is a second set of endpoints in the hands. This will make "
"sense soon."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:241
msgid ""
"Now that a whole skeleton is rigged, the next step is setting up the IK "
"chains. IK chains allow for more natural control of extremities."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:245
msgid "IK chains"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:247
msgid ""
"IK chains are a powerful animation tool. Imagine you want to pose a "
"character's foot in a specific position on the ground. Without IK chains,"
" each motion of the foot would require rotating and positioning several "
"other bones. This would be quite complex and lead to imprecise results."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:249
msgid "What if we could move the foot and let the rest of the leg self-adjust?"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:251
msgid "This type of posing is called IK (Inverse Kinematic)."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:253
msgid ""
"To create an IK chain, simply select a chain of bones from endpoint to "
"the base for the chain. For example, to create an IK chain for the right "
"leg, select the following:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:259
msgid "Then enable this chain for IK. Go to Edit > Make IK Chain."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:263
msgid "As a result, the base of the chain will turn *Yellow*."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:267
msgid ""
"Once the IK chain is set-up, simply grab any of the bones in the "
"extremity, any child or grand-child of the base of the chain and try to "
"grab it and move it. Result will be pleasant, satisfaction warranted!"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:274
msgid "Animation"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:276
msgid ""
"The following section will be a collection of tips for creating animation"
" for your rigs. If unsure about how the animation system in Godot works, "
"refresh it by checking again the :ref:`doc_animations`."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:281
msgid "2D animation"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:283
msgid ""
"When doing animation in 2D, a helper will be present in the top menu. "
"This helper only appears when the animation editor window is opened:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:288
msgid ""
"The key button will insert location/rotation/scale keyframes to the "
"selected objects or bones. This depends on the mask enabled. Green items "
"will insert keys while red ones will not, so modify the key insertion "
"mask to your preference."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:294
msgid "Rest pose"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:296
msgid ""
"These kind of rigs do not have a \"rest\" pose, so it's recommended to "
"create a reference rest pose in one of the animations."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:299
msgid "Simply do the following steps:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:301
msgid "Make sure the rig is in \"rest\" (not doing any specific pose)."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:303
msgid "Create a new animation, rename it to \"rest\"."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:305
msgid "Select all nodes (box selection should work fine)."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:307
msgid "Select \"loc\" and \"rot\" on the top menu."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:309
msgid ""
"5. Push the key button. Keys will be inserted for everything, creating a "
"default pose."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:315
#: ../../tutorials/matrices_and_transforms.rst:184
msgid "Rotation"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:317
msgid ""
"Animating these models means only modifying the rotation of the nodes. "
"Location and scale are rarely used, with the only exception of moving the"
" entire rig from the hip (which is the root node)."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:321
msgid ""
"As a result, when inserting keys, only the \"rot\" button needs to be "
"pressed most of the time:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:326
msgid ""
"This will avoid the creation of extra animation tracks for the position "
"that will remain unused."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:330
msgid "Keyframing IK"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:332
msgid ""
"When editing IK chains, is is not necessary to select the whole chain to "
"add keyframes. Selecting the endpoint of the chain and inserting a "
"keyframe will automatically insert keyframes until the chain base too. "
"This makes the task of animating extremities much simpler."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:338
msgid "Moving sprites above and behind others."
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:340
msgid ""
"RemoteTransform2D works in most cases, but sometimes it is really "
"necessary to have a node above and below others during an animation. To "
"aid on this the \"Behind Parent\" property exists on any Node2D:"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:347
msgid "Batch setting transition curves"
msgstr ""

#: ../../tutorials/2d/cutout_animation.rst:349
msgid ""
"When creating really complex animations and inserting lots of keyframes, "
"editing the individual keyframe curves for each can become an endless "
"task. For this, the Animation Editor has a small menu where changing all "
"the curves is easy. Just select every single keyframe and (generally) "
"apply the \"Out-In\" transition curve to smooth the animation:"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:4
msgid "GUI skinning"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:7
msgid "Oh beautiful GUI!"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:9
msgid ""
"This tutorial is about advanced skinning of an user interface. Most games"
" generally don't need this, as they end up just relying on :ref:`Label "
"<class_Label>`, :ref:`TextureFrame <class_TextureFrame>`, "
":ref:`TextureButton <class_TextureButton>` and :ref:`TextureProgress "
"<class_TextureProgress>`."
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:15
msgid ""
"However, many types of games often need complex user interfaces, like "
"MMOs, traditional RPGs, Simulators, Strategy, etc. These kind of "
"interfaces are also common in some games that include editors to create "
"content, or interfaces for network connectivity."
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:20
msgid ""
"Godot user interface uses these kind of controls with the default theme, "
"but they can be skinned to resemble pretty much any kind of user "
"interface."
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:25
msgid "Theme"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:27
msgid ""
"The GUI is skinned through the :ref:`Theme <class_Theme>` resource. Theme"
" contains all the information required to change the entire visual "
"styling of all controls. Theme options are named, so it's not obvious "
"which name changes what (specialy from code), but several tools are "
"provided. The ultimate place to look at what each theme option is for "
"each control, which will always be more up to date than any documentation"
" is the file `scene/resources/default_theme/default_theme.cpp "
"<https://github.com/godotengine/godot/blob/master/scene/resources/default_theme/default_theme.cpp>`__."
" The rest of this document will explain the different tools used to "
"customize the theme."
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:38
msgid ""
"A Theme can be applied to any control in the scene. As a result, all "
"children and grand-children controls will use that same theme too (unless"
" another theme is specified further down the tree). If a value is not "
"found in a theme, it will be searched in themes higher up in the "
"hierarchy towards the root. If nothing was found, the default theme is "
"used. This system allows for flexible overriding of themes in complex "
"user interfaces."
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:47
msgid "Theme options"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:49
msgid "Each kind of option in a theme can be:"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:51
msgid ""
"**An integer constant**: A single numerical constant. Generally used to "
"define spacing between compoments or alignment."
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:53
msgid ""
"**A Color**: A single color, with or without transparency. Colors are "
"usually applied to fonts and icons."
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:55
msgid ""
"**A Texture**: A single image. Textures are not often used, but when they"
" are they represent handles to pick or icons in a complex control (such "
"as file dialog)."
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:58
msgid ""
"**A Font**: Every control that uses text can be assigned the fonts used "
"to draw strings."
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:60
msgid ""
"**A StyleBox**: Stylebox is a resource that defines how to draw a panel "
"in varying sizes (more information on them later)."
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:63
msgid "Every option is associated to:"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:65
msgid "A name (the name of the option)"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:66
msgid "A Control (the name of the control)"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:68
msgid "An example usage:"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:78
msgid ""
"In the example above, a new theme is created. The \"font_color\" option "
"is changed and then applied to a label. As a result, the label (and all "
"children and grand children labels) will use that color."
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:82
msgid ""
"It is possible to override those options without using the theme directly"
" and only for a specific control by using the override API in "
":ref:`Control.add_color_override() <class_Control_add_color_override>`:"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:91
msgid ""
"In the inline help of Godot (in the script tab) you can check which theme"
" options are overrideable, or check the :ref:`Control <class_Control>` "
"class reference."
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:95
msgid "Customizing a control"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:97
msgid ""
"If only a few controls need to be skinned, it is often not necessary to "
"create a new theme. Controls offer their theme options as special kinds "
"of properties. If checked, overriding will take place:"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:103
msgid ""
"As can be see in the image above, theme options have little check-boxes. "
"If checked, they can be used to override the value of the theme just for "
"that control."
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:108
msgid "Creating a theme"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:110
msgid ""
"The simplest way to create a theme is to edit a theme resource. Create a "
"Theme from the resource menu, the editor will appear immediately. "
"Following to this, save it (to, as example, mytheme.thm):"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:116
msgid ""
"This will create an empty theme that can later be loaded and assigned to "
"controls."
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:120
msgid "Example: theming a button"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:122
msgid ""
"Take some assets (:download:`skin_assets.zip </files/skin_assets.zip>`), "
"go to the \"theme\" menu and select \"Add Class Item\":"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:127
msgid ""
"A menu will appear promting the type of control to create. Select "
"\"Button\":"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:132
msgid ""
"Immediately, all button theme options will appear in the property editor,"
" where they can be edited:"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:137
msgid ""
"Select the \"normal\" stylebox and create a new \"StyleBoxTexture\", then"
" edit it. A texture stylebox basically contains a texture and the size of"
" the margins that will not stretch when the texture is stretched. This is"
" called \"3x3\" stretching:"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:144
msgid ""
"Repeat the steps and add the other assets. There is no hover or disabled "
"image in the example files, so use the same stylebox as in normal. Set "
"the supplied font as the button font and change the font color to black. "
"Soon, your button will look different and retro:"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:151
msgid ""
"Save this theme to the .thm file. Go to the 2D editor and create a few "
"buttons:"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:156
msgid ""
"Now, go to the root node of the scene and locate the \"theme\" property, "
"replace it by the theme that was just created. It should look like this:"
msgstr ""

#: ../../tutorials/2d/gui_skinning.rst:161
msgid "Congratulations! You have created a reusable GUI Theme!"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:4
msgid "Kinematic Character (2D)"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:7
#: ../../tutorials/2d/screen-reading_shaders.rst:7
#: ../../tutorials/2d/using_tilemaps.rst:7
#: ../../tutorials/3d/3d_performance_and_limitations.rst:7
#: ../../tutorials/3d/fixed_materials.rst:7
#: ../../tutorials/3d/high_dynamic_range.rst:7
#: ../../tutorials/3d/importing_3d_meshes.rst:7
#: ../../tutorials/3d/importing_3d_scenes.rst:7
#: ../../tutorials/3d/lighting.rst:7 ../../tutorials/3d/materials.rst:7
#: ../../tutorials/3d/shader_materials.rst:7
#: ../../tutorials/3d/shadow_mapping.rst:7
#: ../../tutorials/3d/using_gridmaps.rst:7
#: ../../tutorials/engine/internationalizing_games.rst:7
#: ../../tutorials/engine/project_organization.rst:7
#: ../../tutorials/engine/saving_games.rst:7
#: ../../tutorials/matrices_and_transforms.rst:7
#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:7
#: ../../tutorials/ray-casting.rst:7 ../../tutorials/ssl_certificates.rst:7
msgid "Introduction"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:9
msgid ""
"Yes, the name sounds strange. \"Kinematic Character\". What is that? The "
"reason is that when physics engines came out, they were called "
"\"Dynamics\" engines (because they dealt mainly with collision "
"responses). Many attempts were made to create a character controller "
"using the dynamics engines but it wasn't as easy as it seems. Godot has "
"one of the best implementations of dynamic character controller you can "
"find (as it can be seen in the 2d/platformer demo), but using it "
"requieres a considerable level of skill and understanding of physics "
"engines (or a lot of patience with trial and error)."
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:19
msgid ""
"Some physics engines such as Havok seem to swear by dynamic character "
"controllers as the best alternative, while others (PhysX) would rather "
"promote the Kinematic one."
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:23
msgid "So, what is really the difference?:"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:25
msgid ""
"A **dynamic character controller** uses a rigid body with infinite "
"inertial tensor. Basically, it's a rigid body that can't rotate. Physics "
"engines always let objects collide, then solve their collisions all "
"together. This makes dynamic character controllers able to interact with "
"other physics objects seamlessly (as seen in the platformer demo), "
"however these interactions are not always predictable. Collisions also "
"can take more than one frame to be solved, so a few collisions may seem "
"to displace a tiny bit. Those problems can be fixed, but require a "
"certain amount of skill."
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:34
msgid ""
"A **kinematic character controller** is assumed to always begin in a non-"
"colliding state, and will always move to a non colliding state. If it "
"starts in a colliding state, it will try to free itself (like rigid "
"bodies do) but this is the exception, not the rule. This makes their "
"control and motion a lot more predictable and easier to program. However,"
" as a downside, they can't directly interact with other physics objects "
"(unless done by hand in code)."
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:42
msgid ""
"This short tutorial will focus on the kinematic character controller. "
"Basically, the oldschool way of handling collisions (which is not "
"necessarily simpler under the hood, but well hidden and presented as a "
"nice and simple API)."
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:48
msgid "Fixed process"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:50
msgid ""
"To manage the logic of a kinematic body or character, it is always "
"advised to use fixed process, which is called the same amount of times "
"per second, always. This makes physics and motion calculation work in a "
"more predictable way than using regular process, which might have spikes "
"or lose precision if the frame rate is too high or too low."
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:67
msgid "Scene setup"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:69
msgid ""
"To have something to test, here's the scene (from the tilemap tutorial): "
":download:`kbscene.zip </files/kbscene.zip>`. We'll be creating a new "
"scene for the character. Use the robot sprite and create a scene like "
"this:"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:75
msgid ""
"Let's add a circular collision shape to the collision body, create a new "
"CircleShape2D in the shape property of CollisionShape2D. Set the radius "
"to 30:"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:81
msgid ""
"**Note: As mentioned before in the physics tutorial, the physics engine "
"can't handle scale on most types of shapes (only collision polygons, "
"planes and segments work), so always change the parameters (such as "
"radius) of the shape instead of scaling it. The same is also true for the"
" kinematic/rigid/static bodies themselves, as their scale affect the "
"shape scale.**"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:88
msgid ""
"Now create a script for the character, the one used as an example above "
"should work as a base."
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:91
msgid ""
"Finally, instance that character scene in the tilemap, and make the map "
"scene the main one, so it runs when pressing play."
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:97
msgid "Moving the Kinematic character"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:99
msgid ""
"Go back to the character scene, and open the script, the magic begins "
"now! Kinematic body will do nothing by default, but it has a really "
"useful function called :ref:`KinematicBody2D.move() "
"<class_KinematicBody2D_move>`. This function takes a :ref:`Vector2 "
"<class_Vector2>` as an argument, and tries to apply that motion to the "
"kinematic body. If a collision happens, it stops right at the moment of "
"the collision."
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:106
msgid "So, let's move our sprite downwards until it hits the floor:"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:118
msgid ""
"The result is that the character will move, but stop right when hitting "
"the floor. Pretty cool, huh?"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:121
msgid ""
"The next step will be adding gravity to the mix, this way it behaves a "
"little more like an actual game character:"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:141
msgid ""
"Now the character falls smoothly. Let's make it walk to the sides, left "
"and right when touching the directional keys. Remember that the values "
"being used (for speed at least) is pixels/second."
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:145
msgid "This adds simple walking support by pressing left and right:"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:173
msgid "And give it a try."
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:176
msgid "Problem?"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:178
msgid ""
"And... it doesn't work very well. If you go to the left against a wall, "
"it gets stuck unless you release the arrow key. Once it is on the floor, "
"it also gets stuck and it won't walk. What is going on??"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:182
msgid ""
"The answer is, what it seems like it should be simple, it isn't that "
"simple in reality. If the motion can't be completed, the character will "
"stop moving. It's as simple as that. This diagram should illustrate "
"better what is going on:"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:189
msgid ""
"Basically, the desired motion vector will never complete because it hits "
"the floor and the wall too early in the motion trajectory and that makes "
"it stop there. Remember that even though the character is on the floor, "
"the gravity is always turning the motion vector downwards."
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:195
msgid "Solution!"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:197
msgid ""
"The solution? This situation is solved by \"sliding\" by the collision "
"normal. KinematicBody2D provides two useful functions:"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:200
msgid ":ref:`KinematicBody2D.is_colliding() <class_KinematicBody2D_is_colliding>`"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:201
msgid ""
":ref:`KinematicBody2D.get_collision_normal() "
"<class_KinematicBody2D_get_collision_normal>`"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:203
msgid "So what we want to do is this:"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:207
msgid ""
"When colliding, the function ``move()`` returns the \"remainder\" of the "
"motion vector. That means, if the motion vector is 40 pixels, but "
"collision happened at 10 pixels, the same vector but 30 pixels long is "
"returned."
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:212
msgid ""
"The correct way to solve the motion is, then, to slide by the normal this"
" way:"
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:240
msgid ""
"Note that not only the motion has been modified but also the velocity. "
"This makes sense as it helps keep the new direction too."
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:243
msgid ""
"The normal can also be used to detect that the character is on floor, by "
"checking the angle. If the normal points up (or at least, within a "
"certain threshold), the character can be determined to be there."
msgstr ""

#: ../../tutorials/2d/kinematic_character_2d.rst:247
msgid ""
"A more complete demo can be found in the demo zip distributed with the "
"engine, or in the "
"https://github.com/godotengine/godot/tree/master/demos/2d/kinematic_char."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:4
msgid "Particle Systems (2D)"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:7
msgid "Intro"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:9
msgid ""
"A simple (but flexible enough for most uses) particle system is provided."
" Particle systems are used to simulate complex physical effects such as "
"sparks, fire, magic particles, smoke, mist, magic, etc."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:13
msgid ""
"The idea is that a \"particle\" is emitted at a fixed interval and with a"
" fixed lifetime. During his lifetime, every particle will have the same "
"base behavior. What makes every particle different and provides a more "
"organic look is the \"randomness\" associated to each parameter. In "
"essence, creating a particle system means setting base physics parameters"
" and then adding randomness to them."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:21
msgid "Particles2D"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:23
msgid ""
"Particle systems are added to the scene via the :ref:`Particles2D "
"<class_Particles2D>` node. They are enabled by default and start emitting"
" white points downwards (as affected by the gravity). This provides a "
"reasonable starting point to start adapting it to our needs."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:32
msgid "Texture"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:34
msgid ""
"A particle system uses a single texture (in the future this might be "
"extended to animated textures via spritesheet). The texture is set via "
"the relevant texture property:"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:41
msgid "Physics variables"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:43
msgid ""
"Before taking a look at the global parameters for the particle system, "
"let's first see what happens when the physics variables are tweaked."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:47
msgid "Direction"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:49
msgid "This is the base angle at which particles emit. Default is 0 (down):"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:53
msgid ""
"Changing it will change the emissor direction, but gravity will still "
"affect them:"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:58
msgid ""
"This parameter is useful because, by rotating the node, gravity will also"
" be rotated. Changing direction keeps them separate."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:62
msgid "Spread"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:64
msgid ""
"Spread is the angle at which particles will randomly be emitted. "
"Increasing the spread will increase the angle. A spread of 180 will emit "
"in all directions."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:71
msgid "Linear velocity"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:73
msgid ""
"Linear velocity is the speed at which particles will be emitted (in "
"pixels/sec). Speed might later be modified by gravity or other "
"accelerations (as described further below)."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:80
msgid "Spin velocity"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:82
msgid ""
"Spin velocity is the speed at which particles turn around their center "
"(in degrees/sec)."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:88
msgid "Orbit velocity"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:90
msgid "Orbit velocity is used to make particles turn around their center."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:95
msgid "Gravity direction & strength"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:97
msgid ""
"Gravity can be modified as in direction and strength. Gravity affects "
"every particle currently alive."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:103
msgid "Radial acceleration"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:105
msgid ""
"If this acceleration is positive, particles are accelerated away from the"
" center. If negative, they are absorbed towards it."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:111
msgid "Tangential acceleration"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:113
msgid ""
"This acceleration will use the tangent vector to the center. Combining "
"with radial acceleration can do nice effects."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:119
msgid "Damping"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:121
msgid ""
"Damping applies friction to the particles, forcing them to stop. It is "
"specially useful for sparks or explosions, which usually begin with a "
"high linear velocity and then stop as they fade."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:128
msgid "Initial angle"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:130
msgid ""
"Determines the initial angle of the particle (in degress). This parameter"
" is mostly useful randomized."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:136
msgid "Initial & final size"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:138
msgid "Determines the initial and final scales of the particle."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:143
msgid "Color phases"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:145
msgid ""
"Particles can use up to 4 color phases. Each color phase can include "
"transparency."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:148
msgid ""
"Phases must provide an offset value from 0 to 1, and always in ascending "
"order. For example, a color will begin at offset 0 and end in offset 1, "
"but 4 colors might use different offsets, such as 0, 0.2, 0.8 and 1.0 for"
" the different phases:"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:155
msgid "Will result in:"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:160
msgid "Global parameters"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:162
msgid "These parameters affect the behavior of the entire system."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:165
msgid "Lifetime"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:167
msgid ""
"The time in seconds that every particle will stay alive. When lifetime "
"ends, a new particle is created to replace it."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:170
msgid "Lifetime: 0.5"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:174
msgid "Lifetime: 4.0"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:179
msgid "Timescale"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:181
msgid ""
"It happens often that the effect achieved is perfect, except too fast or "
"too slow. Timescale helps adjust the overall speed."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:184
msgid "Timescale everything 2x:"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:189
msgid "Preprocess"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:191
msgid ""
"Particle systems begin with 0 particles emitted, then start emitting. "
"This can be an inconvenience when just loading a scene and systems like a"
" torch, mist, etc begin emitting the moment you enter. Preprocess is used"
" to let the system process a given amount of seconds before it is "
"actually shown the first time."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:198
msgid "Emit timeout"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:200
msgid ""
"This variable will switch emission off after given amount of seconds "
"being on. When zero, itś disabled."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:204
msgid "Offset"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:206
msgid "Allows to move the emission center away from the center"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:209
msgid "Half extents"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:211
msgid ""
"Makes the center (by default 1 pixel) wider, to the size in pixels "
"desired. Particles will emit randomly inside this area."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:216
msgid ""
"It is also possible to set an emission mask by using this value. Check "
"the \"Particles\" menu on the 2D scene editor viewport and select your "
"favorite texture. Opaque pixels will be used as potential emission "
"location, while transparent ones will be ignored:"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:224
msgid "Local space"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:226
msgid ""
"By default this option is on, and it means that the space that particles "
"are emitted to is contained within the node. If the node is moved, all "
"particles are moved with it:"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:232
msgid ""
"If disabled, particles will emit to global space, meaning that if the "
"node is moved, the emissor is moved too:"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:238
msgid "Explosiveness"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:240
msgid ""
"If lifetime is 1 and there are 10 particles, it means every particle will"
" be emitted every 0.1 seconds. The explosiveness parameter changes this, "
"and forces particles to be emitted all together. Ranges are:"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:244
msgid "0: Emit all particles together."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:245
msgid "1: Emit particles at equal interval."
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:247
msgid ""
"Values in the middle are also allowed. This feature is useful for "
"creating explosions or sudden bursts of particles:"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:253
msgid "Randomness"
msgstr ""

#: ../../tutorials/2d/particle_systems_2d.rst:255
msgid ""
"All physics parameters can be randomized. Random variables go from 0 to "
"1. the formula to randomize a parameter is:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:4
msgid "Physics introduction"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:6
msgid ""
"Our world is made of tangible matter. In our world, a piano can't go "
"through a wall when going into a house. It needs to use the door. Video "
"games are often like the the real world and Pac-Man can't go through the "
"walls of his maze (although he can teleport from the left to the right "
"side of the screen and back)."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:12
msgid ""
"Anyway, moving sprites around is nice but one day they have to collide "
"properly, so let's get to the point."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:16
msgid "Shapes"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:18
msgid ""
"The base collidable object in Godot's 2D world is a :ref:`Shape2D "
"<class_Shape2D>`. There are many types of shapes, all of them inherit "
"this base class:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:22
msgid ":ref:`CircleShape2D <class_CircleShape2D>`"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:23
msgid ":ref:`RectangleShape2D <class_RectangleShape2D>`"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:24
msgid ":ref:`CapsuleShape2D <class_CapsuleShape2D>`"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:25
msgid ":ref:`ConvexPolygonShape2D <class_ConvexPolygonShape2D>`"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:26
msgid ":ref:`ConcavePolygonShape2D <class_ConcavePolygonShape2D>`"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:27
msgid "etc. (there are others check the class list)."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:29
msgid ""
"Shapes are of type :ref:`Resource <class_Resource>`, but they can be "
"created via code easily. For example:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:43
msgid ""
"The main use for shapes is checking collision/intersection and getting "
"resolution information. Shapes are mostly convex, (except the "
"concavepolygon one, which is just a list of segments to check collision "
"against). This collision check is done easily with the built-in functions"
" like:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:55
msgid ""
"Godot will return correct collision and collision info from the different"
" calls to the Shape2D api. Collision between all shapes and transforms "
"can be done this way, or even obtaining contact information, motion "
"casting, etc."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:61
msgid "Transforming shapes"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:63
msgid ""
"As seen before in the collide functions, 2D shapes in godot can be "
"transformed by using a regular :ref:`Matrix32 <class_Matrix32>` "
"transform, meaning the can check collision while scaled, moved and "
"rotated. The only limitation to this is that shapes with curved sections "
"(such as circle and capsule) can only be scaled uniformly. This means "
"that circle or capsule shapes scaled in the form of an ellipse **will not"
" work properly**. This is a limitation on the collision algorithm used "
"(SAT), so make sure that your circle and capsule shapes are always scaled"
" uniformly!"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:76
msgid "When problems begin"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:78
msgid ""
"Even though this sounds good, reality is that collision detection alone "
"is usually not enough in most scenarios. Many problems start arising as "
"long as the development of the game is in progress:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:83
msgid "Too many combinations!"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:85
msgid ""
"Games have several dozens, hundreds, thousands! of objects that can "
"collide and be collided. The typical approach is to test everything "
"against everything in two for loops like this:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:96
msgid ""
"But this scales really bad. Let's imagine there are only 100 objects in "
"the game. This means that 100\\*100=10000 collisions will need to be "
"tested each frame. This is a lot!"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:101
msgid "Visual aid"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:103
msgid ""
"Most of the time, creating a shape via code is not enough. We need to "
"visually place it over a sprite, draw a collision polygon, etc. It is "
"obvious that we need nodes to create the proper collision shapes in a "
"scene."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:109
msgid "Collision resolution"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:111
msgid ""
"Imagine we solved the collision issue, we can tell easily and quickly "
"which shapes overlap. If many of them are dynamic objects that move "
"around, or move according to newtonian physics, solving a collision of "
"multiple objects can be really difficult code-wise."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:117
msgid "Introducing... Godot's physics engine!"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:119
msgid ""
"To solve all these problems, Godot has a physics and collision engine "
"that is well integrated into the scene system, yet it allows different "
"levels and layers of functionality. The built-in physics engine can be "
"used for:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:124
msgid "Simple Collision Detection: See :ref:`Shape2D <class_Shape2D>` API."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:126
msgid ""
"Scene Kinematics: Handle shapes, collisions, broadphase, etc as nodes. "
"See :ref:`Area2D <class_Area2D>`."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:128
msgid ""
"Scene Physics: Rigid bodies and constraints as nodes. See "
":ref:`RigidBody2D <class_RigidBody2D>`, and the joint nodes."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:132
msgid "Units of measure"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:134
msgid ""
"It is often a problem when integrating a 2D physics engine to a game that"
" such engines are optimized to work using meters as unit of measure. "
"Godot uses a built-in custom 2D physics engine that is designed to "
"function properly in pixels, so all units and default values used for "
"stabilization are tuned for this, making development more "
"straightforward."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:142
msgid "CollisionObject2D"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:144
msgid ""
":ref:`CollisionObject2D <class_CollisionObject2D>` is the (virtual) base "
"node for everything that can be collided in 2D. Area2D, StaticBody2D, "
"KinematicBody2D and RigidBody2D all inherit from it. This node contains a"
" list of shapes (Shape2D) and a relative transform. This means that all "
"collisionable objects in Godot can use multiple shapes at different "
"transforms (offset/scale/rotation). Just remember that, as mentioned "
"before, **non-uniform scale will not work for circle and capsule "
"shapes**."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:156
msgid "StaticBody2D"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:158
msgid ""
"The simplest node in the physics engine is the StaticBody2D, which "
"provides a static collision. This means that other objects can collide "
"against it, but StaticBody2D will not move by itself or generate any kind"
" of interaction when colliding other bodies. It's just there to be "
"collided."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:164
msgid "Creating one of those bodies is not enough, because it lacks collision:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:168
msgid ""
"From the previous point, we know that CollisionObject2D derived nodes "
"have an internal lists of shapes and transforms for collisions, but how "
"to edit them? There are two special nodes for that."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:173
msgid "CollisionShape2D"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:175
msgid ""
"This node is a helper node. It must be created as a direct children of a "
"CollisionObject2D derived node: :ref:`Area2D <class_Area2D>`, "
":ref:`StaticBody2D <class_StaticBody2D>`, :ref:`KinematicBody2D "
"<class_KinematicBody2D>`, :ref:`RigidBody2D <class_RigidBody2D>`."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:180
msgid ""
"By itself it does nothing, but when created as a child of the above "
"mentioned nodes, it adds collision shapes to them. Any amount of "
"CollisionShape2D children can be created, meaning the parent object will "
"simply have more collision shapes. When added/deleted/moved/edited, it "
"updates the list of shapes in the parent node."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:186
msgid ""
"At run time, though, this node does not exist (can't be accessed with "
"``get_node()``), since it's only meant to be an editor helper. To access "
"the shapes created at runtime, use the CollisionObject2D API directly."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:190
msgid ""
"As an example, here's the scene from the platformer, containing an Area2D"
" with child CollisionObject2D and coin sprite:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:196
msgid "Triggers"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:198
msgid ""
"A CollisionShape2D or CollisionPolygon2D can be set as a trigger. When "
"used in a RigidBody2D or KinematicBody2D, \"trigger\" shapes become non-"
"collidable (objects can't collide against it). They just move around with"
" the object as ghosts. This makes them useful in two situations:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:203
msgid "Disabling collision in a specific shape."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:204
msgid ""
"Get an Area2D to trigger a body_enter / body_exit signals with non "
"collidable objects (useful in several situations)."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:208
msgid "CollisionPolygon2D"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:210
msgid ""
"This one is similar to CollisionShape2D, except that instead of assigning"
" a shape, a polygon can be edited (drawn by the user) to determine the "
"shape. The polygon can be convex or concave, it doesn't matter."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:215
msgid ""
"Going back, here's the scene with the StaticBody2D, the static body is "
"the child of a sprite (meaning if the sprite moves, the collision does "
"too). In turn, the CollisionPolygon is a child of staticbody, meaning it "
"adds collision shapes to it."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:222
msgid ""
"In fact, what CollisionPolygon does is to decompose the polygon in convex"
" shapes (shapes can only be convex, remember?) and adds them to the "
"CollisionObject2D:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:229
msgid "KinematicBody2D"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:231
msgid ""
":ref:`KinematicBody2D <class_KinematicBody2D>` bodies are special types "
"of bodies that are meant to be user-controlled. They are not affected by "
"the physics at all (to other types of bodies, such a character or a "
"rigidbody, these are the same as a staticbody). They have however, two "
"main uses:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:237
msgid ""
"**Simulated Motion**: When these bodies are moved manually, either from "
"code or from an :ref:`AnimationPlayer <class_AnimationPlayer>` (with "
"process mode set to fixed!), the physics will automatically compute an "
"estimate of their linear and angular velocity. This makes them very "
"useful for moving platforms or other AnimationPlayer-controlled objects "
"(like a door, a bridge that opens, etc). As an example, the 2d/platformer"
" demo uses them for moving platforms."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:245
msgid ""
"**Kinematic Characters**: KinematicBody2D also has an api for moving "
"objects (the move() function) while performing collision tests. This "
"makes them really useful to implement characters that collide against a "
"world, but that don't require advanced physics. There is a tutorial about"
" :ref:`doc_kinematic_character_2d`."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:252
msgid "RigidBody2D"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:254
msgid ""
"This type of body simulates newtonian physics. It has mass, friction, "
"bounce, and the 0,0 coordinates simulates the center of mass. When real "
"physics are needed, :ref:`RigidBody2D <class_RigidBody2D>` is the node to"
" use. The motion of this body is affected by gravity and/or other bodies."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:260
msgid ""
"Rigid bodies are usually active all the time, but when they end up in "
"resting position and don't move for a while, they are put to sleep until "
"something else wakes them up. This saves an enormous amount of CPU."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:264
msgid ""
"RigidBody2D nodes update their transform constantly, as it is generated "
"by the simulation from a position, linear velocity and angular velocity. "
"As a result, [STRIKEOUT:this node can't be scaled]. Scaling the children "
"nodes should work fine though."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:269
msgid ""
"As a plus, as this is very common in games, it is possible to change a "
"RigidBody2D node to behave like a Character (no rotation), StaticBody or "
"KinematicBody according to different situations (example, an enemy frozen"
" by an ice beam becomes a StaticBody)"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:274
msgid ""
"The best way to interact with a RigidBody2D is during the force "
"integration callback. In this very moment, the physics engine "
"synchronizes state with the scene and allows full modification of the "
"internal parameters (otherwise, as it may be running in a thread, changes"
" will not take place until next frame). To do this, the following "
"function must be overridden:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:286
msgid ""
"The \"state\" parameter is of type :ref:`Physics2DDirectBodyState "
"<class_Physics2DDirectBodyState>`. Please do not use this object (state) "
"outside the callback as it will result in an error."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:291
msgid "Contact reporting"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:293
msgid ""
"In general, RigidBody2D will not keep track of the contacts, because this"
" can require a huge amount of memory if thousands of rigid bodies are in "
"the scene. To get contacts reported, simply increase the amount of the "
"\"contacts reported\" property from zero to a meaningful value (depending"
" on how many you are expecting to get). The contacts can be later "
"obtained via the :ref:`Physics2DDirectBodyState.get_contact_count() "
"<class_Physics2DDirectBodyState_get_contact_count>` and related "
"functions."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:302
msgid ""
"Contact monitoring via signals is also available (signals similar to the "
"ones in Area2D, described below) via a boolean property."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:306
msgid "Area2D"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:308
msgid "Areas in Godot physics have three main roles:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:310
msgid ""
"1. Override the space parameters for objects entering them (ie. gravity, "
"gravity direction, gravity type, density, etc)."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:313
msgid "Monitor when rigid or kinematic bodies enter or exit the area."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:315
msgid "Monitor other areas (this is the simplest way to get overlap test)"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:317
msgid ""
"The second function is the most common. For it to work, the "
"\"monitoring\" property must be enabled (it is by default). There are two"
" types of signals emitted by this node:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:336
msgid ""
"By default, areas also receive mouse/touchscreen input, providing a "
"lower-level way than controls to implement this kind of input in a game. "
"Bodies support this but it's disabled by default."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:341
msgid "In case of overlap, who receives collision information?"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:343
msgid ""
"Remember that not every combination of two bodies can \"report\" "
"contacts. Static bodies are passive and will not report contacts when "
"hit. Kinematic Bodies will report contacts but only against "
"Rigid/Character bodies. Area2D will report overlap (not detailed "
"contacts) with bodies and with other areas. The following table should "
"make it more visual:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:350
msgid "**Type**"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:350
msgid "*RigidBody*"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:350
msgid "*CharacterBody*"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:350
msgid "*KinematicBody*"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:350
msgid "*StaticBody*"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:350
msgid "*Area*"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:352
msgid "**RigidBody**"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:352
#: ../../tutorials/2d/physics_introduction.rst:354
#: ../../tutorials/2d/physics_introduction.rst:356
#: ../../tutorials/2d/physics_introduction.rst:360
msgid "Both"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:352
msgid "Rigidbody"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:352
#: ../../tutorials/2d/physics_introduction.rst:354
#: ../../tutorials/2d/physics_introduction.rst:356
#: ../../tutorials/2d/physics_introduction.rst:360
msgid "Area"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:354
msgid "**CharacterBody**"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:354
#: ../../tutorials/2d/physics_introduction.rst:358
msgid "CharacterBody"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:356
msgid "**KinematicBody**"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:356
#: ../../tutorials/2d/physics_introduction.rst:358
#: ../../tutorials/2d/physics_introduction.rst:360
msgid "None"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:358
msgid "**StaticBody**"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:358
msgid "RigidBody"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:360
msgid "**Area**"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:364
msgid "Physics global variables"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:366
msgid ""
"A few global variables can be tweaked in the project settings for "
"adjusting how 2D physics works:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:371
msgid ""
"Leaving them alone is best (except for the gravity, that needs to be "
"adjusted in most games), but there is one specific parameter that might "
"need tweaking which is the \"cell_size\". Godot 2D physics engine used by"
" default a space hashing algorithm that divides space in cells to compute"
" close collision pairs more efficiently."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:377
msgid ""
"If a game uses several colliders that are really small and occupy a small"
" portion of the screen, it might be necessary to shrink that value "
"(always to a power of 2) to improve efficiency. Likewise if a game uses "
"few large colliders that span a huge map (of several screens of size), "
"increasing that value a bit might help save resources."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:384
msgid "Fixed process callback"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:386
msgid ""
"The physics engine may spawn multiple threads to improve performance, so "
"it can use up to a full frame to process physics. Because of this, when "
"accessing physics variables such as position, linear velocity, etc. they "
"might not be representative of what is going on in the current frame."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:391
msgid ""
"To solve this, Godot has a fixed process callback, which is like process "
"but it's called once per physics frame (by default 60 times per second). "
"During this time, the physics engine is in *synchronization* state and "
"can be accessed directly and without delays."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:396
msgid ""
"To enable a fixed process callback, use the ``set_fixed_process()`` "
"function, example:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:410
msgid "Casting rays and motion queries"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:412
msgid ""
"It is very often desired to \"explore\" the world around from our code. "
"Throwing rays is the most common way to do it. The simplest way to do "
"this is by using the RayCast2D node, which will throw a ray every frame "
"and record the intersection."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:417
msgid ""
"At the moment there isn't a high level API for this, so the physics "
"server must be used directly. For this, the "
":ref:`Physics2DDirectspaceState <class_Physics2DDirectspaceState>` class "
"must be used. To obtain it, the following steps must be taken:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:422
msgid ""
"1. It must be used inside the ``_fixed_process()`` callback, or at "
"``_integrate_forces()``"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:425
msgid "The 2D RIDs for the space and physics server must be obtained."
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:427
msgid "The following code should work:"
msgstr ""

#: ../../tutorials/2d/physics_introduction.rst:435
msgid "Enjoy doing space queries!"
msgstr ""

#: ../../tutorials/2d/screen-reading_shaders.rst:4
msgid "Screen-reading shaders"
msgstr ""

#: ../../tutorials/2d/screen-reading_shaders.rst:9
msgid ""
"Very often it is desired to make a shader that reads from the same screen"
" it's writing to. 3D APIs such as OpenGL or DirectX make this very "
"difficult because of internal hardware limitations. GPUs are extremely "
"parallel, so reading and writing causes all sort of cache and coherency "
"problems. As a result, not even the most modern hardware supports this "
"properly."
msgstr ""

#: ../../tutorials/2d/screen-reading_shaders.rst:16
msgid ""
"The workaround is to make a copy of the screen, or a part of the screen, "
"to a back-buffer and then read from it while drawing. Godot provides a "
"few tools that makes this process easy!"
msgstr ""

#: ../../tutorials/2d/screen-reading_shaders.rst:21
msgid "TexScreen shader instruction"
msgstr ""

#: ../../tutorials/2d/screen-reading_shaders.rst:23
msgid ""
"Godot :ref:`doc_shading_language` has a special instruction, "
"\"texscreen\", it takes as parameter the UV of the screen and returns a "
"vec3 RGB with the color. A special built-in varying: SCREEN_UV can be "
"used to obtain the UV for the current fragment. As a result, this simple "
"2D fragment shader:"
msgstr ""

#: ../../tutorials/2d/screen-reading_shaders.rst:32
msgid ""
"results in an invisible object, because it just shows what lies behind. "
"The same shader using the visual editor looks like this:"
msgstr ""

#: ../../tutorials/2d/screen-reading_shaders.rst:38
msgid "TexScreen example"
msgstr ""

#: ../../tutorials/2d/screen-reading_shaders.rst:40
msgid ""
"Texscreen instruction can be used for a lot of things. There is a special"
" demo for *Screen Space Shaders*, that you can download to see and learn."
" One example is a simple shader to adjust brightness, contrast and "
"saturation:"
msgstr ""

#: ../../tutorials/2d/screen-reading_shaders.rst:60
msgid "Behind the scenes"
msgstr ""

#: ../../tutorials/2d/screen-reading_shaders.rst:62
msgid ""
"While this seems magical, it's not. The Texscreen instruction, when first"
" found in a node that is about to be drawn, does a full-screen copy to a "
"back-buffer. Subsequent nodes that use texscreen() in shaders will not "
"have the screen copied for them, because this ends up being very "
"inefficient."
msgstr ""

#: ../../tutorials/2d/screen-reading_shaders.rst:68
msgid ""
"As a result, if shaders that use texscreen() overlap, the second one will"
" not use the result of the first one, resulting in unexpected visuals:"
msgstr ""

#: ../../tutorials/2d/screen-reading_shaders.rst:74
msgid ""
"In the above image, the second sphere (top right) is using the same "
"source for texscreen() as the first one below, so the first one "
"\"disappears\", or is not visible."
msgstr ""

#: ../../tutorials/2d/screen-reading_shaders.rst:78
msgid ""
"To correct this, a :ref:`BackBufferCopy <class_BackBufferCopy>` node can "
"be instanced between both spheres. BackBufferCopy can work by either "
"specifying a screen region or the whole screen:"
msgstr ""

#: ../../tutorials/2d/screen-reading_shaders.rst:85
msgid "With correct back-buffer copying, the two spheres blend correctly:"
msgstr ""

#: ../../tutorials/2d/screen-reading_shaders.rst:90
msgid "Back-buffer logic"
msgstr ""

#: ../../tutorials/2d/screen-reading_shaders.rst:92
msgid ""
"So, to make it clearer, here's how the backbuffer copying logic works in "
"Godot:"
msgstr ""

#: ../../tutorials/2d/screen-reading_shaders.rst:95
msgid ""
"If a node uses the texscreen(), the entire screen is copied to the back "
"buffer before drawing that node. This only happens the first time, "
"subsequent nodes do not trigger this."
msgstr ""

#: ../../tutorials/2d/screen-reading_shaders.rst:98
msgid ""
"If a BackBufferCopy node was processed before the situation in the point "
"above (even if texscreen() was not used), this behavior described in the "
"point above does not happen. In other words, automatic copying of the "
"entire screen only happens if texscreen() is used in a node for the first"
" time and no BackBufferCopy node (not disabled) was found before in tree-"
"order."
msgstr ""

#: ../../tutorials/2d/screen-reading_shaders.rst:104
msgid ""
"BackBufferCopy can copy either the entire screen or a region. If set to "
"only a region (not the whole screen) and your shader uses pixels not in "
"the region copied, the result of that read is undefined (most likely "
"garbage from previous frames). In other words, it's possible to use "
"BackBufferCopy to copy back a region of the screen and then use "
"texscreen() on a different region. Avoid this behavior!"
msgstr ""

#: ../../tutorials/2d/size_and_anchors.rst:4
msgid "尺寸与锚点"
msgstr ""

#: ../../tutorials/2d/size_and_anchors.rst:6
msgid "如果一个游戏只运行在一些分辨率相同的设备上，那就简单了，只需要设置各自的坐标即可。不幸的是，这种情况几乎没有。"
msgstr ""

#: ../../tutorials/2d/size_and_anchors.rst:8
msgid "如今，只有电视拥有标准的分辨率和宽高比。其他设备，从pc到平板，从掌机到手机都有不同的分辨率和宽高比。"
msgstr ""

#: ../../tutorials/2d/size_and_anchors.rst:10
msgid "解决这些问题有很多方法，但是现在，让我们想象一下，当屏幕分辨率改变时，控件需要重新定位。一些需要保持在屏幕底部，一些在屏幕顶部、左边或右边等等。"
msgstr ""

#: ../../tutorials/2d/size_and_anchors.rst:14
msgid ""
"通过设置控件的 *margin* 属性可以很容易实现。每个控件都有4个边距(margin)：left,right,top,bottom"
"。默认情况下，它们表示控件相对于父级左上角(top-left)的距离（单位：像素），如果没有父级，则相对于视窗左上角。"
msgstr ""

#: ../../tutorials/2d/size_and_anchors.rst:18
msgid ""
"当水平方向(left,right)或垂直方向(top,bottom)设置为 END 时，magin值就变为相对于父级或视窗的右下角(bottom-"
"right)定位。 （可能描述得不是很清楚，自己在编辑器里面试一试就会非常明白了）"
msgstr ""

#: ../../tutorials/2d/size_and_anchors.rst:23
msgid "下面就是右下角定位的例子，控件始终保持20像素的边距："
msgstr ""

#: ../../tutorials/2d/size_and_anchors.rst:27
msgid "最后，也可以设置比例，0表示最左，1表示最右。"
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:4
msgid "Using tilemaps"
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:9
msgid ""
"Tilemaps are a simple and quick way to make 2D game levels. Basically, "
"you start with bunch of reference tiles (or pieces) that can be put in a "
"grid, as many times each as desired:"
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:15
msgid ""
"Collisions can also be added to the tiles, allowing for both 2D side "
"scrolling and top down games."
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:19
msgid "Making a tileset"
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:21
msgid ""
"To begin, a tileset needs to be made. Here are some tiles for it. They "
"are all in the same image because artists will often prefer this. Having "
"them as separate images also works."
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:27
msgid "Create a new project and move the above png image into the directory."
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:29
msgid ""
"We will be creating a :ref:`TileSet <class_TileSet>` resource. While this"
" resource exports properties, it's pretty difficult to get complex data "
"into it and maintain it:"
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:35
msgid ""
"There's enough properties to get by, and with some effort editing this "
"way can work, but the easiest way to edit and maintain a tileset is with "
"the export tool!"
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:40
msgid "TileSet scene"
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:42
msgid ""
"Create a new scene with a regular node or node2d as root. For each tile, "
"add a sprite as a child. Since tiles here are 50x50, enabling snap might "
"be a good idea."
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:46
msgid ""
"If more than one tile is present in the source image, make sure to use "
"the region property of the sprite to adjust which part of the texture is "
"being used."
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:50
msgid ""
"Finally, make sure to name your sprite node correctly, this will ensure "
"that, in subsequent edits to the tileset (for example, if added "
"collision, changed the region, etc), the tile will still be **identified "
"correctly and updated**. This name should be unique."
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:55
msgid ""
"Sounds like a lot of requirements, so here's a screenshot that shows "
"where everything of relevance is:"
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:60
msgid ""
"Continue adding all the tiles, adjusting the offsets if needed (if you "
"have multiple tiles in a single source image). Again, remember that their"
" names must be unique."
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:67
msgid "Collision"
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:69
msgid ""
"To add collision to a tile, create a StaticBody2D child for each sprite. "
"This is a static collision node. Then, as a child of the StaticBody2D, "
"create a CollisionShape2D or CollisionPolygon. The latter is recommended "
"because it is easier to edit:"
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:76
msgid ""
"Finally, edit the polygon, this will give the tile a collision. "
"**Remember to use snap!**. Using snap will make sure collision polygons "
"are aligned properly, allowing a character to walk seamlessly from tile "
"to tile. Also **do not scale or move** the collision and/or collision "
"polygon nodes. leave them at offset 0,0, with scale 1,1 and rotation 0 "
"respect to the parent sprite."
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:85
msgid ""
"Keep adding collisions to tiles until we are done. Note that BG is just a"
" background, so it should not have a collision."
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:90
msgid ""
"OK! We're done! Remember to save this scene for future edit, call it "
"\"tileset_edit.scn\" or something like that."
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:94
msgid "Exporting a TileSet"
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:96
msgid ""
"With the scene created and opened in the editor, next step will be to "
"create a tileset. Use Scene > Convert To > Tile Set from the Scene Menu:"
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:101
msgid ""
"Then choose a filename, like \"mytiles.res\". Make sure the \"Merge With "
"Existing\" option is toggled on. This way, every time the tileset "
"resource file is overwritten, existing tiles are merged and updated (they"
" are referenced by their unique name, so again, **name your tiles "
"properly**)."
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:110
msgid "Using the TileSet in a TileMap"
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:112
msgid ""
"Create a new scene, use any node or node2d as root, then create a "
":ref:`TileMap <class_TileMap>` as a child."
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:118
msgid ""
"Go to the tileset property of this node and assign the one created in "
"previous steps:"
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:123
msgid ""
"Also set the cell size to '50', since that is the size used by the tiles."
" Quadrant size is a tuning value, which means that the engine will draw "
"and cull the tilemap in blocks of 16x16 tiles. This value is usually fine"
" and does not need to be changed, but can be used to tune performance in "
"specific cases (if you know what you are doing)."
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:130
msgid "Painting your world"
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:132
msgid ""
"With all set, make sure the TileMap node is selected. A red grid will "
"appear on screen, allowing to paint on it with the selected tile on the "
"left palette."
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:138
msgid ""
"To avoid moving and selecting the tilemap node accidentally (something "
"common given it's a huge node), it is recommended that you lock it, using"
" the lock button:"
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:145
msgid "Offset and scaling artifacts"
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:147
msgid ""
"When using a single texture for all the tiles, scaling the tileset (or "
"even moving to a non pixel-aligned location) will most likely result in "
"filtering artifacts like this:"
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:153
msgid ""
"This can't be avoided, as it is the way the hardware bilinear filter "
"works. So, to avoid this situation, there are a few workarounds, try the "
"ones that look better for you:"
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:157
msgid ""
"Use a single image for each tile, this will remove all artifacts but can "
"be more cumbersome to implement, so try the options below first."
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:159
msgid ""
"Disable filtering for either the tileset texture or the entire image "
"loader (see the :ref:`doc_managing_image_files` asset pipeline tutorial)."
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:161
msgid ""
"Enable pixel snap (set: \"Scene > Project Settings > "
"Display/use_2d_pixel_snap\" to true)."
msgstr ""

#: ../../tutorials/2d/using_tilemaps.rst:163
msgid ""
"Viewport Scaling can often help with shrinking the map (see the "
":ref:`doc_viewports` tutorial)."
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:4
msgid "视窗与画布变换(Viewport and canvas transforms)"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:7
#: ../../tutorials/step_by_step/animations.rst:7
#: ../../tutorials/step_by_step/filesystem.rst:7
#: ../../tutorials/step_by_step/gui_tutorial.rst:7
#: ../../tutorials/step_by_step/scene_tree.rst:7
#: ../../tutorials/step_by_step/scenes_and_nodes.rst:7
#: ../../tutorials/step_by_step/scripting.rst:7
#: ../../tutorials/step_by_step/singletons_autoload.rst:7
#: ../../tutorials/vector_math.rst:7
msgid "介绍"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:9
msgid "这篇教程创建于一个对于大多数用户来说都比较晦涩难懂的主题之后，并解释了所有节点上的2D变换发生时，在绘制场景时同时其绘制自身。"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:12
msgid "画布变换(Canvas transform)"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:14
msgid ""
"上个教程提到，:ref:`doc_canvas_layers`，每个CanvasItem节点（记住，所有继承自Node2D和Control的节点都以CanvasItem作为其根节点）都属于"
" *Canvas Layer*。每个canvas layer都有一个变换属性（平移，旋转，缩放等），可以通过 :ref:`Matrix32 "
"<class_Matrix32>` 访问。"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:16
msgid ""
"我们知道，默认情况下，节点被绘制在 layer0，可以使用:ref:`CanvasLayer "
"<class_CanvasLayer>`来将节点绘制在不同的层。"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:20
msgid "全局画布变换(Global canvas transform)"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:22
msgid ""
"视窗拥有一个全局画布变换的属性，这是一个:ref:`Matrix32 <class_Matrix32>`。 此属性最主要且影响其他所有 "
"*Canvas Layer*。我们一般不会用到这个属性，但在Godot编辑器中被用作编辑 Canvas Item。"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:26
msgid "拉伸(Stretch transform)"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:28
msgid ""
"视窗有一个 *Stretch Transform* "
"属性，用于屏幕大小变化时。这个属性一般由系统内部调用（详见：:ref:`doc_multiple_resolutions`），但也可以手动设置。"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:30
msgid ""
":ref:`MainLoop._input_event() "
"<class_MainLoop__input_event>`回调发出的Input事件同样受该属性影响。要将事件坐标转化为CanvasItem的坐标，使用:ref:`CanvasItem.make_input_local()"
" <class_CanvasItem_make_input_local>`。"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:33
msgid "变换顺序(Transform order)"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:35
msgid "要将 CanvasItem 的本地坐标转换为屏幕坐标， 需要经过以下流程："
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:40
msgid "变换方法(Transform functions)"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:41
msgid "可以通过以下方法来获取每个变换："
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:44
msgid "Type"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:44
#: ../../tutorials/matrices_and_transforms.rst:253
#: ../../tutorials/matrices_and_transforms.rst:482
msgid "Transform"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:46
msgid "CanvasItem"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:46
msgid ""
":ref:`CanvasItem.get_global_transform() "
"<class_CanvasItem_get_global_transform>`"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:48
msgid "CanvasLayer"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:48
msgid ""
":ref:`CanvasItem.get_canvas_transform() "
"<class_CanvasItem_get_canvas_transform>`"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:50
msgid "CanvasLayer+GlobalCanvas+Stretch"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:50
msgid ""
":ref:`CanvasItem.get_viewport_transform() "
"<class_CanvasItem_get_viewport_transform>`"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:53
msgid "然后，要将CanvasItem的本地坐标转化为屏幕坐标，只需按照下面的顺序相乘："
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:59
msgid "注意，一般不通过屏幕坐标来进行变换，我们建议使用画布的本地坐标(``CanvasItem.get_global_transform()``)来保证屏幕分辨率改变时正确工作。"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:62
msgid "触发自定义事件"
msgstr ""

#: ../../tutorials/2d/viewport_and_canvas_transforms.rst:64
msgid "如需要在场景中触发自定义事件，通过前面的教程，可以这样做："
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:4
msgid "3D performance and limitations"
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:9
msgid ""
"Godot follows a balanced performance philosophy. In performance world, "
"there are always trade-offs, which consist in trading speed for usability"
" and flexibility. Some practical examples of this are:"
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:13
msgid ""
"Rendering objects efficiently in high amounts is easy, but when a large "
"scene must be rendered it can become inefficient. To solve this, "
"visibility computation must be added to the rendering, which makes "
"rendering less efficient, but at the same less objects are rendered, so "
"efficiency overall improves."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:18
msgid ""
"Configuring the properties of every material for every object that needs "
"to be renderer is also slow. To solve this, objects are sorted by "
"material to reduce the costs, but at the same time sorting has a cost."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:22
msgid ""
"In 3D physics a similar situation happens. The best algorithms to handle "
"large amounts of physics objects (such as SAP) are very slow at "
"insertion/removal of objects and ray-casting. Algorithms that allow "
"faster insertion and removal, as well as ray-casting will not be able to "
"handle as many active objects."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:28
msgid ""
"And there are many more examples of this! Game engines strive to be "
"general purpose in nature, so balanced algorithms are always favored over"
" algorithms that might be the fast in some situations and slow in "
"others.. or algorithms that are fast but make usability more difficult."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:33
msgid ""
"Godot is not an exception and, while it is designed to have backends "
"swappable for different algorithms, the default ones (or more like, the "
"only ones that are there for now) prioritize balance and flexibility over"
" performance."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:38
msgid ""
"With this clear, the aim of this tutorial is to explain how to get the "
"maximum performance out of Godot."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:42
msgid "Rendering"
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:44
msgid ""
"3D rendering is one of the most difficult areas to get performance from, "
"so this section will have a list of tips."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:48
msgid "Reuse shaders and materials"
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:50
msgid ""
"Godot renderer is a little different to what is out there. It's designed "
"to minimize GPU state changes as much as possible. :ref:`FixedMaterial "
"<class_FixedMaterial>` does a good job at reusing materials that need "
"similar shaders but, if custom shaders are used, make sure to reuse them "
"as much as possible. Godot's priorities will be like this:"
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:57
msgid ""
"**Reusing Materials**: The less amount of different materials in the "
"scene, the faster the rendering will be. If a scene has a huge amount of "
"objects (in the hundreds or thousands) try reusing the materials or in "
"the worst case use atlases."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:61
msgid ""
"**Reusing Shaders**: If materials can't be reused, at least try to re-use"
" shaders (or FixedMaterials with different parameters but same "
"configuration)."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:65
msgid ""
"If a scene has, for example, 20.000 objects with 20.000 different "
"materials each, rendering will be really slow. If the same scene has "
"20.000 objects, but only uses 100 materials, rendering will be blazing "
"fast."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:71
msgid "Pixels cost vs vertex cost"
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:73
msgid ""
"It is a common thought that the lower the polygons in a model, the faster"
" it will be rendered. This is *really* relative and depends on many "
"factors."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:77
msgid ""
"On a modern PC and consoles, vertex cost is low. Very low. GPUs "
"originally only rendered triangles, so all the vertices:"
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:80
msgid "Had to be transformed by the CPU (including clipping)."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:82
msgid "Had to be sent to the GPU memory from the main RAM."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:84
msgid ""
"Nowadays, all this is handled inside the GPU, so the performance is "
"extremely high. 3D artists usually have the wrong feeling about polycount"
" performance because 3D DCCs (such as Blender, Max, etc.) need to keep "
"geometry in CPU memory in order for it to be edited, reducing actual "
"performance. Truth is, a model rendered by a 3D engine is much more "
"optimal than how 3D DCCs display them."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:91
msgid ""
"On mobile devices, the story is different. PC and Console GPUs are brute-"
"force monsters that can pull as much electricity as they need from the "
"power grid. Mobile GPUs are limited to a tiny battery, so they need to be"
" a lot more power efficient."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:96
msgid ""
"To be more efficient, mobile GPUs attempt to avoid *overdraw*. This "
"means, the same pixel on the screen being rendered (as in, with lighting "
"calculation, etc.) more than once. Imagine a town with several buildings,"
" GPUs don't really know what is visible and what is hidden until they "
"draw it. A house might be drawn and then another house in front of it "
"(rendering happened twice for the same pixel!). PC GPUs normally don't "
"care much about this and just throw more pixel processors to the hardware"
" to increase performance (but this also increases power consumption)."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:106
msgid ""
"On mobile, pulling more power is not an option, so a technique called "
"\"Tile Based Rendering\" is used (almost every mobile hardware uses a "
"variant of it), which divide the screen into a grid. Each cell keeps the "
"list of triangles drawn to it and sorts them by depth to minimize "
"*overdraw*. This technique improves performance and reduces power "
"consumption, but takes a toll on vertex performance. As a result, less "
"vertices and triangles can be processed for drawing."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:114
msgid ""
"Generally, this is not so bad, but there is a corner case on mobile that "
"must be avoided, which is to have small objects with a lot of geometry "
"within a small portion of the screen. This forces mobile GPUs to put a "
"lot of strain on a single screen cell, considerably decreasing "
"performance (as all the other cells must wait for it to complete in order"
" to display the frame)."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:121
msgid ""
"To make it short, do not worry about vertex count so much on mobile, but "
"avoid concentration of vertices in small parts of the screen. If, for "
"example, a character, NPC, vehicle, etc. is far away (so it looks tiny), "
"use a smaller level of detail (LOD) model instead."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:126
msgid ""
"An extra situation where vertex cost must be considered is objects that "
"have extra processing per vertex, such as:"
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:129
msgid "Skinning (skeletal animation)"
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:130
msgid "Morphs (shape keys)"
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:131
msgid "Vertex Lit Objects (common on mobile)"
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:134
#: ../../tutorials/asset_pipeline/importing_textures.rst:108
msgid "Texture compression"
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:136
msgid ""
"Godot offers to compress textures of 3D models when imported (VRAM "
"compression). Video RAM compression is not as efficient in size as PNG or"
" JPG when stored, but increase performance enormously when drawing."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:140
msgid ""
"This is because the main goal of texture compression is bandwidth "
"reduction between memory and the GPU."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:143
msgid ""
"In 3D, the shapes of objects depend more on the geometry than the "
"texture, so compression is generally not noticeable. In 2D, compression "
"depends more on shapes inside the textures, so the artifacting resulting "
"from the compression is more noticeable."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:148
msgid ""
"As a warning, most Android devices do not support texture compression of "
"textures with transparency (only opaque), so keep this in mind."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:152
msgid "Transparent objects"
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:154
msgid ""
"As mentioned before, Godot sorts objects by material and shader to "
"improve performance. This, however, can not be done on transparent "
"objects. Transparent objects are rendered from back to front to make "
"blending with what is behind work. As a result, please try to keep "
"transparent objects to a minimum! If an object has a small section with "
"transparency, try to make that section a separate material."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:162
msgid "Level of detail (LOD)"
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:164
msgid ""
"As also mentioned before, using objects with less vertices can improve "
"performance in some cases. Godot has a very simple system to use level of"
" detail, :ref:`GeometryInstance <class_GeometryInstance>` based objects "
"have a visibility range that can be defined. Having several "
"GeometryInstance objects in different ranges works as LOD."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:172
msgid "Use instancing (MultiMesh)"
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:174
msgid ""
"If several identical objects have to be drawn in the same place or "
"nearby, try using :ref:`MultiMesh <class_MultiMesh>` instead. MultiMesh "
"allows drawing of dozens of thousands of objects at very little "
"performance cost, making it ideal for flocks, grass, particles, etc."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:181
msgid "Bake lighting"
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:183
msgid ""
"Small lights are usually not a performance issue. Shadows a little more. "
"In general, if several lights need to affect a scene, it's ideal to bake "
"it (:ref:`doc_light_baking`). Baking can also improve the scene quality "
"by adding indirect light bounces."
msgstr ""

#: ../../tutorials/3d/3d_performance_and_limitations.rst:188
msgid ""
"If working on mobile, baking to texture is recommended, since this method"
" is even faster."
msgstr ""

#: ../../tutorials/3d/_3d.rst:2
msgid "3D tutorials"
msgstr ""

#: ../../tutorials/3d/_3d_import.rst:2
#: ../../tutorials/asset_pipeline/_import.rst:2
msgid "Import"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:4
msgid "Fixed materials"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:9
msgid ""
"Fixed materials (originally Fixed Pipeline Materials) are the most common"
" type of materials, using the most common material options found in 3D "
"DCCs (such as Maya, 3DS Max or Blender). The big advantage of using them "
"is that 3D artists are very familiar with this layout. They also allow to"
" try out different things quickly without the need of writing shaders. "
"Fixed Materials inherit from :ref:`Material <class_Material>`, which also"
" has several options. If you haven't read it before, reading the "
":ref:`doc_materials` tutorial is recommended."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:20
#: ../../tutorials/3d/importing_3d_meshes.rst:39
msgid "Options"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:22
msgid "Here is the list of all the options available for fixed materials:"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:26
msgid "From this point, every option will be explained in detail:"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:29
msgid "Fixed flags"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:31
msgid "These are a set of flags that control general aspects of the material."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:34
msgid "Use alpha"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:36
msgid ""
"This flag needs to be active for transparent materials to blend with what"
" is behind, otherwise display will always be opaque. Do not enable this "
"flag unless the material really needs it, because it can severely affect "
"performance and quality. Materials with transparency will also not cast "
"shadows (unless they contain opaque areas and the \"opaque pre-pass\" "
"hint is turned on, see the :ref:`doc_materials` tutorial for more "
"information)."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:47
msgid "Use vertex colors"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:49
msgid ""
"Vertex color painting is a very common technique to add detail to "
"geometry. 3D DCCs all support this, and many even support baking "
"occlusion to it. Godot allows this information to be used in the fixed "
"material by modulating the diffuse color when enabled."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:57
msgid "Point size"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:59
msgid ""
"Point size is used to set the point size (in pixels) for when rendering "
"points. This feature is mostly used in tools and HUDs"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:63
msgid "Discard alpha"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:65
msgid ""
"When alpha is enabled (see above) the invisible pixels are blended with "
"what is behind them. In some combinations (of using alpha to render "
"depth) it may be possible that invisible pixels cover other objects."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:70
msgid ""
"If this is the case, enable this option for the material. This option is "
"often used in combination with \"opaque pre-pass\" hint (see the "
":ref:`doc_materials` tutorial for more information)."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:75
#: ../../tutorials/3d/materials.rst:71
msgid "Parameters"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:78
msgid "Diffuse, specular, emission and specular exponent"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:80
msgid "These are the base colors for the material."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:82
msgid ""
"Diffuse color is responsible for the light that reaches the material, "
"then gets diffused around. This color varies by the angle to the light "
"and the distance (in the case of spot and omni lights). It is the color "
"that best represents the material. It can also have alpha (transparency)"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:87
msgid ""
"Specular color is the color of the reflected light and responsible for "
"shines. It is affected by the specular exponent."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:89
msgid ""
"Emission is the color of the light generated within the material "
"(although it will not lit anything else around unless baking). This color"
" is constant."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:92
msgid ""
"Specular Exponent (or \"Shininess\"/\"Intensity\" in some 3D DCCs) is the"
" way light is reflected. If the value is high, light is reflected "
"completely, otherwise it is diffused more and more."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:96
msgid "Below is an example of how they interact:"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:101
msgid "Shader & shader param"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:103
msgid ""
"Regular shader materials allow custom lighting code. Fixed materials come"
" with four predefined shader types:"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:106
msgid ""
"**Lambert**: The standard diffuse light, where the amount of light is "
"proportional to the angle from the light emitter."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:108
msgid ""
"**Wrap**: A variation on Lambert, where the \"coverage\" of the light can"
" be changed. This is useful for many types of materials such as wood, "
"clay, hair, etc."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:111
msgid ""
"**Velvet**: This is similar to Lambert, but adds light scattering in the "
"edges. It's useful for leathers and some types of metals."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:113
msgid ""
"**Toon**: Standard toon shading with a coverage parameter. The specular "
"component also becomes toon-ized."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:119
msgid "Detail & detail mix"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:121
msgid ""
"Detail is a second diffuse texture which can be mixed with the first one "
"(more on textures later!). Detail blend and mix control how these are "
"added together, here's an example of what detail textures are for:"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:128
msgid "Normal depth"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:130
msgid ""
"Normal depth controls the intensity of the normal-mapping as well as the "
"direction. On 1 (the default) normalmapping applies normally, on -1 the "
"map is inverted and on 0 is disabled. Intermediate or greater values are "
"accepted. Here's how it's supposed to look:"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:138
msgid "Glow"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:140
msgid ""
"This value controls how much of the color is sent to the glow buffer. It "
"can be greater than 1 for a stronger effect. For glow to work, a "
"WorldEnvironment must exist with Glow activated."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:147
#: ../../tutorials/3d/materials.rst:76
msgid "Blend mode"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:149
#: ../../tutorials/3d/materials.rst:78
msgid ""
"Objects are usually blended in Mix mode. Other blend modes (Add and Sub) "
"exist for special cases (usually particle effects, light rays, etc.) but "
"materials can be set to them:"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:156
msgid "Point size, line width"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:158
msgid ""
"When drawing points or lines, the size of them can be adjusted here per "
"material."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:162
msgid "Textures"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:164
msgid ""
"Almost all of the parameters above can have a texture assigned to them. "
"There are four options to where they can get their UV coordinates:"
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:167
msgid ""
"**UV Coordinates (UV Array)**: This is the regular UV coordinate array "
"that was imported with the model."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:169
msgid "**UV x UV XForm**: UV Coordinates multiplied by the UV Xform matrix."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:170
msgid ""
"**UV2 Coordinates**: Some imported models might have come with a second "
"set of UV coordinates. These are common for detail textures or for baked "
"light textures."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:173
msgid ""
"**Sphere**: Spherical coordinates (difference of the normal at the pixel "
"by the camera normal)."
msgstr ""

#: ../../tutorials/3d/fixed_materials.rst:176
msgid ""
"The value of every pixel of the texture is multiplied by the original "
"parameter. This means that if a texture is loaded for diffuse, it will be"
" multiplied by the color of the diffuse color parameter. Same applies to "
"all the others except for specular exponent, which is replaced."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:4
msgid "High dynamic range"
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:9
msgid ""
"Normally, an artist does all the 3D modelling, then all the texturing, "
"looks at his or her awesome looking model in the 3D DCC and says \"looks "
"fantastic, ready for integration!\" then goes into the game, lighting is "
"setup and the game runs."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:14
msgid ""
"So where does all this HDR stuff thing come from? The idea is that "
"instead of dealing with colors that go from black to white (0 to 1), we "
"use colors whiter than white (for example, 0 to 8 times white)."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:18
msgid ""
"To be more practical, imagine that in a regular scene, the intensity of a"
" light (generally 1.0) is set to 5.0. The whole scene will turn very "
"bright (towards white) and look horrible."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:22
msgid ""
"After this the luminance of the scene is computed by averaging the "
"luminance of every pixel of it, and this value is used to bring the scene"
" back to normal ranges. This last operation is called tone-mapping. "
"Finally, we are at a similar place from where we started:"
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:30
msgid ""
"Except the scene is more contrasted, because there is a higher light "
"range in play. What is this all useful for? The idea is that the scene "
"luminance will change while you move through the world, allowing "
"situations like this to happen:"
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:37
msgid ""
"Additionally, it is possible to set a threshold value to send to the glow"
" buffer depending on the pixel luminance. This allows for more realistic "
"light bleeding effects in the scene."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:42
msgid "Linear color space"
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:44
msgid ""
"The problem with this technique is that computer monitors apply a gamma "
"curve to adapt better to the way the human eye sees. Artists create their"
" art on the screen too, so their art has an implicit gamma curve applied "
"to it."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:49
msgid ""
"The color space where images created in computer monitors exist is called"
" \"sRGB\". All visual content that people have on their computers or "
"download from the internet (such as pictures, movies, etc.) is in this "
"colorspace."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:56
msgid ""
"The mathematics of HDR require that we multiply the scene by different "
"values to adjust the luminance and exposure to different light ranges, "
"and this curve gets in the way as we need colors in linear space for "
"this."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:62
msgid "Linear color space & asset pipeline"
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:64
msgid ""
"Working in HDR is not just pressing a switch. First, imported image "
"assets must be converted to linear space on import. There are two ways to"
" do this:"
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:69
msgid "SRGB -> linear conversion on image import"
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:71
msgid ""
"This is the most compatible way of using linear-space assets and it will "
"work everywhere including all mobile devices. The main issue with this is"
" loss of quality, as sRGB exists to avoid this same problem. Using 8 bits"
" per channel to represent linear colors is inefficient from the point of "
"view of the human eye. These textures might be later compressed too, "
"which makes the problem worse."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:78
msgid "In any case though, this is the easy solution that works everywhere."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:81
msgid "Hardware sRGB -> linear conversion."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:83
msgid ""
"This is the most correct way to use assets in linear-space, as the "
"texture sampler on the GPU will do the conversion after reading the texel"
" using floating point. This works fine on PC and consoles, but most "
"mobile devices do no support it, or do not support it on compressed "
"texture format (iOS for example)."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:90
msgid "Linear -> sRGB at the end."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:92
msgid ""
"After all the rendering is done, the linear-space rendered image must be "
"converted back to sRGB. To do this, simply enable sRGB conversion in the "
"current :ref:`Environment <class_Environment>` (more on that below)."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:96
msgid ""
"Keep in mind that sRGB [STRIKEOUT:> Linear and Linear]> sRGB conversions "
"must always be **both** enabled. Failing to enable one of them will "
"result in horrible visuals suitable only for avant garde experimental "
"indie games."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:102
msgid "Parameters of HDR"
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:104
msgid ""
"HDR is found in the :ref:`Environment <class_Environment>` resource. "
"These are found most of the time inside a :ref:`WorldEnvironment "
"<class_WorldEnvironment>` node, or set in a camera. There are many "
"parameters for HDR:"
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:112
msgid "ToneMapper"
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:114
msgid ""
"The ToneMapper is the heart of the algorithm. Many options for "
"tonemappers are provided:"
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:117
msgid ""
"Linear: Simplest tonemapper. It does it's job for adjusting scene "
"brightness, but if the differences in light are too big, it will cause "
"colors to be too saturated."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:120
msgid "Log: Similar to linear, but not as extreme."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:121
msgid ""
"Reinhardt: Classical tonemapper (modified so it will not desaturate as "
"much)"
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:123
msgid ""
"ReinhardtAutoWhite: Same as above, but uses the max scene luminance to "
"adjust the white value."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:127
msgid "Exposure"
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:129
msgid ""
"The same exposure parameter as in real cameras. Controls how much light "
"enters the camera. Higher values will result in a brighter scene and "
"lower values will result in a darker scene."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:134
msgid "White"
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:136
msgid "Maximum value of white."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:139
msgid "Glow threshold"
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:141
msgid ""
"Determine above which value (from 0 to 1 after the scene is tonemapped), "
"light will start bleeding."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:145
msgid "Glow scale"
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:147
msgid "Determine how much light will bleed."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:150
msgid "Min luminance"
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:152
msgid ""
"Lower bound value of light for the scene at which the tonemapper stops "
"working. This allows dark scenes to remain dark."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:156
msgid "Max luminance"
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:158
msgid ""
"Upper bound value of light for the scene at which the tonemapper stops "
"working. This allows bright scenes to remain saturated."
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:162
msgid "Exposure adjustment speed"
msgstr ""

#: ../../tutorials/3d/high_dynamic_range.rst:164
msgid ""
"Auto-exposure will change slowly and will take a while to adjust (like in"
" real cameras). Bigger values means faster adjustment."
msgstr ""

#: ../../tutorials/3d/importing_3d_meshes.rst:4
msgid "Importing 3D meshes"
msgstr ""

#: ../../tutorials/3d/importing_3d_meshes.rst:9
msgid ""
"Godot supports a flexible and powerful :ref:`3D scene importer "
"<doc_importing_3d_scenes>` that allows for full scene importing. For a "
"lot of artists and developers this is more than enough. However, many do "
"not like this workflow as much and prefer to import individual 3D Meshes "
"and build the scenes inside the Godot 3D editor themselves. (Note that "
"for more advanced features such as skeletal animation, there is no option"
" to the 3D Scene Importer)."
msgstr ""

#: ../../tutorials/3d/importing_3d_meshes.rst:16
msgid ""
"The 3D mesh import workflow is simple and works using the OBJ file "
"format. The imported meshes result in a .msh binary file which the user "
"can put into a :ref:`class_meshinstance`, which in turn can be placed "
"somewhere in the edited scene."
msgstr ""

#: ../../tutorials/3d/importing_3d_meshes.rst:22
msgid "Importing"
msgstr ""

#: ../../tutorials/3d/importing_3d_meshes.rst:24
msgid "Importing is done through the Import 3D Mesh menu:"
msgstr ""

#: ../../tutorials/3d/importing_3d_meshes.rst:28
msgid "Which opens the Mesh import window:"
msgstr ""

#: ../../tutorials/3d/importing_3d_meshes.rst:32
msgid ""
"This dialog allows the import of one more more OBJ files into a target "
"path. OBJ files are converted to .msh files. Files are imported without "
"any material on them, material has to be added by the user (see the "
":ref:`doc_fixed_materials` tutorial). If the external OBJ file is changed"
" it will be re-imported, while keeping the newly assigned material."
msgstr ""

#: ../../tutorials/3d/importing_3d_meshes.rst:41
msgid ""
"A few options are present. Normals are needed for regular shading, while "
"Tangents are needed if you plan to use normal-mapping on the material. In"
" general, OBJ files describe how to be shaded very well, but an option to"
" force smooth shading is available."
msgstr ""

#: ../../tutorials/3d/importing_3d_meshes.rst:46
msgid ""
"Finally, there is an option to weld vertices. Given OBJ files are text-"
"based, it is common to find some of these with vertices that do not "
"match, which results in strange shading. The weld vertices option merges "
"vertices that are too close to keep proper smooth shading."
msgstr ""

#: ../../tutorials/3d/importing_3d_meshes.rst:52
#: ../../tutorials/engine/background_loading.rst:24
msgid "Usage"
msgstr ""

#: ../../tutorials/3d/importing_3d_meshes.rst:54
msgid ""
"Mesh resources (what this importer imports to) are used inside "
"MeshInstance nodes. Simply set them to the Mesh property of them."
msgstr ""

#: ../../tutorials/3d/importing_3d_meshes.rst:59
msgid "And that is it."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:4
msgid "Importing 3D scenes"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:9
msgid ""
"Most game engines just import 3D objects, which may contain skeletons or "
"animations, and then all further work is done in the engine UI, like "
"object placement, full scene animations, etc. In Godot, given the node "
"system is very similar to how 3D DCC tools (such as Maya, 3DS Max or "
"Blender) work, full 3D scenes can be imported in all their glory. "
"Additionally, by using a simple language tag system, it is possible to "
"specify that objects are imported as several things, such as collidable, "
"rooms and portals, vehicles and wheels, LOD distances, billboards, etc."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:18
msgid "This allows for some interesting features:"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:20
msgid "Importing simple scenes, rigged objects, animations, etc."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:21
msgid ""
"Importing full scenes. Entire scenarios can be created and updated in the"
" 3D DCC and imported to Godot each time they change, then only little "
"editing is needed from the engine side."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:24
msgid ""
"Full cutscenes can be imported, including multiple character animation, "
"lighting, camera motion, etc."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:26
msgid ""
"Scenes can be further edited and scripted in the engine, where shaders "
"and environment effects can be added, enemies can be instanced, etc. The "
"importer will update geometry changes if the source scene changes but "
"keep the local changes too (in real-time while using the Godot editor!)"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:31
msgid ""
"Textures can be all batch-imported and updated when the source scene "
"changes."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:34
msgid ""
"This is achieved by using a very simple language tag that will be "
"explained in detail later."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:38
msgid "Exporting DAE files"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:41
msgid "Why not FBX?"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:43
msgid ""
"Most game engines use the FBX format for importing 3D scenes, which is "
"definitely one of the most standardized in the industry. However, this "
"format requires the use of a closed library from Autodesk which is "
"distributed with a more restrictive licensing terms than Godot. The plan "
"is, sometime in the future, to implement an external conversion binary, "
"but meanwhile FBX is not really supported."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:51
msgid "Exporting DAE files from Maya and 3DS Max"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:53
msgid ""
"Autodesk added built-in collada support to Maya and 3DS Max, but It's "
"really broken and should not be used. The best way to export this format "
"is by using the `OpenCollada "
"<https://github.com/KhronosGroup/OpenCOLLADA/wiki/OpenCOLLADA-Tools>`__ "
"plugins. They work really well, although they are not always up-to date "
"with the latest version of the software."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:61
msgid "Exporting DAE files from Blender"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:63
msgid ""
"Blender also has built-in collada support, but It's really broken and "
"should not be used either."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:66
msgid ""
"Godot provides a `Python Plugin "
"<https://github.com/godotengine/godot/tree/master/tools/export/blender25>`__"
" that will do a much better job at exporting the scenes."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:71
msgid "The import process"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:73
msgid "Import process begins with the 3D scene import menu:"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:77
msgid "That opens what is probably the biggest of all the import dialogs:"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:81
msgid "Many options exist in there, so each section will be explained as follows:"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:85
msgid "Source & target paths"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:87
msgid ""
"To import, two options are needed. The first is a source .dae file (.dae "
"stands for Collada. More import formats will eventually added, but "
"Collada is the most complete open format as of this writing)."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:91
msgid ""
"A target folder needs to be provided, so the importer can import the "
"scene there. The imported scene will have the same filename as the source"
" one, except for the .scn extension, so make sure you pick good names "
"when you export!"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:96
msgid ""
"The textures will be copied and converted. Textures in 3D applications "
"are usually just PNG or JPG files. Godot will convert them to video "
"memory texture compression format (s3tc, pvrtc, ericsson, etc.) by "
"default to improve performance and save resources."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:101
msgid ""
"Since the original textures, 3D file and textures are usually not needed,"
" it's recommended to keep them outside the project. For some hints on how"
" to do this the best way, you can check the "
":ref:`doc_project_organization` tutorial."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:106
msgid ""
"Two options for textures are provided. They can be copied to the same "
"place as the scene, or they can be copied to a common path (configurable "
"in the project settings). If you choose this, make sure no two textures "
"are named the same."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:112
msgid "3D rigging tips"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:114
msgid ""
"Before going into the options, here are some tips for making sure your "
"rigs import properly"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:117
msgid ""
"Only up to 4 weights are imported per vertex, if a vertex depends of more"
" than 4 bones, only the 4 most important bones (the one with the most "
"weight) will be imported. For most models this usually works fine, but "
"just keep it in mind."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:121
msgid ""
"Do not use non-uniform scale in bone animation, as this will likely not "
"import properly. Try to accomplish the same effect with more bones."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:124
msgid ""
"When exporting from Blender, make sure that objects modified by a "
"skeleton are children of it. Many objects can be modified by a single "
"skeleton, but they all should be direct children."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:127
msgid ""
"The same way, when using Blender, make sure that the relative transform "
"of children nodes to the skeleton is zero (no rotation, no translation, "
"no scale. All zero and scale at 1.0). The position of both objects (the "
"little orange dot) should be at the same place."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:133
msgid "3D import options"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:135
msgid ""
"This section contains many options to change the way import workflow "
"works. Some (like HDR) will be better explained in other sections, but in"
" general a pattern can be visible in the options and that is, many of the"
" options end with \"-something\". For example:"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:140
msgid "Remove Nodes (-noimp)"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:141
msgid "Set Alpha in Materials (-alpha)"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:142
msgid "Create Collisions (-col)."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:144
msgid ""
"This means that the object names in the 3D DCC need to have those options"
" appended at the end for the importer to tell what they are. When "
"imported, Godot will convert them to what they are meant to be."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:148
msgid "**Note:** Maya users must use “_\" (underscore) instead of \"-\" (minus)."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:150
msgid ""
"Here is an example of how a scene in the 3D DCC looks (using Blender), "
"and how it is imported to Godot:"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:155
msgid "Notice that:"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:157
msgid "The camera was imported normally."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:158
msgid "A Room was created (-room)."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:159
msgid "A Portal was created (-portal)."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:160
msgid "The Mesh got static collision added (-col)."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:161
msgid "The Light was not imported (-noimp)."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:164
msgid "Options in detail"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:166
msgid ""
"Following is a list of most import options and what they do in more "
"detail."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:170
msgid "Remove nodes (-noimp)"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:172
msgid ""
"Node names that have this at the end will be removed at import time, mo "
"matter their type. Erasing them afterwards is most of the times pointless"
" because the will be restored if the source scene changes."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:177
msgid "Import animations"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:179
msgid ""
"Some scene formats (.dae) support one or more animations. If this is "
"checked, an `AnimationPlayer <class_animationplayer>`__ node will be "
"created, containing the animations."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:184
msgid "Compress geometry"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:186
msgid ""
"This option (disabled [STRIKEOUT:or more like, always enabled] at the "
"moment at the time of writing this) will compress geometry so it takes "
"less space and renders faster (at the cost of less precision)."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:191
msgid "Force generation of tangent arrays"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:193
msgid ""
"The importer detects when you have used a normalmap texture, or when the "
"source file contains tangent/binormal information. These arrays are "
"needed for normalmapping to work, and most exporters know what they do "
"when they export this. However, it might be possible to run into source "
"scenes that do not have this information which, as a result, make normal-"
"mapping not work. If you notice that normal-maps do not work when "
"importing the scene, turn this on!"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:202
msgid "SRGB -> linear of diffuse textures"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:204
msgid ""
"When rendering using HDR (High Dynamic Range) it might be desirable to "
"use linear-space textures to achieve a more real-life lighting. "
"Otherwise, colors may saturate and contrast too much when exposure "
"changes. This option must be used together with the SRGB option in "
"`WorldEnvironment <class_worldenvironment>`__. The texture import options"
" also have the option to do this conversion, but if this one is turned "
"on, conversion will always be done to diffuse textures (usually what is "
"desired). For more information, read the :ref:`doc_high_dynamic_range` "
"tutorial."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:215
msgid "Set alpha in materials (-alpha)"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:217
msgid ""
"When working with most 3D DCCs, its pretty obvious when a texture is "
"transparent and has opacity and this rarely affects the workflow or final"
" rendering. However, when dealing with real-time rendering, materials "
"with alpha blending are usually less optimal to draw, so they must be "
"explicitly marked as such."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:223
msgid ""
"Originally Godot detected this based on whether if the source texture had"
" an alpha channel, but most image manipulation applications like "
"Photoshop or Gimp will export this channel anyway even if not used. Code "
"was added later to check manually if there really was any transparency in"
" the texture, but artists will anyway and very often lay uvmaps into "
"opaque parts of a texture and leave unused areas (where no UV exists) "
"transparent, making this detection worthless."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:231
msgid ""
"Finally, it was decided that it's best to import everything as opaque and"
" leave artists to fix materials that need transparency when it's obvious "
"that they are not looking right (see the :ref:`doc_materials` tutorial)."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:236
msgid ""
"As a helper, since every 3D DCC allows naming the materials and keeping "
"their name upon export, the (-alpha) modifier in their name will hint the"
" 3D scene importer in Godot that this material will use the alpha channel"
" for transparency."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:242
msgid "Set vert. color in materials (-vcol)"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:244
msgid ""
"Most 3D DCCs support vertex color painting. This is generally applied as "
"multiplication or screen blending. However, it is also often the case "
"that your exporter will export this information as all 1s, or export it "
"as something else and you will not realize it. Since most of the cases "
"this option is not desired, just add this to any material to confirm that"
" vertex colors are desired."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:252
msgid "Create collisions (-col, -colonly)"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:254
msgid ""
"These will only work for Mesh nodes, If the \"-col\" option is detected, "
"a child static collision node will be added, using the same geometry as "
"the mesh."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:258
msgid ""
"However, it is often the case that the visual geometry is too complex or "
"too un-smooth for collisions, which end up not working well. To solve "
"this, the \"-colonly\" modifier exists, which will remove the mesh upon "
"import and create a `StaticBody <class_staticbody>`__ collision instead. "
"This helps the visual mesh and actual collision to be separated."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:265
msgid "Create rooms (-room)"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:267
msgid ""
"This is used to create a room. As a general rule, any node that is a "
"child of this node will be considered inside the room (including "
"portals)."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:273
msgid ""
"There are two ways in which this modifier can be used. The first is using"
" a Dummy/Empty node in the 3D application with the \"-room\" tag. For "
"this to work, the \"interior\" of the room must be closed (geometry of "
"the children should contain walls, roof, floor, etc. and the only holes "
"to the outside should be covered with portals). The importer will then "
"create a simplified version of the geometry for the room."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:280
msgid ""
"The second way is to use the \"-room\" modifier on a mesh node. This will"
" use the mesh as the base for the BSP tree that contains the room bounds."
" Make sure that the mesh shape is **closed**, all normals **point "
"outside** and that the geometry is **not self-intersecting**, otherwise "
"the bounds may be computed wrong (BSP Trees are too picky and difficult "
"to work with, which is why they are barely used anymore..)."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:287
msgid "Anyway, the room will need portals, which are described next."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:290
msgid "Create portals (-portal)"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:292
msgid ""
"Portals are the view to look outside a room. They are always some flat "
"shape on the surface of a room. If the portal is left alone, it is used "
"to activate occlusion when looking inside<->outside the room."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:298
msgid "Basically, the conditions to make and import a portal from the 3D DCC are:"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:301
msgid "It should be a child of a room."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:302
msgid ""
"It should lay on the surface of the room (this doesn't need to be super "
"exact, just make it as close as you can by eye and Godot will adjust it)"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:305
msgid ""
"It must be a flat, convex shape, any flat and convex shape is okay, no "
"matter the axis or size."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:307
msgid ""
"Normals for the flat shape faces must **all point towards the OUTSIDE** "
"of the room."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:310
msgid "Here is how it usually looks:"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:314
msgid ""
"To connect to rooms, simply make two identical portals for both rooms and"
" place them overlapped. This does not need to be perfectly exact, again, "
"as Godot will fix it."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:319
msgid "[..]"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:321
msgid ""
"The rest of the tags in this section should be rather obvious, or will be"
" documented/changed in the future."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:325
msgid "Double-sidedness"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:327
msgid ""
"Collada and other formats support specifying the double-sidedness of the "
"geometry (in other words, when not double-sided, back-faces are not "
"drawn). Godot supports this option per Material, not per Geometry."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:331
msgid ""
"When exporting from 3D DCCs that work with per-object double-sidedness "
"(such as Blender of Maya), make sure that the double sided objects do not"
" share a material with the single sided ones or the importer will not be "
"able to discern."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:337
msgid "Animation options"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:339
msgid ""
"Some things to keep in mind when importing animations. 3D DCCs allow "
"animating with curves for every x,y,z component, doing IK constraints and"
" other stuff. When imported for real-time, animations are sampled (at "
"small intervals) so all this information is lost. Sampled animations are "
"fast to process, but can use considerable amounts of memory."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:346
msgid ""
"Because of this, the \"Optimize\" option exists but, in some cases, this "
"option might break an animation, so make it sure to disable it if you "
"notice any issues."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:350
msgid ""
"Some animations are meant to be cycled (like walk animations) if this is "
"the case, animation names that end in \"-cycle\" or \"-loop\" are "
"automatically set to loop."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:355
msgid "Import script"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:357
msgid ""
"Creating a script to parse the imported scene is actually really simple. "
"This is great for post processing, changing materials, doing funny stuff "
"with the geometry, etc."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:361
msgid "Create a script that basically looks like this:"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:372
msgid ""
"The post-import function takes the imported scene as parameter (the "
"parameter is actually the root node of the scene)."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:376
msgid "Update logic"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:378
msgid ""
"Other types of resources (like samples, meshes, fonts, images, etc.) are "
"re-imported entirely when changed and user changes are not kept."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:381
msgid ""
"Because of 3D Scenes can be really complex, they use a different update "
"strategy. The user might have done local changes to take advantage of the"
" engine features and it would be really frustrating if everything is lost"
" on re-import because the source asset changed."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:386
msgid ""
"This led to the implementation of a special update strategy. The idea "
"behind is that the user will not lose anything he or she did, and only "
"added data or data that can't be edited inside Godot will be updated."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:390
msgid "It works like this:"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:393
msgid "Strategy"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:395
msgid ""
"Upon changes on the source asset (ie: .dae), and on re-import, the editor"
" will remember the way the scene originally was, and will track your "
"local changes like renaming nodes, moving them or reparenting them. "
"Finally, the following will be updated:"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:400
msgid "Mesh Data will be replaced by the data from the updated scene."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:401
msgid "Materials will be kept if they were not modified by the user."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:402
msgid ""
"Portal and Room shapes will be replaced by the ones from the updated "
"scene."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:404
msgid ""
"If the user moved a node inside Godot, the transform will be kept. If the"
" user moved a node in the source asset, the transform will be replaced. "
"Finally, if the node was moved in both places, the transform will be "
"combined."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:409
msgid ""
"In general, if the user deletes anything from the imported scene (node, "
"mesh, material, etc.), updating the source asset will restore what was "
"deleted. This is a good way to revert local changes to anything. If you "
"really don't want a node anymore in the scene, either delete it from both"
" places or add the \"-noimp\" tag to it in the source asset."
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:416
msgid "Fresh re-import"
msgstr ""

#: ../../tutorials/3d/importing_3d_scenes.rst:418
msgid ""
"It can also happen that the source asset changed beyond recognition and a"
" full fresh re-import is desired. If so, simply re-open the 3D scene "
"import dialog from the Import -> Re-Import menu and perform re-import."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:4
msgid "Introduction to 3D"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:6
msgid ""
"Creating a 3D game can be challenging. That extra Z coordinate makes many"
" of the common techniques that helped to make 2D games simple no longer "
"work. To aid in this transition, it is worth mentioning that Godot uses "
"very similar APIs for 2D and 3D. Most nodes are the same and are present "
"in both 2D and 3D versions. In fact, it is worth checking the 3D "
"platformer tutorial, or the 3D kinematic character tutorials, which are "
"almost identical to their 2D counterparts."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:14
msgid ""
"In 3D, math is a little more complex than in 2D, so also checking the "
":ref:`doc_vector_math` in the wiki (which were specially created for game"
" developers, not mathematicians or engineers) will help pave the way into"
" efficiently developing 3D games."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:20
msgid "Spatial node"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:22
msgid ""
":ref:`Node2D <class_Node2D>` is the base node for 2D. :ref:`Control "
"<class_Control>` is the base node for everything GUI. Following this "
"reasoning, the 3D engine uses the :ref:`Spatial <class_Spatial>` node for"
" everything 3D."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:29
msgid ""
"Spatial nodes have a local transform, which is relative to the parent "
"node (as long as the parent node is also **or inherits** of type "
"Spatial). This transform can be accessed as a 4x3 :ref:`Transform "
"<class_Transform>`, or as 3 :ref:`Vector3 <class_Vector3>` members "
"representing location, Euler rotation (x,y and z angles) and scale."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:39
msgid "3D content"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:41
msgid ""
"Unlike 2D, where loading image content and drawing is straightforward, 3D"
" is a little more difficult. The content needs to be created with special"
" 3D tool (usually referred to as DCCs) and exported to an exchange file "
"format in order to be imported in Godot (3D formats are not as "
"standardized as images)."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:48
msgid "DCC-created models"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:50
msgid ""
"There are two pipelines to import 3D models in Godot. The first and most "
"common one is through the :ref:`doc_importing_3d_scenes` importer, which "
"allows to import entire scenes (just as they look in the DCC), including "
"animation, skeletal rigs, blend shapes, etc."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:55
msgid ""
"The second pipeline is through the :ref:`doc_importing_3d_meshes` "
"importer. This second method allows importing simple .OBJ files as mesh "
"resources, which can be then put inside a :ref:`MeshInstance "
"<class_MeshInstance>` node for display."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:61
msgid "Generated geometry"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:63
msgid ""
"It is possible to create custom geometry by using the :ref:`Mesh "
"<class_Mesh>` resource directly, simply create your arrays and use the "
":ref:`Mesh.add_surface() <class_Mesh_add_surface>` function. A helper "
"class is also available, :ref:`SurfaceTool <class_SurfaceTool>`, which "
"provides a more straightforward API and helpers for indexing, generating "
"normals, tangents, etc."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:70
msgid ""
"In any case, this method is meant for generating static geometry (models "
"that will not be updated often), as creating vertex arrays and submitting"
" them to the 3D API has a significant performance cost."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:75
msgid "Immediate geometry"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:77
msgid ""
"If, instead, there is a requirement to generate simple geometry that will"
" be updated often, Godot provides a special node, :ref:`ImmediateGeometry"
" <class_ImmediateGeometry>` which provides an OpenGL 1.x style immediate-"
"mode API to create points, lines, triangles, etc."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:84
msgid "2D in 3D"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:86
msgid ""
"While Godot packs a powerful 2D engine, many types of games use 2D in a "
"3D environment. By using a fixed camera (either orthogonal or "
"perspective) that does not rotate, nodes such as :ref:`Sprite3D "
"<class_Sprite3D>` and :ref:`AnimatedSprite3D <class_AnimatedSprite3D>` "
"can be used to create 2D games that take advantage of mixing with 3D "
"backgrounds, more realistic parallax, lighting/shadow effects, etc."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:94
msgid ""
"The disadvantage is, of course, that added complexity and reduced "
"performance in comparison to plain 2D, as well as the lack of reference "
"of working in pixels."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:99
msgid "Environment"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:101
msgid ""
"Besides editing a scene, it is often common to edit the environment. "
"Godot provides a :ref:`WorldEnvironment <class_WorldEnvironment>` node "
"that allows changing the background color, mode (as in, put a skybox), "
"and applying several types of built-in post-processing effects. "
"Environments can also be overridden in the Camera."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:108
msgid "3D viewport"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:110
msgid ""
"Editing 3D scenes is done in the 3D tab. This tab can be selected "
"manually, but it will be automatically enabled when a Spatial node is "
"selected."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:116
msgid ""
"Default 3D scene navigation controls are similar to Blender (aiming to "
"have some sort of consistency in the free software pipeline..), but "
"options are included to customize mouse buttons and behavior to be "
"similar to other tools in Editor Settings:"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:124
msgid "Coordinate system"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:126
msgid ""
"Godot uses the `metric <http://en.wikipedia.org/wiki/Metric_system>`__ "
"system for everything. 3D Physics and other areas are tuned for this, so "
"attempting to use a different scale is usually a bad idea (unless you "
"know what you are doing)."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:131
msgid ""
"When working with 3D assets, it's always best to work in the correct "
"scale (set your DCC to metric). Godot allows scaling post-import and, "
"while this works in most cases, in rare situations it may introduce "
"floating point precision issues (and thus, glitches or artifacts) in "
"delicate areas such as rendering or physics. So, make sure your artists "
"always work in the right scale!"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:138
msgid ""
"The Y coordinate is used for \"up\", though for most objects that need "
"alignment (like lights, cameras, capsule collider, vehicle, etc.), the Z "
"axis is used as a \"pointing towards\" direction. This convention roughly"
" means that:"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:143
msgid "**X** is sides"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:144
msgid "**Y** is up/down"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:145
msgid "**Z** is front/back"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:148
msgid "Space and manipulation gizmos"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:150
msgid ""
"Moving objects in the 3D view is done through the manipulator gizmos. "
"Each axis is represented by a color: Red, Green, Blue represent X,Y,Z "
"respectively. This convention applies to the grid and other gizmos too "
"(and also to the shader language, ordering of components for "
"Vector3,Color,etc.)."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:158
msgid "Some useful keybindings:"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:160
msgid ""
"To snap motion or rotation, press the \"s\" key while moving, scaling or "
"rotating."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:162
msgid "To center the view on the selected object, press the \"f\" key."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:165
msgid "View menu"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:167
msgid ""
"The view options are controlled by the \"[ view ]\" menu. Pay attention "
"to this little menu inside the window because it is often overlooked!"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:173
msgid "Default lighting"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:175
msgid "The 3D view has by some default options on lighting:"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:177
msgid ""
"There is a directional light that makes objects visible while editing "
"turned on by default. It is no longer visible when running the game."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:179
msgid ""
"There is subtle default environment light to avoid places not reached by "
"the light to remain visible. It is also no longer visible when running "
"the game (and when the default light is turned off)."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:183
msgid "These can be turned off by toggling the \"Default Light\" option:"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:187
msgid ""
"Customizing this (and other default view options) is also possible via "
"the settings menu:"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:192
msgid ""
"Which opens this window, allowing to customize ambient light color and "
"default light direction:"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:198
msgid "Cameras"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:200
msgid ""
"No matter how many objects are placed in 3D space, nothing will be "
"displayed unless a :ref:`Camera <class_Camera>` is also added to the "
"scene. Cameras can either work in orthogonal or perspective projections:"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:207
msgid ""
"Cameras are associated and only display to a parent or grand-parent "
"viewport. Since the root of the scene tree is a viewport, cameras will "
"display on it by default, but if sub-viewports (either as render target "
"or picture-in-picture) are desired, they need their own children cameras "
"to display."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:215
msgid ""
"When dealing with multiple cameras, the following rules are followed for "
"each viewport:"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:218
msgid ""
"If no cameras are present in the scene tree, the first one that enters it"
" will become the active camera. Further cameras entering the scene will "
"be ignored (unless they are set as *current*)."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:221
msgid ""
"If a camera has the \"*current*\" property set, it will be used "
"regardless of any other camera in the scene. If the property is set, it "
"will become active, replacing the previous camera."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:224
msgid ""
"If an active camera leaves the scene tree, the first camera in tree-order"
" will take it's place."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:228
msgid "Lights"
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:230
msgid ""
"There is no limitation on the number of lights nor of types of lights in "
"Godot. As many as desired can be added (as long as performance allows). "
"Shadow maps are, however, limited. The more they are used, the less the "
"quality overall."
msgstr ""

#: ../../tutorials/3d/introduction_to_3d.rst:235
msgid ""
"It is possible to use :ref:`doc_light_baking`, to avoid using large "
"amount of real-time lights and improve performance."
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:4
msgid "Inverse kinematics"
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:6
msgid "This tutorial is a follow-up of :ref:`doc_working_with_3d_skeletons`."
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:8
msgid ""
"Before continuing on, I'd recommend reading some theory, the simplest "
"article I find is this:"
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:11
msgid "http://freespace.virgin.net/hugo.elias/models/m_ik2.htm"
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:14
msgid "Initial problem"
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:16
msgid ""
"Talking in Godot terminology, the task we want to solve here is position "
"our 2 angles we talked about above so, that the tip of lowerarm bone is "
"as close to target point, which is set by target Vector3() as possible "
"using only rotations. This task is very calculation-intensive and never "
"resolved by analytical equation solve. So, it is an underconstrained "
"problem, which means there is unlimited number of solutions to the "
"equation."
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:26
msgid ""
"For easy calculation, for this chapter we consider target is also child "
"of Skeleton. If it is not the case for your setup you can always reparent"
" it in your script, as you will save on calculations if you do."
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:31
msgid ""
"In the picture you see angles alpha and beta. In this case we don't use "
"poles and constraints, so we need to add our own. On the picture the "
"angles are 2D angles living in plane which is defined by bone base, bone "
"tip and target."
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:36
msgid ""
"The rotation axis is easily calculated using cross-product of bone vector"
" and target vector. The rotation in this case will be always in positive "
"direction. If t is the Transform which we get from get_bone_global_pose()"
" function, the bone vector is"
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:45
msgid "So we have all information here to execute our algorithm."
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:47
msgid ""
"In game dev it is common to resolve this problem by iteratively closing "
"to the desired location, adding/subtracting small numbers to the angles "
"until the distance change achieved is less than some small error value. "
"Sounds easy enough, but there are Godot problems we need to resolve there"
" to achieve our goal."
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:53
msgid "**How to find coordinates of the tip of the bone?**"
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:54
msgid "**How to find vector from bone base to target?**"
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:56
msgid ""
"For our goal (tip of the bone moved within area of target), we need to "
"know where the tip of our IK bone is. As we don't use a leaf bone as IK "
"bone, we know the coordinate of the bone base is the tip of parent bone. "
"All these calculations are quite dependant on the skeleton's structure. "
"You can use pre-calculated constants as well. You can add an extra bone "
"for the tip of IK and calculate using that."
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:64
msgid "Implementation"
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:66
msgid "We will just use exported variable for bone length to be easy."
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:74
msgid ""
"Now, we need to apply our transformations from IK bone to the base of "
"chain. So we apply rotation to IK bone then move from our IK bone up to "
"its parent, then apply rotation again, then move to the parent of current"
" bone again, etc. So we need to limit our chain somewhat."
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:83
msgid "For ``_ready()`` function:"
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:92
msgid "Now we can write our chain-passing function:"
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:106
msgid "And for the ``_process()`` function:"
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:113
msgid ""
"Executing this script will just pass through bone chain printing bone "
"transforms."
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:140
msgid ""
"Now we need to actually work with target. The target should be placed "
"somewhere accessible. Since \"arm\" is imported scene, we better place "
"target node within our top level scene. But for us to work with target "
"easily its Transform should be on the same level as Skeleton."
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:145
msgid ""
"To cope with this problem we create \"target\" node under our scene root "
"node and at script run we will reparent it copying global transform, "
"which will achieve wanted effect."
msgstr ""

#: ../../tutorials/3d/inverse_kinematics.rst:149
msgid ""
"Create new Spatial node under root node and rename it to \"target\". Then"
" modify ``_ready()`` function to look like this:"
msgstr ""

#: ../../tutorials/3d/lighting.rst:4
msgid "Lighting"
msgstr ""

#: ../../tutorials/3d/lighting.rst:9
msgid ""
"Lights emit light that mix with the materials and produces a visible "
"result. Light can come from several types of sources in a scene:"
msgstr ""

#: ../../tutorials/3d/lighting.rst:12
msgid ""
"From the Material itself, in the form of the emission color (though it "
"does not affect nearby objects unless baked)."
msgstr ""

#: ../../tutorials/3d/lighting.rst:14
msgid "Light Nodes: Directional, Omni and Spot."
msgstr ""

#: ../../tutorials/3d/lighting.rst:15
msgid "Ambient Light in the :ref:`Environment <class_Environment>`."
msgstr ""

#: ../../tutorials/3d/lighting.rst:17
msgid "Baked Light (read :ref:`doc_light_baking`)."
msgstr ""

#: ../../tutorials/3d/lighting.rst:19
msgid ""
"The emission color is a material property, as seen in the previous "
"tutorials about materials (go read them if you didn't at this point!)."
msgstr ""

#: ../../tutorials/3d/lighting.rst:23
msgid "Light nodes"
msgstr ""

#: ../../tutorials/3d/lighting.rst:25
msgid ""
"As mentioned before, there are three types of light nodes: Directional, "
"Ambient and Spot. Each has different uses and will be described in detail"
" below, but first let's take a look at the common parameters for lights:"
msgstr ""

#: ../../tutorials/3d/lighting.rst:32
msgid "Each one has a specific function:"
msgstr ""

#: ../../tutorials/3d/lighting.rst:34
msgid "**Enabled**: Lights can be disabled at any time."
msgstr ""

#: ../../tutorials/3d/lighting.rst:35
msgid ""
"**Bake Mode**: When using the light baker, the role of this light can be "
"defined in this enumerator. The role will be followed even if the light "
"is disabled, which allows to configure a light and then disable it for "
"baking."
msgstr ""

#: ../../tutorials/3d/lighting.rst:39
msgid ""
"**Energy**: This value is a multiplier for the light, it's specially "
"useful for :ref:`doc_high_dynamic_range` and for Spot and Omni lights, "
"because it can create very bright spots near the emissor."
msgstr ""

#: ../../tutorials/3d/lighting.rst:42
msgid ""
"**Diffuse and Specular**: These light values get multiplied by the "
"material light and diffuse colors, so a white value does not mean that "
"light will be white, but that the original color will be kept."
msgstr ""

#: ../../tutorials/3d/lighting.rst:45
msgid ""
"**Operator**: It is possible to make some lights negative for a darkening"
" effect."
msgstr ""

#: ../../tutorials/3d/lighting.rst:47
msgid ""
"**Projector**: Lights can project a texture for the diffuse light "
"(currently only supported in Spot light)."
msgstr ""

#: ../../tutorials/3d/lighting.rst:51
msgid "Directional light"
msgstr ""

#: ../../tutorials/3d/lighting.rst:53
msgid ""
"This is the most common type of light and represents the sun. It is also "
"the cheapest light to compute and should be used whenever possible "
"(although it's not the cheapest shadow-map to compute, but more on that "
"later). Directional light nodes are represented by a big arrow, which "
"represent the direction of the light, however the position of the node "
"does not affect the lighting at all, and can be anywhere."
msgstr ""

#: ../../tutorials/3d/lighting.rst:62
msgid ""
"Basically what faces the light is lit, what doesn't is dark. Most lights "
"have specific parameters but directional lights are pretty simple in "
"nature so they don't."
msgstr ""

#: ../../tutorials/3d/lighting.rst:67
msgid "Omni light"
msgstr ""

#: ../../tutorials/3d/lighting.rst:69
msgid ""
"Omni light is a point that throws light all around it up to a given "
"radius (distance) that can be controlled by the user. The light "
"attenuates with the distance and reaches 0 at the edge. It represents "
"lamps or any other light source that comes from a point."
msgstr ""

#: ../../tutorials/3d/lighting.rst:76
msgid ""
"The attenuation curve for these kind of lights in nature is computed with"
" an inverse-quadratic function that never reaches zero and has almost "
"infinitely large values near the emissor."
msgstr ""

#: ../../tutorials/3d/lighting.rst:80
msgid ""
"This makes them considerably inconvenient to tweak for artists, so Godot "
"simulates them with an artist-controlled exponential curve instead."
msgstr ""

#: ../../tutorials/3d/lighting.rst:87
msgid "Spot light"
msgstr ""

#: ../../tutorials/3d/lighting.rst:89
msgid ""
"Spot lights are similar to Omni lights, except they only operate between "
"a given angle (or \"cutoff\"). They are useful to simulate flashlights, "
"car lights, etc. This kind of light is also attenuated towards the "
"opposite direction it points to."
msgstr ""

#: ../../tutorials/3d/lighting.rst:97
msgid "Ambient light"
msgstr ""

#: ../../tutorials/3d/lighting.rst:99
msgid ""
"Ambient light can be found in the properties of a WorldEnvironment "
"(remember only one of such can be instanced per scene). Ambient light "
"consists of a uniform light and energy. This light is applied the same to"
" every single pixel of the rendered scene, except to objects that used "
"baked light."
msgstr ""

#: ../../tutorials/3d/lighting.rst:106
msgid "Baked light"
msgstr ""

#: ../../tutorials/3d/lighting.rst:108
msgid ""
"Baked light stands for pre-computed ambient light. It can serve multiple "
"purposes, such as baking light emissors that are not going to be used in "
"real-time, and baking light bounces from real-time lights to add more "
"realism to a scene (see Baked Light]] tutorial for more information)."
msgstr ""

#: ../../tutorials/3d/materials.rst:4
msgid "Materials"
msgstr ""

#: ../../tutorials/3d/materials.rst:9
msgid ""
"Materials can be applied to most visible 3D objects, they basically are a"
" description to how light reacts to that object. There are many types of "
"materials, but the main ones are the :ref:`FixedMaterial "
"<class_FixedMaterial>` and :ref:`ShaderMaterial <class_ShaderMaterial>`. "
"Tutorials for each of them exist :ref:`doc_fixed_materials` and "
":ref:`doc_shader_materials`."
msgstr ""

#: ../../tutorials/3d/materials.rst:16
msgid "This tutorial is about the basic properties shared between them."
msgstr ""

#: ../../tutorials/3d/materials.rst:21
msgid "Flags"
msgstr ""

#: ../../tutorials/3d/materials.rst:23
msgid ""
"Materials, no matter which type they are, have a set of flags associated."
" Each has a different use and will be explained as follows."
msgstr ""

#: ../../tutorials/3d/materials.rst:27
msgid "Visible"
msgstr ""

#: ../../tutorials/3d/materials.rst:29
msgid ""
"Toggles whether the material is visible. If unchecked, the object will "
"not be shown."
msgstr ""

#: ../../tutorials/3d/materials.rst:33
msgid "Double sided & invert faces"
msgstr ""

#: ../../tutorials/3d/materials.rst:35
msgid ""
"Godot by default only shows geometry faces (triangles) when facing the "
"camera. To do this it needs them to be in view in clockwise order. This "
"saves a lot of GPU power by ensuring that not visible triangles are not "
"drawn."
msgstr ""

#: ../../tutorials/3d/materials.rst:40
msgid ""
"Some flat objects might need to be drawn all the times though, for this "
"the \"double sided\" flag will make sure that no matter the facing, the "
"triangle will always be drawn. It is also possible to invert this check "
"and draw counter-clockwise looking faces too, though it's not very useful"
" except for a few cases (like drawing outlines)."
msgstr ""

#: ../../tutorials/3d/materials.rst:47
msgid "Unshaded"
msgstr ""

#: ../../tutorials/3d/materials.rst:49
msgid ""
"Objects are always black unless light affects them, and their shading "
"changes according to the type and direction of lights. When this flag is "
"turned on, the diffuse color is displayed right the same as it appears in"
" the texture or parameter:"
msgstr ""

#: ../../tutorials/3d/materials.rst:57
msgid "On top"
msgstr ""

#: ../../tutorials/3d/materials.rst:59
msgid ""
"When this flag is turned on, the object will be drawn after everything "
"else has been drawn and without a depth test. This is generally only "
"useful for HUD effects or gizmos."
msgstr ""

#: ../../tutorials/3d/materials.rst:64
msgid "Ligthmap on UV2"
msgstr ""

#: ../../tutorials/3d/materials.rst:66
msgid ""
"When using lightmapping (see the :ref:`doc_light_baking` tutorial), this "
"option determines that the lightmap should be accessed on the UV2 array "
"instead of regular UV."
msgstr ""

#: ../../tutorials/3d/materials.rst:73
msgid "Some parameters also exist for controlling drawing and blending:"
msgstr ""

#: ../../tutorials/3d/materials.rst:85
msgid "Line width"
msgstr ""

#: ../../tutorials/3d/materials.rst:87
msgid "When drawing lines, the size of them can be adjusted here per material."
msgstr ""

#: ../../tutorials/3d/materials.rst:90
msgid "Depth draw mode"
msgstr ""

#: ../../tutorials/3d/materials.rst:92
msgid ""
"This is a tricky but very useful setting. By default, opaque objects are "
"drawn using the depth buffer and translucent objects are not (but are "
"sorted by depth). This behavior can be changed here. The options are:"
msgstr ""

#: ../../tutorials/3d/materials.rst:96
msgid ""
"**Always**: Draw objects with depth always, even those with alpha. This "
"often results in glitches like the one in the first image (which is why "
"it's not the default)."
msgstr ""

#: ../../tutorials/3d/materials.rst:99
msgid ""
"**Opaque Only**: Draw objects with depth only when they are opaque, and "
"do not set depth for alpha. This is the default because it's fast, but "
"it's not the most correct setting. Objects with transparency that self-"
"intersect will always look wrong, especially those that mix opaque and "
"transparent areas, like grass, tree leaves, etc. Objects with "
"transparency also can't cast shadows, this is evident in the second "
"image."
msgstr ""

#: ../../tutorials/3d/materials.rst:106
msgid ""
"**Alpha Pre-Pass**: The same as above, but a depth pass is performed for "
"the opaque areas of objects with transparency. This makes objects with "
"transparency look much more correct. In the third image it is evident how"
" the leaves cast shadows between them and into the floor. This setting is"
" turned off by default because, while on PC this is not very costly, "
"mobile devices suffer a lot when this setting is turned on, so use it "
"with care."
msgstr ""

#: ../../tutorials/3d/materials.rst:113
msgid ""
"**Never**: Never use the depth buffer for this material. This is mostly "
"useful in combination with the \"On Top\" flag explained above."
msgstr ""

#: ../../tutorials/3d/shader_materials.rst:4
msgid "Shader materials"
msgstr ""

#: ../../tutorials/3d/shader_materials.rst:9
msgid ""
"For the most common cases, :ref:`doc_fixed_materials` are enough to "
"create the desired textures or look and feel. Shader materials are a step"
" beyond that, adding a huge amount of flexibility. With them, it is "
"possible to:"
msgstr ""

#: ../../tutorials/3d/shader_materials.rst:13
msgid "Create procedural textures."
msgstr ""

#: ../../tutorials/3d/shader_materials.rst:14
msgid "Create complex texture blendings."
msgstr ""

#: ../../tutorials/3d/shader_materials.rst:15
msgid "Create animated materials, or materials that change with time."
msgstr ""

#: ../../tutorials/3d/shader_materials.rst:16
msgid "Create refractive effects or other advanced effects."
msgstr ""

#: ../../tutorials/3d/shader_materials.rst:17
msgid "Create special lighting shaders for more exotic materials."
msgstr ""

#: ../../tutorials/3d/shader_materials.rst:18
msgid "Animate vertices, like tree leaves or grass."
msgstr ""

#: ../../tutorials/3d/shader_materials.rst:21
msgid ""
"Traditionally, most engines will ask you to learn GLSL, HLSL or CG, which"
" are pretty complex for the skillset of most artists. Godot uses a "
"simplified version of a shader language that will detect errors as you "
"type, so you can see your edited shaders in real-time. Additionally, it "
"is possible to edit shaders using a visual, node-based graph editor."
msgstr ""

#: ../../tutorials/3d/shader_materials.rst:28
msgid "Creating a ShaderMaterial"
msgstr ""

#: ../../tutorials/3d/shader_materials.rst:30
msgid ""
"Create a new ShaderMaterial in some object of your choice. Go to the "
"\"Shader\" property, then create a new \"MaterialShader\" (use "
"\"MaterialShaderGraph\" for access to the visual graph editor):"
msgstr ""

#: ../../tutorials/3d/shader_materials.rst:36
msgid "Edit the newly created shader, and the shader editor will open:"
msgstr ""

#: ../../tutorials/3d/shader_materials.rst:40
msgid ""
"There are three code tabs open, the first is for the vertex shader, the "
"second for the fragment and the third for the lighting. The shader "
"language is documented in :ref:`doc_shading_language` so a small example "
"will be presented next."
msgstr ""

#: ../../tutorials/3d/shader_materials.rst:45
msgid "Create a very simple fragment shader that writes a color:"
msgstr ""

#: ../../tutorials/3d/shader_materials.rst:52
msgid ""
"Code changes take place in real-time. If the code is modified, it will be"
" instantly recompiled and the object will be updated. If a typo is made, "
"the editor will notify of the compilation failure:"
msgstr ""

#: ../../tutorials/3d/shader_materials.rst:58
msgid ""
"Finally, go back and edit the material, and the exported uniform will be "
"instantly visible:"
msgstr ""

#: ../../tutorials/3d/shader_materials.rst:63
msgid ""
"This allows to very quickly create custom, complex materials for every "
"type of object."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:4
msgid "Shadow mapping"
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:9
msgid ""
"Simply throwing a light is not enough to realistically illuminate a "
"scene. It should be, in theory, but given the way video hardware works, "
"parts of objects that should not be reached by light are lit anyway."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:14
msgid ""
"Most people (including artists), see shadows as something projected by "
"light, as if they were created by the light itself by darkening places "
"that are hidden from the light source."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:18
msgid ""
"This is actually not correct and it's important to understand that "
"shadows are places where light simply does not reach. As a rule (and "
"without counting indirect light) if a light is turned off, the places "
"where shadow appear should remain the same. In other words, shadows "
"should not be seen as something \"added\" to the scene, but as an area "
"that \"remains dark\"."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:25
msgid ""
"All light types in Godot can use shadow mapping, and all support several "
"different techniques that trade quality by performance. Shadow mapping "
"uses a texture storing the \"depth view\" of the light and checks against"
" it in real-time for each pixel it renders."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:30
msgid ""
"The bigger the resolution of the shadow map texture, the more detail the "
"shadow has, but more video memory and bandwidth consumed (which means "
"frame-rate goes down)."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:35
msgid "Shadows by light type"
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:38
msgid "Directional light shadows"
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:40
msgid ""
"Directional lights can affect a really big area. The bigger the scene, "
"the bigger the affected area. Given the shadow map resolution stays the "
"same, the same amount of shadow pixels cover a bigger area, resulting in "
"blocky shadows. Multiple techniques exist to deal with resolution "
"problems, but the most common one is PSSM (Parallel Split Shadow Maps):"
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:48
msgid ""
"These techniques divide the view in 2 or 4 sections, and a shadow is "
"rendered for each. This way, close objects can use larger shadow while "
"further away objects will use one in less detail, but in proportion this "
"seems to make the shadow map size increase while it's actually kept the "
"same. Of course, this technique is not free, the more splits the more the"
" performance goes down. On mobile, it is generally inconvenient to use "
"more than 2 splits."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:56
msgid ""
"An alternative technique is PSM (Perspective Shadow Mapping). This "
"technique is much cheaper than PSSM (as cheap as orthogonal), but it only"
" really works for a few camera angles respect to the light. In other "
"words, PSM is only useful for games where the camera direction and light "
"direction are both fixed, and the light is not parallel to the camera "
"(which is when PSM completely breaks)."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:64
msgid "Omni light shadows"
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:66
msgid ""
"Omnidirectional lights are also troublesome. How to represent 360 degrees"
" of light with a single texture? There are two alternatives, the first "
"one is to use DPSM (Dual Paraboloid Shadow Mapping). This technique is "
"fast, but it requires DISCARD to be used (which makes it not very usable "
"on mobile). DPSM can also look rather bad if the geometry is not "
"tessellated enough, so more vertices might be necessary if it doesn't "
"look tight. The second option is to simply not use a shadow map, and use "
"a shadow cubemap. This is faster, but requires six passes to render all "
"directions and is not supported on the current (GLES2) renderer."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:78
msgid "As few considerations when using DPSM shadow maps:"
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:80
msgid "Keep Slope-Scale on 0."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:81
msgid "Use a small value for Z-Offset, if this look wrong, make it smaller."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:82
msgid "ESM filtering can improve the look."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:83
msgid ""
"The seams between the two halves of the shadow are generally noticeable, "
"so rotate the light to make them show less."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:87
msgid "Spot light shadows"
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:89
msgid ""
"Spot light shadows are generally the simpler, just needing a single "
"texture and no special techniques."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:95
msgid "Shadows parameters"
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:97
msgid ""
"The fact that shadows are actually a texture can generate several "
"problems. The most common is Z fighting (lines at the edge of the objects"
" that cast the shadows. There are two ways to fix this, the first is to "
"tweak the offset parameters, and the second is to use a filtered shadow "
"algorithm, which generally looks better and has not as many glitches, but"
" consumes more GPU time."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:105
msgid "Adjusting z-offset"
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:107
msgid ""
"So, you have decided to go with non-filtered shadows because they are "
"faster, you want a little more detail or maybe you just like the sexy "
"saw-like shadow outlines because they remind you of your favorite "
"previous-gen games. Truth is, this can be kind of be a pain, but most of "
"the time it can be adjusted to have nice results. There is no magic "
"number and whatever result you come up will be different from scene to "
"scene, it just takes a while of tweaking. Let's go step by step."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:115
msgid ""
"First step is to turn on the shadows, let's assume that both Z-Offset and"
" Z-Slope-Scale are at 0. You will be greeted by this:"
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:120
msgid ""
"Holy crap, the shadow is all over the place and extremely glitchy! This "
"happens because the shadow is fighting with the same geometry that is "
"casting it. This is called \"self-shadowing\". To avoid this meaningless "
"fight, you realize you need to make peace between the shadow and the "
"geometry, so you push back the shadow a little by increasing the shadow "
"Z-Offset. This improves things a lot:"
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:129
msgid ""
"But it's not quite perfect, self shadowing did not disappear completely. "
"So close to perfection but still not there.. so in a turn of greed you "
"increase the Z-Offset even more!"
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:135
msgid ""
"And it gets rid of those self-shadowings! Hooray! Except something is "
"wrong.. oh, right. Being pushed back too much, the shadows start "
"disconnecting from their casters, which looks pretty awful. Ok, you go "
"back to the previous Z-offset."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:140
msgid ""
"This is when Z-Slope-Scale comes to save the day. This setting makes "
"shadow caster objects thinner, so the borders don't self-shadow:"
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:145
msgid ""
"Aha! Finally something that looks acceptable. It's perfectly acceptable "
"and you can perfectly ship a game that looks like this (imagine you are "
"looking at Final Fantasy quality art btw, not this horrible attempt at 3D"
" modelling). There may be very tiny bits left of self shadowing that no "
"one cares about, so your inextinguishable greed kicks in again and you "
"raise the Z-Slope Scale again:"
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:154
msgid ""
"Well, that was too much, shadows casted are way too thin and don't look "
"good anymore. Well, though luck, the previous setting was good anyway, "
"let's accept that perfection does not exist and move on to something "
"else."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:160
msgid "Important!"
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:162
msgid ""
"If you are using shadow maps with directional lights, make sure that the "
"*view distance* of the *camera* is set to an *optimal range*. This means,"
" if the distance between your camera and the visible end of the scene is "
"100, then set the view distance to that value. If a greater than "
"necessary value is used, the shadow maps will lose detail as they will "
"try to cover a bigger area."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:169
msgid "So, always make sure to use the optimal range!"
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:172
msgid "Shadow filtering"
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:174
msgid ""
"Raw shadows are blocky. Increasing their resolution just makes smaller "
"blocks, but they are still blocks."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:177
msgid ""
"Godot offers a few ways to filter them (shadow in the example is low-"
"resolution on purpose!):"
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:182
msgid ""
"PCF5 and PCF13 are simple texture-space filtering. Will make the texture "
"a little more acceptable but still needs considerable resolution for it "
"to look good."
msgstr ""

#: ../../tutorials/3d/shadow_mapping.rst:186
msgid ""
"ESM is a more complex filter and has a few more tweaking parameters. ESM "
"uses shadow blurring (amount of blur passes and multiplier can be "
"adjusted)."
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:4
msgid "Using gridmaps"
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:9
msgid ""
":ref:`Gridmaps <class_GridMap>` are a simple and fast way to create 3D "
"game levels. Think of it as a 3D version of the "
":ref:`TileMap<doc_using_tilemaps>` node. Similarly, you start with a "
"predefined library of 3D meshes that can be put on a grid, just like if "
"you were building a level with an unlimited amount of Lego blocks."
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:15
msgid ""
"Collisions can also be added to the meshes, just like you would do with "
"the tiles of a tilemap."
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:19
msgid "Creating a MeshLibrary"
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:21
msgid ""
"To begin, you need a :ref:`class_MeshLibrary`, which is a collection of "
"meshes that can be used in the gridmap. Here are some meshes you can use "
"to set it up."
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:27
msgid ""
"Open a new scene and create a root node (this is important, as without "
"the root node, it will not be able to generate the MeshLibrary!). Then, "
"create a :ref:`class_MeshInstance` node:"
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:33
msgid ""
"If you don't need to apply physics to the building blocks, that's all you"
" need to do. In most cases though, you will need your block to generate "
"collisions, so let's see how to add them."
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:38
msgid "Collisions"
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:40
msgid ""
"To assign a :ref:`class_CollisionShape` and :ref:`class_PhysicsBody` to "
"the meshes, the simplest way is to do it while creating the MeshLibrary. "
"Alternatively, you can also edit an existing MeshLibrary from within the "
"GridMap inspector, but only CollisionShapes can be defined there and not "
"PhysicsBody."
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:46
msgid ""
"To give the meshes a CollisionShape, you simply add children nodes to the"
" MeshInstance node. You would typically add the desired PhysicsBody and "
"CollisionShape in this order:"
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:52
msgid "You can adjust the order according to your needs."
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:55
msgid "Exporting the MeshLibrary"
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:57
msgid ""
"To export, go to ``Scene > Convert To.. > MeshLibrary..``, and save it as"
" a resource."
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:62
msgid "You are now ready to use the GridMap node."
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:65
msgid "Using the MeshLibrary in a GridMap"
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:67
msgid ""
"Create a new scene using any node as root, then add a Gridmap node. Then,"
" load the MeshLibrary that you just exported."
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:72
msgid ""
"Now, you can build your own level as you see best fit. Use left click to "
"add tiles and right click to remove them. You can adjust the floor level "
"when you need to put meshes at specific heights."
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:78
msgid ""
"As mentioned above, you can also define new CollisionShapes at this stage"
" by doing the following steps:"
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:83
msgid "There you are!"
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:86
msgid "Reminder"
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:88
msgid "Be cautious before scaling meshes if you are not using uniform meshes."
msgstr ""

#: ../../tutorials/3d/using_gridmaps.rst:90
msgid "There are many ways to make use of gridmaps, be creative!"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:4
msgid "Working with 3D skeletons"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:6
msgid ""
"Godot 3D skeleton support is currently quite rudimentary. The "
":ref:`class_Skeleton` node and class were designed mainly to support "
"importing skeletal animations as a set of transformation matrices."
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:11
msgid "Skeleton node"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:13
msgid ""
"Skeleton node can be directly added anywhere you want on scene. Usually "
"mesh is a child of Skeleton, as it easier to manipulate this way, as "
"Transforms within skeleton are relative to where Skeleton is. But you can"
" specify Skeleton node in every MeshInstance."
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:18
msgid ""
"Being obvious, Skeleton is intended to deform meshes, and consists of "
"structures called \"bones\". Each \"bone\" is represented as Transform, "
"which is applied to a group of vertices within a mesh. You can directly "
"control a group of vertices from Godot. For that please reference "
":ref:`class_MeshDataTool` class, method :ref:`set_vertex_bones "
"<class_MeshDataTool_set_vertex_bones>`. This class is very powerful."
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:25
msgid ""
"The \"bones\" are organized in hierarchy, every bone, except for root "
"bone(s) have parent. Every bone have associated name you can use to refer"
" to it (e.g. \"root\" or \"hand.L\", etc.). Also bones are all numbered, "
"these numbers are bone IDs. Bone parents are referred by their numbered "
"IDs."
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:31
msgid "For the rest of the article we consider the following scene:"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:39
msgid ""
"This scene is imported from Blender. It contains arm mesh with 2 bones - "
"upperarm and lowerarm, with lowerarm parented to upperarm."
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:43
msgid "Skeleton class"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:45
msgid ""
"You can view Godot internal help for descriptions of every function. "
"Basically all operations on bones are done using their numeric ID. You "
"can convert from name to numeric ID and vise versa."
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:49
msgid "**To find number of bones in skeleton we use get_bone_count() function**"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:64
msgid "**to find ID for the bone, use find_bone() function**"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:76
msgid ""
"Now, we want to do something interesting with ID except for printing it. "
"Also, we might need additional information - to find bone parents to "
"complete chain, etc. This all is done with get/set_bone\\_\\* functions."
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:80
msgid "**To find bone parent we use get_bone_parent(id) function**"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:94
msgid ""
"Bone transforms is the thing why we're here at all. There are 3 kind of "
"transforms - local, global, custom."
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:97
msgid "**To find bone local Transform we use get_bone_pose(id) function**"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:113
msgid ""
"So we see 3x4 matrix there, with first column of 1s. What can we do about"
" that? It is a Transform, so we can do everything we can do with "
"Transform, basically translate, rotate and scale. Also we can multiply "
"transforms to have complex transforms. Remember, \"bones\" in Godot are "
"just Transforms over a group of vertices. Also we can copy Transforms of "
"other objects there. So lets rotate our \"upperarm\" bone:"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:141
msgid ""
"Now we can rotate individual bones. The same happens for scale and "
"translate - try these on your own and see results."
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:144
msgid ""
"What we used now was local pose. By default all bones are not modified. "
"But this Transform tells us nothing about relationship between bones. "
"This information is needed for quite a number of tasks. How can we get "
"it? Here comes global transform:"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:149
msgid "**To find bone global Transform we use get_bone_global_pose(id) function**"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:152
msgid "We will find global Transform for lowerarm bone:"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:168
msgid ""
"As you see, this transform is not zeroed. While being called global, it "
"is actually relative to Skeleton origin. For root bone, origin is always "
"at 0 if not modified. Lets print origin for our lowerarm bone:"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:186
msgid ""
"You will see a number. What does this number mean? It is a rotation point"
" of Transform. So it is base part of the bone. In Blender you can go to "
"Pose mode and try there to rotate bones - they will rotate around their "
"origin. But what about tip? We can't know things like bone length, which "
"we need for many things, without knowing tip location. For all bones in "
"chain except for last one we can calculate tip location - it is simply a "
"child bone origin. Yes, there are situations when this is not true, for "
"non-connected bones. But that is OK for us for now, as it is not "
"important regarding Transforms. But the leaf bone tip is nowhere to be "
"found. Leaf bone is a bone without children. So you don't have any "
"information about its tip. But this is not a showstopper. You can "
"overcome this by either adding extra bone to the chain or just "
"calculating leaf bone length in Blender and store the value in your "
"script."
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:202
msgid "Using 3D \"bones\" for mesh control"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:204
msgid ""
"Now as you know basics we can apply these to make full FK-control of our "
"arm (FK is forward-kinematics)"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:207
msgid "To fully control our arm we need the following parameters:"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:209
msgid "Upperarm angle x, y, z"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:210
msgid "Lowerarm angle x, y, z"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:212
msgid "All of these parameters can be set, incremented and decremented."
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:214
msgid "Create the following node tree:"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:223
msgid ""
"Set up Camera so that arm is properly visible. Rotate DirectionLight so "
"that arm is properly lit while in scene play mode."
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:226
msgid "Now we need to create new script under main:"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:228
msgid "First we setup parameters:"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:235
msgid "Now we need to setup a way to change them. Let us use keys for that."
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:237
msgid "Please create 7 actions under project settings:"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:239
msgid "**selext_x** - bind to X key"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:240
msgid "**selext_y** - bind to Y key"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:241
msgid "**selext_z** - bind to Z key"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:242
msgid "**select_upperarm** - bind to key 1"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:243
msgid "**select_lowerarm** - bind to key 2"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:244
msgid "**increment** - bind to key numpad +"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:245
msgid "**decrement** - bind to key numpad -"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:247
msgid ""
"So now we want to adjust the above parameters. Therefore we create code "
"which does that:"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:273
msgid "The full code for arm control is this:"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:323
msgid ""
"Pressing keys 1/2 select upperarm/lowerarm, select axis by pressing x, y,"
" z, rotate using numpad \"+\"/\"-\""
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:326
msgid ""
"This way you fully control your arm in FK mode using 2 bones. You can add"
" additional bones and/or improve \"feel\" of the interface by using "
"coefficients for the change. I recommend you play with this example a lot"
" before going to next part."
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:331
msgid "You can clone the demo code for this chapter using"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:338
msgid "Or you can browse it using web-interface:"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:340
msgid "https://github.com/slapin/godot-skel3d"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:343
msgid "Using 3D \"bones\" to implement Inverse Kinematics"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:345
msgid "See :ref:`doc_inverse_kinematics`."
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:348
msgid "Using 3D \"bones\" to implement ragdoll-like physics"
msgstr ""

#: ../../tutorials/3d/working_with_3d_skeletons.rst:350
msgid "TODO."
msgstr ""

#: ../../tutorials/_math.rst:2
msgid "数学"
msgstr ""

#: ../../tutorials/_misc_tutorials.rst:2
msgid "Miscellaneous"
msgstr ""

#: ../../tutorials/_networking.rst:2
msgid "Networking"
msgstr ""

#: ../../tutorials/_plugins.rst:2
msgid "Editor plugins"
msgstr ""

#: ../../tutorials/_plugins.rst:4
msgid "Coming soon™."
msgstr ""

#: ../../tutorials/_shaders.rst:2
msgid "Shaders"
msgstr ""

#: ../../tutorials/asset_pipeline/_asset_pipeline.rst:2
msgid "Asset pipeline"
msgstr ""

#: ../../tutorials/asset_pipeline/_export.rst:2
msgid "Export"
msgstr ""

#: ../../tutorials/asset_pipeline/_general.rst:2
msgid "General"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_android.rst:4
msgid "Exporting for Android"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_android.rst:6
msgid ""
"Exporting for android has much less requirements than compiling Godot for"
" it. As follows are the steps to setup the SDK and the engine."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_android.rst:10
msgid "Download the Android SDK"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_android.rst:12
msgid ""
"Download and install the Android SDK from "
"http://developer.android.com/sdk/index.html"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_android.rst:16
msgid "Install OpenJDK or Oracle JDK"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_android.rst:18
msgid ""
"Download and install OpenJDK or Oracle JDK. Version 6 and 8 are known to "
"work, some users have reported issues with the jarsigner (used to sign "
"the APKs) in JDK 7."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_android.rst:23
msgid "Create a debug.keystore"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_android.rst:25
msgid ""
"Android needs a debug keystore file to install to devices and distribute "
"non-release APKs. If you have used the SDK before and have built "
"projects, ant or eclipse probably generated one for you (In Linux and "
"OSX, you can find it in the ~/.android folder)."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_android.rst:30
msgid ""
"If you can't find it or need to generate one, the keytool command from "
"the JDK can be used for this purpose:"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_android.rst:38
msgid "Make sure you have adb"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_android.rst:40
msgid ""
"ADB is the command line tool used to communicate with Android devices. "
"It's installed with the SDK, but you may need to install one (any) of the"
" Android API levels for it to be installed in the SDK directory."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_android.rst:45
msgid "Setting it up in Godot"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_android.rst:47
msgid ""
"Enter the Editor Settings screen. This screens contains the editor "
"settings for the user account in the computer (It's independent from the "
"project)."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_android.rst:53
msgid "Scroll down to the section where the Android settings are located:"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_android.rst:57
msgid "In that screen, the path to 3 files needs to be set:"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_android.rst:59
msgid "The *adb* executable (adb.exe on Windows)"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_android.rst:60
msgid "The *jarsigner* executable (from JDK 6 or 8)"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_android.rst:61
msgid "The debug *keystore*"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_android.rst:63
msgid "Once that is configured, everything is ready to export to Android!"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:4
msgid "Exporting for iOS"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:6
msgid ""
"Exporting for iOS is done manually at the moment. These are the steps to "
"load your game in an XCode project, where you can deploy to a device, "
"publish, etc."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:11
msgid "Requirements"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:13
msgid "Download XCode for iOS"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:14
msgid "Download the export templates: https://godotengine.org/download"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:15
msgid ""
"Since there is no automatic deployer yet, unzip export_templates.tpz "
"manually and extract GodotiOSXCode.zip from it."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:18
msgid ""
"The zip contains an XCode project, godot_ios.xcodeproj, an empty data.pck"
" file and the engine executable. Open the project, and modify the game "
"name, icon, organization, provisioning signing certificate identities "
"(??), etc."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:24
msgid "Add your project data"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:26
msgid ""
"Using the Godot editor, :ref:`doc_exporting_for_pc`, to obtain the "
"data.pck file. Replace the empty data.pck in the XCode project with the "
"new one, and run/archive."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:30
msgid ""
"If you want to test your scenes on the iOS device as you edit them, you "
"can add your game directory to the project (instead of data.pck), and add"
" a property \"godot_path\" to Info.plist, with the name of your directory"
" as its value."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:37
msgid ""
"Alternatively you can add all the files from your game directly, with "
"\"engine.cfg\" at the root."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:41
msgid "Loading files from a host"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:43
msgid ""
"Sometimes your game becomes too big and deploying to the device takes too"
" long every time you run. In that case you can deploy only the engine "
"executable, and serve the game files from your computer."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:48
msgid "Setting up the file host"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:50
msgid ""
"On your PC, open the editor, and click the righ-most icon on the top-"
"center group of icons, and select \"Enable File Server\". The icon turns "
"red. Your PC will open a port and accept connections to serve files from "
"your project's directory (so enable your local firewall accordingly)."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:59
msgid "Setting up the game"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:61
msgid ""
"On XCode, click on your app name (top left, next to the \"Stop\" button),"
" and select \"Edit Scheme\". Go to the \"Arguments\" tab, and add 2 "
"arguments, \"-rfs\" and the IP of your PC."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:67
msgid ""
"When you run, your device will connect to the host and open the files "
"remotely. Note that the directory with the game data (\"platformer\") is "
"no longer added to the project, only the engine executable."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:72
msgid "Services for iOS"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_ios.rst:74
msgid ""
"Special iOS services can be used in Godot. Check out the "
":ref:`doc_services_for_ios` page."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_pc.rst:4
msgid "Exporting for PC"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_pc.rst:6
msgid ""
"The simplest way to distribute a game for PC is to copy the executables "
"(godot.exe on windows, godot on the rest), zip the folder and send it to "
"someone else. However, this is often not desired."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_pc.rst:10
msgid ""
"Godot offers a more elegant approach for PC distribution when using the "
"export system. When exporting for PC (Linux, Windows, Mac), the exporter "
"takes all the project files and creates a \"data.pck\" file. This file is"
" bundled with a specially optimized binary that is smaller, faster and "
"lacks tools and debugger."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_for_pc.rst:16
msgid ""
"Optionally, the files can be bundled inside the executable, though this "
"does not always works properly."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_images.rst:4
msgid "Exporting images"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_images.rst:6
msgid ""
"It is often desired to do an operation to all or a group of images upon "
"export. Godot provides some tools for this. Examples of such operations "
"are:"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_images.rst:10
msgid ""
"Converting all images from a lossless format to a lossy one (ie: png -> "
"web) for greater compression."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_images.rst:12
msgid ""
"Shrinking all images to half the size, to create a low resolution build "
"for smaller screens."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_images.rst:14
msgid ""
"Create an atlas for a group of images and crop them, for higher "
"performance and less memory usage."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_images.rst:18
msgid "Image export options"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_images.rst:20
msgid "In the \"Export Dialog\", go to the Images tab:"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_images.rst:24
msgid ""
"In this dialog the image extensions for conversion can be selected, and "
"operations can be performed that apply to all images (except those in "
"groups -next section for that-):"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_images.rst:28
msgid ""
"**Convert Image Format**: Probably the most useful operation is to "
"convert to Lossy (WebP) to save disk space. For lossy, a Quality bar can "
"set the quality/vs size ratio."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_images.rst:31
msgid ""
"**Shrink**: This allows to shrink all images by a given amount. It's "
"useful to export a game to half or less resolution for special devices."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_images.rst:34
msgid "**Compress Formats**: Allows to select which image exensions to convert."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_images.rst:37
msgid ""
"On export, Godot will perform the desired operation. The first export "
"might be really slow, but subsequent exports will be fast, as the "
"converted images will be cached."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_images.rst:42
msgid "Image group export options"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_images.rst:44
msgid ""
"This section is similar to the previous one, except it can operate on a "
"selected group of images. When a image is in a group, the settings from "
"the global export options are overridden by the ones from the group. An "
"image can only be in one group at the same time. So if the image is in "
"another group different to the current one being edited, it will not be "
"selectable."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_images.rst:54
msgid "Atlas"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_images.rst:56
msgid ""
"As a plus, an atlas can be created from a group. When this mode is "
"active, a button to preview the resulting atlas becomes available. Make "
"sure that atlases don't become too big, as some hardware will not support"
" textures bigger than 2048x2048 pixels. If this happens, just create "
"another atlas."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_images.rst:62
msgid ""
"The atlas can be useful to speed up drawing of some scenes, as state "
"changes are minimized when drawing from it (through unlike other engines,"
" Godot is designed so state changes do not affect it as much). Textures "
"added to an atlas get cropped (empty spaces around the image are "
"removed), so this is another reason to use them (save space). If unsure, "
"though, just leave that option disabled."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:4
msgid "Exporting projects"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:7
msgid "Why exporting?"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:9
msgid ""
"Originally, Godot did not have any means to export projects. The "
"developers would compile the proper binaries and build the packages for "
"each platform manually."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:13
msgid ""
"When more developers (and even non-programmers) started using it, and "
"when our company started taking more projects at the same time, it became"
" evident that this was a bottleneck."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:18
msgid "On PC"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:20
msgid ""
"Distributing a game project on PC with Godot is rather easy. Just drop "
"the godot.exe (or godot) binary together in the same place as the "
"engine.cfg file, zip it and you are done. This can be taken advantage to "
"make custom installers."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:25
msgid ""
"It sounds simple, but there are probably a few reasons why the developer "
"may not want to do this. The first one is that it may not be desirable to"
" distribute loads of files. Some developers may not like curious users "
"peeking at how the game was made, others may just find it inelegant, etc."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:31
msgid ""
"Another reason is that, for distribution, the developer might use a "
"specially compiled binary, which is smaller in size, more optimized and "
"does not include tools inside (like the editor, debugger, etc)."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:35
msgid ""
"Finally, Godot has a simple but efficient system for creating DLCs as "
"extra package files."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:39
msgid "On mobile"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:41
msgid ""
"The same scenario in mobile is a little worse. To distribute a project in"
" those devices, a binary for each of those platforms is built, then added"
" to a native project together with the game data."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:45
msgid ""
"This can be troublesome because it means that the developer must be "
"familiarized with the SDK of each platform before even being able to "
"export. In other words, while learning each SDK is always encouraged, it "
"can be frustrating to be forced to do it at an undesired time."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:50
msgid ""
"There is also another problem with this approach, which is the fact that "
"different devices prefer some data in different formats to run. The main "
"example of this is texture compression. All PC hardware uses S3TC (BC) "
"compression and that has been standardized for more than a decade, but "
"mobile devices use different formats for texture compression, such as "
"PVRCT (iOS) or ETC (Android)"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:58
msgid "Export dialog"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:60
msgid ""
"After many attempts at different export workflows, the current one has "
"worked the best. At the time of this writing, not all platforms are "
"supported yet, but that will change soon."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:64
msgid "To open the export dialog, just click the \"Export\" Button:"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:68
msgid "The dialog will open, showing all the supported export platforms:"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:72
msgid ""
"The default options are often enough to export, so tweaking them is not "
"necessary until it's needed. However, many platforms require additional "
"tools (SDKs) to be installed to be able to export. Additionally, Godot "
"needs exports templates installed to create packages. The export dialog "
"will complain when something is missing and will not allow the user to "
"export for that platform until he or she resolves it:"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:81
msgid ""
"At that time, the user is expected to come back to the wiki and follow "
"instructions on how to properly set up that platform."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:85
msgid "Export templates"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:87
msgid ""
"Apart from setting up the platform, the export templates must be "
"installed to be able to export projects. They can be downloaded as a .tpz"
" (a renamed .zip) file from the wiki."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:91
msgid ""
"Once downloaded, they can be installed using the \"Install Export "
"Templates\" option in the editor:"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:97
msgid "Export mode"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:99
msgid ""
"When exporting, Godot makes a list of all the files to export and then "
"creates the package. There are 3 different modes for exporting:"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:102
msgid "Export every single file in the project"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:103
msgid "Export only resources (+custom filter), this is default."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:104
msgid "Export only selected resources (+custom filter)"
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:108
msgid ""
"**Export every single file** - This mode exports every single file in the"
" project. This is good to test if something is being forgotten, but "
"developers often have a lot of unrelated stuff around in the dev dir, "
"which makes it a bad idea."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:113
msgid ""
"**Export only resources** - Only resources are exported. For most "
"projects, this is enough. However many developers like to use custom "
"datafiles in their games. To compensate for this, filters can be added "
"for extra extensions (like, *.txt,*.csv, etc)."
msgstr ""

#: ../../tutorials/asset_pipeline/exporting_projects.rst:118
msgid ""
"**Export only selected resources** - Only select resources from a list "
"are exported. This is probably overkill for most projects, but in some "
"cases it is justified (usually huge projects). This mode offers total "
"control of what is exported. Individual resources can be selected and "
"dependency detection is performed to ensure that everything needed is "
"added. As a plus, this mode allows to \"Bundle\" scenes and dependencies "
"into a single file, which is *really* useful for games distributed on "
"optical media."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:4
msgid "Import process"
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:7
msgid "What is it for?"
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:9
msgid ""
"When Godot was created, it was probably after several failed and not so "
"failed engine attempts (well, each attempt failed a little less.. and so "
"on). One of the most difficult areas of creating game engines is managing"
" the import process. That means, getting the assets that artists make "
"into the game, in a way that functions optimally."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:15
msgid ""
"Artists use certain tools and formats, and programmers would rather have "
"their data into a different format. This is because artists put their "
"focus on creating assets with the best quality possible, while "
"programmers have to make sure they actually run at decent speed (or run "
"at all), use a certain amount of memory, and don't take ages loading from"
" disk."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:22
msgid ""
"One would think that just writing a converter/importer would be enough, "
"but this is not all there is to it. The same way programmers iterate "
"several times over their code, artists keep making changes to their "
"assets. This generates some bottleneck, because *someone* has to keep re-"
"importing that artwork right? And importing assets is often something "
"that has to be agreed by both parties, as the programmer needs to decide "
"how the artwork is imported and the artists needs to see how it looks."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:30
msgid ""
"The goal to establishing an import process is that both can agree on how "
"the rules under which the assets are going to be imported the first time,"
" and the system will apply those rules automatically each time the asset "
"is re-imported."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:35
msgid ""
"Godot does not do the re-import process automatically, though. It gives "
"the team the option to do it at any time ( a red icon on the top right of"
" the screen, allows the ability to do it at any desired time)."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:40
msgid "Does it always work?"
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:42
msgid ""
"The aim of the import system is that it works well enough for most common"
" cases and projects. What is there has been tested and seems to cover "
"most needs."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:46
msgid ""
"However, as mentioned before, this is one of the most difficult areas of "
"writing a game engine. It may happen often (specially on large projects, "
"ports, or projects with unusual requirement) that what is provided is not"
" enough. It's easy to say that the engine is open source and that the "
"programmer should make their own if they don't like what is there, but "
"that would be making a huge disservice to the users and not the right "
"attitude. Because of that, we made sure to provide as many tools and "
"helpers as possible to support a custom import process, for example:"
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:55
msgid ""
"Access to the internals of almost all data structures is provided to the "
"scripting and C++ API, as well as saving and loading in all supported "
"file formats."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:58
msgid ""
"Some importers (like the 3D asset importer) support scripts to modify the"
" data being imported."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:60
msgid ""
"Support for creating custom import plugins is also provided, even for "
"replacing the existing ones."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:62
msgid ""
"If all else fails, Godot supports adding custom resource loaders, to load"
" data in alternative formats, without intermediate conversion."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:65
msgid ""
"Both the import system and the custom tools provided will improve over "
"time as more use cases are revealed to us."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:69
msgid "Importing assets"
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:72
msgid "Source asset location"
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:74
msgid ""
"To begin, it is a good idea to define where the original assets created "
"by the artists (before they are imported) will be located. Normally, "
"Godot does not mind much about the location, but if the project has "
"several developers, it is a good idea to understand the simple rule for "
"it to work for everyone."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:80
msgid ""
"First of all, it would be really good for this location to **not** be "
"inside the project path (where engine.cfg is located, or any sub-folder)."
" Godot expects regular resources in there, and may consider many of the "
"files used as source art as regular resources. This would lead to it "
"bundling all of them when the project is exported, something which is "
"undesired."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:87
msgid ""
"Now that it is clear that this location must be outside the project "
"folder, the rule that Godot uses to reference external assets can be "
"explained. When an asset is imported, the engine stores a relative path "
"from the project path to the asset (In windows, this works as long as "
"they are on the same drive, otherwise an absolute path is stored). This "
"ensures that the same asset can be re-imported in another computer."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:94
msgid ""
"The usual approach to this, when using a VCS such as Subversion, Perforce"
" or GIT, is to create the project in a subfolder, so both it and the "
"source assets can be committed to a same repository. For example:"
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:98
msgid "Repository layout:"
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:109
msgid ""
"In the above example, artists, musician, translators, etc. can work in "
"the source_assets/ folder, then import the assets to the game/ folder. "
"When the repository is updated, anyone can re-import the assets if they "
"changed."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:115
msgid "Import dialogs"
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:117
msgid ""
"Godot provides for importing several types of assets, all of them can be "
"accessed from the import dialog:"
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:122
msgid ""
"Each of the dialog shares a similar function, a source file (or several "
"of them) must be provided, as well as a target destination inside the "
"project folders. Once imported, Godot saves this information as metadata "
"in the imported asset itself."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:129
msgid ""
"More information about each specific type of asset can be found in "
"specific sections, such as `Importing Textures <import_textures>`__."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:133
msgid "Tracking changes and re-importing"
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:135
msgid ""
"Godot tracks changes in the source assets constantly. If at least one "
"asset has been found to be modified (md5 is different than when it was "
"imported), a small red indicator will appear in the top right corner of "
"the screen."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:142
msgid ""
"From that moment onward, the user can choose to re-import at any given "
"time by clicking on the red-icon. When this action is done, a dialog will"
" pop-up showing which resources can be re-imported (all selected by "
"default)."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:147
msgid ""
"Accepting that dialog will immediately re-import the resources and will "
"update any of them currently in use in the editor (like a texture, model "
"or audio file)."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:154
msgid "Manually re-importing"
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:156
msgid ""
"The re-import process is automatic, but it may be desired at some point "
"to change the settings of an already imported file, so it can be re-"
"imported differently. For this, the Import Settings window is provided."
msgstr ""

#: ../../tutorials/asset_pipeline/import_process.rst:163
msgid ""
"This screen allows the user to re-open the corresponding import-window to"
" re-import that asset again, with the ability to change any of the "
"settings."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:4
#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:91
msgid "Importing audio samples"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:7
msgid "Why importing?"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:9
msgid ""
"Importing Audio Samples into the game engine is a process that should be "
"easier than it really is. Most readers are probably thinking \"Why not "
"just copying the .wav files to a folder inside the project and be over "
"with it?\"."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:14
msgid ""
"It's not usually that simple. Most game engines use uncompressed audio "
"(in memory at least) for sound effects. The reason for this is because "
"it's really cheap to play back and resample. Compressed streamed audio "
"(such as .ogg files) takes a large amount of processor to decode so no "
"more than one or two are streamed simultaneously. However, with sound "
"effects, one expects a dozen of them to be playing at the same time in "
"several situations."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:22
msgid ""
"Because of this, sound effects are loaded uncompressed into memory, and "
"here is where the problems begin."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:25
msgid ""
"As is usual with graphics, the situation where programmers don't really "
"know about audio and audio engineers don't know about programming is also"
" common in the industry. This leads to a scenario where a project ends up"
" wasting resources unnecessarily."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:30
msgid ""
"To be more precise, sfx artists tend to work with audio formats that give"
" them a lot of room for tweaking the audio with a low noise floor minimum"
" aliasing, such as 96khz, 24 bits. In many cases, they work in stereo "
"too. Added to that, many times they add effects with an infinite or "
"really long fadeout, such as reverb, which take a long time to fade out. "
"Finally, many DAWs also add silence at the beginning when normalizing to "
"wav."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:38
msgid ""
"This results in extremely large files to integrate more often than "
"desired, with sound effects taking dozens of megabytes."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:42
msgid "How much does quality matter?"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:44
msgid ""
"First of all, it is important to know that Godot has an internal reverb "
"generator. Sound effects can go to four different setups (small, medium "
"and large room as well as hall), with different send amounts. This saves "
"sfx artists the need to add reverb to the sound effects, reducing their "
"size greatly and ensuring correct trimming. Say no to SFX with baked "
"reverb!"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:53
msgid ""
"Another common problem is that, while it's useful for working inside a "
"DAW, high dynamic range (24 bits) and high sampling rate (96khz) is "
"completely unnecessary for use in a game, as there is no `audible "
"difference <http://www.youtube.com/watch?v=cIQ9IXSUzuM>`__. If positional"
" sound is going to be used (for 2D and 3D), the panning and stereo reverb"
" will be provided by the engine, so there is little need for stereo "
"sound. How does this affect the resource usage? Look at the following "
"comparison:"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:63
msgid "Format"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:63
msgid "1 Second of Audio"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:63
msgid "Frame Size"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:65
msgid "24 bits, 96 khz, Stereo"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:65
msgid "576kb"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:65
msgid "12"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:67
msgid "16 bits, 44 khz, Mono"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:67
msgid "88kb"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:67
msgid "2"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:69
msgid "16 bits, IMA-ADPCM"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:69
msgid "22kb"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:69
msgid "1/2"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:72
msgid ""
"As seen, for being no audible difference, the 16 bits, 44khz takes *6 "
"times less memory* than the 24 bits, 96khz, Stereo version. The IMA-ADPCM"
" version takes *24 times less memory* than what was exported from the "
"DAW."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:78
msgid "Trimming"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:80
msgid ""
"One last issue that happens often is that the waveform files received "
"have silences at the beginning and at the end. These are inserted by DAWs"
" when saving to a waveform, increase their size unnecessarily and add "
"latency to the moment they are played back. Trimming them solves this, "
"but it takes effort for the sfx artist, as they have to do it in a "
"separate application. In the worst case, they may not even know the "
"silences are being added."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:93
msgid ""
"Godot has a simple screen for importing audio samples to the engine. SFX "
"artists only have to save the .wav files to a folder outside the project,"
" and the import dialog will fix the files for inclusion, as well as doing"
" it automatically every time they are modified and re-imported."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:100
msgid ""
"In this screen, the quality of the audio can be limited to what is "
"needed, and trimming is done automatically. As a plus, several samples "
"can be loaded and batch-converted, just like textures."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:105
msgid "Looping"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:107
msgid ""
"Godot supports looping in the samples (Tools such as Sound Forge or "
"Audition can add loop points to .wav files). This is useful for sound "
"effects such as engines, machine guns, etc. Ping-pong looping is also "
"supported."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_audio_samples.rst:112
msgid ""
"As an alternative, the import screen has a \"loop\" option that enables "
"looping for the entire sample when importing."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:4
msgid "Importing fonts"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:7
msgid "What is a font?"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:9
msgid ""
"Fonts in modern operating systems are created as scalable vector "
"graphics. They are stored as a collection of curves (usually one for each"
" character), which are independent of the screen resolution, and stored "
"in standardized file formats, such as TTF (TrueType) or OTF (OpenType)."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:15
msgid ""
"Rendering such fonts to bitmaps is a complex process, which employs "
"different methods to convert curves to pixels depending on context and "
"target size. Due to this, this rendering process must be done by using "
"the CPU. Game engines use the GPU to render, and 3D APIs don't really "
"support the means to do this efficiently, so fonts have to be converted "
"to a format that is friendly to the GPU when imported to a project."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:23
msgid "Converting fonts"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:25
msgid ""
"This conversion process consists of rendering a vector font to a given "
"point size and storing all the resulting characters in a bitmap texture. "
"The bitmap texture is then used by the GPU to draw a small quad for each "
"character and form readable strings."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:32
msgid ""
"The drawback of this process is that fonts must be pre-imported in the "
"specific sizes that they will use in the project. However, given that "
"that bitmap fonts compress really well, this is not as bad as it sounds."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:37
msgid "Importing a font"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:39
msgid ""
"Fonts are imported via the Font import dialog. The dialog will ask for a "
"font, a size, some options and a target resource fie to save."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:44
msgid ""
"The dialog is fully dynamic, which means that any change will be "
"reflected in the font preview window. The user ccan tweak almost every "
"parameter and get instant feedback on how the font will look."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:48
msgid ""
"Since the resulting font is a bitmap, a few more options were added to "
"make the imported font look even nicer. These options were added to "
"please graphic designers, who love putting gradients, outlines and "
"shadows in fonts, as well as changing all the inter-spaces available :). "
"The options which will be explained in the next section."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:55
msgid "Extra spacing"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:57
msgid "It is possible to add more space for:"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:59
msgid "**Characters**, the space between them can be varied."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:60
msgid "**\"space\" character**, so the distance between words is bigger."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:61
msgid ""
"**Top and Bottom margins**, this changes the spacing between lines as "
"well as the space between the top and bottom lines and the borders."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:67
msgid "Shadows & outline"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:69
msgid ""
"Fonts can be added a shadow. For this, the font is drawn again below on a"
" different color and the blurred with a gaussian kernel of different "
"sizes. The resulting shadow can be adjusted with an exponential function "
"to make it softer or more like an outline. A second shadow is also "
"provided to create some added effects, like a bump or outline+shadow."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:78
msgid "Gradients"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:80
msgid ""
"Gradients are also another of the visual effects that graphic designers "
"often use. To show how much we love them, we added those too. Gradients "
"can be provided as a simple curve between two colors, or a special png "
"file with a hand drawn gradient."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:88
msgid "Internationalization"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:90
msgid ""
"Colors, shadows and gradients are beautiful, but it's time we get to "
"serious business. Developing games for Asian markets is a common practice"
" in today's globalized world and app stores."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:94
msgid ""
"Here's when things get tricky with using bitmap fonts. Asian alphabets "
"(Chinese, Japanese and Korean) contains dozens of thousands of "
"characters. Generating bitmap fonts with every single of them is pretty "
"expensive, as the resulting textures are huge. If the font size is small "
"enough, it can be done without much trouble, but when the fonts become "
"bigger, we run out of video ram pretty quickly!"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:101
msgid ""
"To solve this, Godot allows the user to specify a text file (in UTF-8 "
"format) where it expects to find all the characters that will be used in "
"the project. This seems difficult to provide at first, and more to keep "
"up to date, but it becomes rather easy when one realizes that the .csv "
"with the translations can be used as such source file (see the "
":ref:`doc_importing_translations` section). As Godot re-imports assets "
"when their dependencies change, both the translation and font files will "
"be updated and re-imported automatically if the translation csv changes."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_fonts.rst:110
msgid ""
"Another cool trick for using a text file as limit of which characters can"
" be imported is when using really large fonts. For example, the user "
"might want to use a super large font, but only to show numbers. For this,"
" he or she writes a numbers.txt file that contains \"1234567890\", and "
"Godot will only limit itself to import data, thus saving a lot of video "
"memory."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:4
msgid "Importing textures"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:7
msgid "Do NOT import them in most cases"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:9
msgid ""
"In most cases you **don't** want images imported when dealing with 2D and"
" GUI. Just copy them to the filesystem. Read the tutorial on "
":ref:`doc_managing_image_files` before continuing! For 3D, textures are "
"always imported by the 3D scene importer, so importing those is only "
"useful when importing a texture used for 3D that doesn't come with the 3D"
" scene (for example, in a shader). The flags and options are the same as "
"here, so reading the rest of the document might help too."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:19
msgid "OK, you *might* want to import them"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:21
msgid ""
"So, if you have read the previous tutorial on the texture exporter, the "
"texture importer gives you more finer grained control on how textures are"
" imported. If you want to change flags such as repeat, filter, mip-maps, "
"fix edges, etc. ***PER texture***, importing them is the best way to "
"accomplish this (since you can't save such flags in a standard image "
"file)."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:29
msgid "Lack of MipMaps"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:31
msgid ""
"Images in 3D hardware are scaled with a (bi)linear filter, but this "
"method has limitations. When images are shrunk too much, two problems "
"arise:"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:35
msgid ""
"**Aliasing**: Pixels are skipped too much, and the image shows "
"discontinuities. This decrases quality."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:37
msgid ""
"**Cache Misses**: Pixels being read are too far apart, so texture cache "
"reads a lot more data than it should. This decreases performance."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:41
msgid "(Todo, find image sample of why it looks bad)"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:43
msgid ""
"To solve this, mipmaps are created. Mipmaps are versions of the image "
"shrunk by half in both axis, recursively, until the image is 1 pixel of "
"size. When the 3D hardware needs to shrink the image, it finds the "
"largest mipmap it can scale from, and scales from there. This improves "
"performance and image quality."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:51
msgid ""
"Godot automatically creates mipmaps upon load for standard image files. "
"This process is time consuming (although not much) and makes load times a"
" little worse. Pre-importing the textures allows the automatic generation"
" of mipmaps."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:57
msgid "Unwanted MipMaps"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:59
msgid ""
"Remember the previous point about mipmaps? Yes, they are cool, but mobile"
" GPUs only support them if the textures are in power of 2 dimensions (ie "
"256x256 or 512x128). In these platforms, Godot will stretch and enlarge "
"the texture to the closest power of 2 size and then generate the mipmaps."
" This process takes more of a performance hit and it might degrade the "
"quality a little more."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:66
msgid ""
"Because of this, there are some scenarios when it may be desirable to not"
" use them, and just use a linear filter. One of them is when working with"
" graphical user interfaces (GUIs). Usually they are made of large images "
"and don't stretch much. Even if the screen resolution is in a larger or "
"smaller value than original art, the amount of stretch is not as much and"
" the art can retain the quality. Pre-importing the textures also allows "
"the disabling of mipmap generation."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:75
msgid "Blending artifacts"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:77
msgid ""
"The `blending equation "
"<http://en.wikipedia.org/wiki/Alpha_compositing>`__ used by applications "
"like Photoshop is too complex for realtime. There are better "
"approximations such as `pre-multiplied alpha "
"<http://blogs.msdn.com/b/shawnhar/archive/2009/11/06/premultiplied-"
"alpha.aspx?Redirected=true>`__, but they impose more stress in the asset "
"pipeline. In the end, we are left with textures that have artifacts in "
"the edges, because apps such as Photoshop store white pixels in "
"completely transparent areas. Such white pixels end up showing thanks to "
"the texture filter."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:87
#: ../../tutorials/asset_pipeline/managing_image_files.rst:76
msgid ""
"Godot has an option to fix the edges of the image (by painting invisible "
"pixels the same color as the visible neighbours):"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:92
msgid ""
"However, this must be done every time the image changes. Pre-Importing "
"the textures makes sure that every time the original file changes, this "
"artifact is fixed upon automatic re-import."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:97
msgid "Texture flags"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:99
msgid ""
"Textures have flags. The user can choose for them to repeat or clamp to "
"edges (when UVs exceed the 0,0,1,1 boundary). The magnifying filter can "
"also be turned off (for a Minecraft-like effect). Such values can not be "
"edited in standard file formats (png, jpg, etc), but can be edited and "
"saved in Godot .tex files. Then again, the user may not want to change "
"the values every time the texture changes. Pre-Importing the textures "
"also takes care of that."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:110
msgid ""
"Asides from the typical texture compression, which saves space on disk "
"(.png, jpg, etc), there are also texture compression formats that save "
"space in memory (more specifically video memory. This allows to have much"
" better looking textures in games without running out of memory, and "
"decrease memory bandwidth when reading them so they are a big plus."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:116
msgid ""
"Video texture compression formats are several and non standard. Apple "
"uses PVRTC. PC GPUs, consoles and nVidia Android devices use S3TC (BC), "
"other chipsets use other formats. OpenGL ES 3.0 standardized on ETC "
"format, but we are still a few years away from that working everywhere."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:121
msgid ""
"Still, when using this option, Godot converts and compresses to the "
"relevant format depending on the target platform (as long as the user "
"pre-imported the texture and specified video ram compression!)."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:125
msgid ""
"This kind of compression is often not desirable for many types 2D games "
"and UIs because it has visible visual artifacts. This is specially "
"noticeable on games that use the trendy vectory social game artwork. "
"However, again, the fact that it saves space and improves performance may"
" make up for it."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:131
msgid "The 3D scene importer always imports textures with this option turned on."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:135
msgid "Atlases"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:137
msgid ""
"Remember how mobile GPUs have this limitation of textures having to be in"
" power of 2 sizes to be able to generate mimpmaps for optimum stretching?"
" What if we have a lot of images in different random sizes? All will have"
" to be scaled and mipmapped when loaded (using more CPU and memory) or "
"when imported (using more memory). This is probably still ok, but there "
"is a tool that can help improve this situation."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:144
msgid ""
"Atlases are big textures that fit a lot of small textures inside "
"efficiently. Godot supports creating atlases in the importer, and the "
"imported files are just small resources that reference a region of the "
"bigger texture."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:149
msgid ""
"Atlases can be a nice solution to save some space on GUI or 2D artwork by"
" packing everything together. The current importer is not as useful for "
"3D though (3D Atlasses are created differently, and not all 3D models can"
" use them)."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:154
msgid ""
"As a small plus, atlases can decrease the amount of \"state changes\" "
"when drawing. If a lot of objects that are drawn using several different "
"textures are converted to atlas, then the texture rebinds per object will"
" go from dozens or hundreds to one. This will give the performance a "
"small boost."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:161
msgid "Artists use PSD"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:163
msgid ""
"Still wondering whether to use the texture importer or not? Remember that"
" in the end, artists will often use Photoshop anyway, so it may be wiser "
"to just let the import subsystem to take care of importing and converting"
" the PSD files instead of asking the artist to save a png and copy it to "
"the project every time."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:170
msgid "Texture importer"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:172
msgid ""
"Finally! It's time to take a look at the texture importer. There are 3 "
"options in the import menu. They are pretty much (almost) the same dialog"
" with a different set of defaults."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:178
msgid ""
"When selected, the texture import dialog will appear. This is the default"
" one for 2D textures:"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:183
msgid "Each import option has a function, explained as follows:"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:186
msgid "Source texture(s)"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:188
msgid ""
"One or more source images can be selected from the same folder (this "
"importer can do batch-conversion). This can be from inside or outside the"
" project."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:193
msgid "Target path"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:195
msgid ""
"A destination folder must be provided. It must be inside the project, as "
"textures will be converted and saved to it. Extensions will be changed to"
" .tex (Godot resource file for textures), but names will be kept."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:200
msgid "Texture format"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:202
msgid "This combo allows to change the texture format (compression in this case):"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:207
msgid ""
"Each of the four options described in this table together with their "
"advantages and disadvantages ( |good| = Best, |bad| =Worst ):"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:211
msgid "Uncompressed"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:211
msgid "Compress Lossless (PNG)"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:211
msgid "Compress Lossy (WebP)"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:211
msgid "Compress VRAM"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:213
msgid "Description"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:213
msgid "Stored as raw pixels"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:213
msgid "Stored as PNG"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:213
msgid "Stored as WebP"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:213
msgid "Stored as S3TC/BC,PVRTC/ETC, depending on platform"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:215
msgid "Size on Disk"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:215
#: ../../tutorials/asset_pipeline/importing_textures.rst:217
msgid "|bad| Large"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:215
msgid "|regular| Small"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:215
msgid "|good| Very Small"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:217
msgid "Memory Usage"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:217
msgid "|good| Small"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:219
msgid "Performance"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:219
#: ../../tutorials/asset_pipeline/importing_textures.rst:223
msgid "|regular| Normal"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:219
#: ../../tutorials/asset_pipeline/importing_textures.rst:223
msgid "|good| Fast"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:221
msgid "Quality Loss"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:221
msgid "|good| None"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:221
msgid "|regular| Slight"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:221
msgid "|bad| Moderate"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:223
msgid "Load Time"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:223
msgid "|bad| Slow"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:227
msgid "Texture options"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:229
msgid "Provided are a small amount of options for fine grained import control:"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:231
msgid ""
"**Streaming Format** - This does nothing as of yet, but a texture format "
"for streaming different mipmap levels is planned. Big engines have "
"support for this."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:234
msgid ""
"**Fix Border Alpha** - This will fix texture borders to avoid the white "
"auras created by white invisible pixels (see the rant above)."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:236
msgid ""
"**Alpha Bit Hint** - Godot auto-detects if the texture needs alpha bit "
"support for transparency (instead of full range), which is useful for "
"compressed formats such as BC. This forces alpha to be 0 or 1."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:239
msgid ""
"**Compress Extra** - Some VRAM compressions have alternate formats that "
"compress more at the expense of quality (PVRTC2 for example). If this is "
"ticked, texture will be smaller but look worse."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:242
msgid ""
"**No MipMaps** - Force imported texture to NOT use mipmaps. This may be "
"desirable in some cases for 2D (as explained in the rant above), though "
"it's NEVER desirable for 3D."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:245
msgid ""
"**Repeat** - Texture will repeat when UV coordinates go beyond 1 and "
"below 0. This is often desirable in 3D, but may generate artifacts in 2D."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_textures.rst:248
msgid ""
"**Filter** - Enables linear filtering when a texture texel is larger than"
" a screen pixel. This is usually turned on, unless it's required for "
"artistic purposes (minecraft look, for example)."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:4
msgid "Importing translations"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:7
msgid "Games and internationalization"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:9
msgid ""
"The world is full of different markets and cultures and, to maximize "
"profits™, nowadays games are released in several languages. To solve "
"this, internationalized text must be supported in any modern game engine."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:14
msgid ""
"In regular desktop or mobile applications, internationalized text is "
"usually located in resource files (or .po files for GNU stuff). Games, "
"however, can use several orders of magnitude more text than applications,"
" so they must support efficient methods for dealing with loads of multi-"
"language text."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:20
msgid ""
"There are two approaches to generate multi language games and "
"applications. Both are based on a key:value system. The first is to use "
"one of the languages as key (usually english), the second is to use a "
"specific identifier. The first approach is probably easier for "
"development if a game is released first in english, later in other "
"languages, but a complete nightmare if working with many languages at the"
" same time."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:28
msgid ""
"In general, games use the second approach and a unique ID is used for "
"each string. This allows to revise the text while it's being translated "
"to others. the unique ID can be a number, a string, or a string with a "
"number (it's just a unique string anyway)."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:33
msgid ""
"Translators also, most of the time prefer to work with spreadsheets "
"(either as a Microsoft Excel file or a shared Google Spreadsheet)."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:37
msgid "Translation format"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:39
msgid ""
"To complete the picture and allow efficient support for translations, "
"Godot has a special importer that can read .csv files. Both Microsoft "
"Excel and Google Spreadsheet can export to this format, so the only "
"requirement is that the files have a special format. The csv files must "
"be saved in utf-8 encoding and the format is as follows:"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:46
msgid "<lang1>"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:46
msgid "<lang2>"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:46
msgid "<langN>"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:48
msgid "KEY1"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:48
#: ../../tutorials/asset_pipeline/importing_translations.rst:50
#: ../../tutorials/asset_pipeline/importing_translations.rst:52
msgid "string"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:50
msgid "KEY2"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:52
msgid "KEYN"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:55
msgid ""
"The \"lang\" tags must represent a language, it must be one of the "
":ref:`valid locales <doc_locales>` supported by the engine. The \"KEY\" "
"tags must be unique and represent a string universally (they are usually "
"in uppercase, to differentiate from other strings). Here's an example:"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:61
msgid "id"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:61
msgid "en"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:61
msgid "es"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:61
msgid "ja"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:63
msgid "GREET"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:63
msgid "Hello, friend!"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:63
msgid "Hola, Amigo!"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:63
msgid "こんにちは"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:65
msgid "ASK"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:65
msgid "How are you?"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:65
msgid "Cómo esta?"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:65
msgid "元気ですか"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:67
msgid "BYE"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:67
msgid "Good Bye"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:67
msgid "Adiós"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:67
msgid "さようなら"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:71
msgid "Import dialog"
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:73
msgid ""
"The import dialog takes a .csv file in the previously described format "
"and generates several compressed translation resource files inside the "
"project."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:77
msgid ""
"Selecting a .csv file autodetects the languages from the first row. and "
"determines which column represents which language. It is possible to "
"change that manually, by selecting the language for each column."
msgstr ""

#: ../../tutorials/asset_pipeline/importing_translations.rst:83
msgid ""
"The import dialog also can add the translation to the list of "
"translations to load when the game runs, specified in engine.cfg (or the "
"project properties). Godot allows to load and remove translations at "
"runtime, too."
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:4
msgid "Managing image files"
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:6
msgid ""
"If you have read the previous tutorials on :ref:`doc_resources` and "
":ref:`doc_filesystem`, at this point you know that regular image files "
"(.png, .jpg, etc.) are treated as regular resources in Godot."
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:10
msgid ""
"Unlike texture resources (.tex files), image files contain no extra "
"information on tiling (texture repeat), mipmaps or filtering. Editing "
"this information and saving the texture back will not have any effect, "
"since such formats can't contain that information."
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:16
msgid "Image loader"
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:18
msgid ""
"Loading of images is done by the image loader. The behavior of the loader"
" for all image files can be changed in the Project Settings dialog (Scene"
" -> Project Settings). There is a section with values that are used for "
"all image resources:"
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:26
msgid "Image loader options"
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:29
msgid "Filter"
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:31
msgid ""
"Filter is used when the image is stretched more than its original size, "
"so a texel in the image is bigger than a pixel on the screen. Turning off"
" the filter produces a retro-like look:"
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:38
msgid "Repeat"
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:40
msgid ""
"Repeat is mainly used for 3D textures, so it's off by default (textures "
"are imported with the scenes and usually are not in the project as image "
"files). When using UV coordinates (something not as common in 2D), and "
"the UV value goes beyond the 0,0,1,1 rect, the texture repeats instead of"
" clamping to the edge."
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:47
msgid "Mipmaps"
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:49
msgid ""
"When the mipmaps option is enabled, Godot will generate mipmaps. Mipmaps "
"are versions of the image shrunk by half in both axis, recursively, until"
" the image is 1 pixel of size. When the 3D hardware needs to shrink the "
"image, it finds the largest mipmap it can scale from, and scales from "
"there. This improves performance and image quality."
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:58
msgid ""
"When mipmaps are disabled, images start distorting badly when shrunk "
"excessively:"
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:64
msgid "Alpha blending"
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:66
msgid ""
"The `blending equation "
"<http://en.wikipedia.org/wiki/Alpha_compositing>`__ used by applications "
"like Photoshop is too complex for real-time. There are better "
"approximations such as `pre-multiplied alpha "
"<http://blogs.msdn.com/b/shawnhar/archive/2009/11/06/premultiplied-"
"alpha.aspx?Redirected=true>`__, but they impose more stress in the asset "
"pipeline. In the end, we are left with textures that have artifacts in "
"the edges, because apps such as Photoshop store white pixels in "
"completely transparent areas. Such white pixels end up showing thanks to "
"the texture filter (when active)."
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:81
msgid ""
"To do this, open the image from the resources tab, or edit it from the "
"property editor from another node or resource, then go to the object "
"options and select \"Fix Alpha Edges\", then save it."
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:87
msgid ""
"Since fixing this in so many images can be a little annoying, both "
"Texture Import and Image Export can also perform this operation."
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:91
msgid "Texture import"
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:93
msgid ""
"Sometimes, it might be desired to change the above settings per image. "
"Unfortunately, the image loader settings are global. Texture flags also "
"can't be saved in a regular .png or .jpg file."
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:97
msgid ""
"For such cases, the image can be imported as a texture (.tex), where the "
"individual flags can be changed. Godot also keeps track of the original "
"file and will re-import if it changes."
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:101
msgid ""
"Importing also allows conversion to other formats (WebP, or RAM "
"compression) which might be of use in some cases. More information on the"
" :ref:`doc_importing_textures` page."
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:106
msgid "Image export"
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:108
msgid ""
"It is also possible to convert images to other formats (WebP or RAM "
"compression) on export, as well as instructing the exporter to create an "
"Atlas for a set of images. It is also possible to ask the exporter to "
"scale all images (or selected groups)."
msgstr ""

#: ../../tutorials/asset_pipeline/managing_image_files.rst:113
msgid "More information on the :ref:`doc_exporting_images` page."
msgstr ""

#: ../../tutorials/asset_pipeline/one-click_deploy.rst:4
msgid "One-click deploy"
msgstr ""

#: ../../tutorials/asset_pipeline/one-click_deploy.rst:7
msgid "Sounds good, what is it?"
msgstr ""

#: ../../tutorials/asset_pipeline/one-click_deploy.rst:9
msgid ""
"This feature will pop up automatically once a platform is properly "
"configured and a supported device is connected to the computer. Since "
"things can go wrong at many levels (platform may not be configured "
"correctly, SDK may incorrectly installed, device may be improperly "
"configured, kitty ate the USB cable, etc.), it's good to let the user "
"know that it exists."
msgstr ""

#: ../../tutorials/asset_pipeline/one-click_deploy.rst:16
msgid ""
"Some platforms (at the time of this writing, only Android and Blackberry "
"10) can detect when a USB device is connected to the computer, and offer "
"the user to automatically export, install and run the project (in debug "
"mode) on the device. This feature is called, in industry buzz-words, "
"\"One Click Deploy\" (though, it's technically two clicks...)."
msgstr ""

#: ../../tutorials/asset_pipeline/one-click_deploy.rst:23
msgid "Steps for one-click deploy"
msgstr ""

#: ../../tutorials/asset_pipeline/one-click_deploy.rst:25
msgid "Configure target platform."
msgstr ""

#: ../../tutorials/asset_pipeline/one-click_deploy.rst:26
msgid ""
"Configure device (make sure it's in developer mode, likes the computer, "
"usb is recognized, usb cable is plugged, etc)."
msgstr ""

#: ../../tutorials/asset_pipeline/one-click_deploy.rst:28
msgid "Connect the device.."
msgstr ""

#: ../../tutorials/asset_pipeline/one-click_deploy.rst:29
msgid "And voila!"
msgstr ""

#: ../../tutorials/asset_pipeline/one-click_deploy.rst:33
msgid "Click once.. and deploy!"
msgstr ""

#: ../../tutorials/engine/_engine.rst:2
msgid "引擎相关"
msgstr ""

#: ../../tutorials/engine/_filesystem.rst:2
msgid "文件系统"
msgstr ""

#: ../../tutorials/engine/_game_flow.rst:2
msgid "Game flow"
msgstr ""

#: ../../tutorials/engine/_i18n.rst:2
msgid "国际化"
msgstr ""

#: ../../tutorials/engine/_scene_input_viewports.rst:2
msgid "场景，输入和视窗"
msgstr ""

#: ../../tutorials/engine/background_loading.rst:4
msgid "Background loading"
msgstr ""

#: ../../tutorials/engine/background_loading.rst:6
msgid ""
"When switching the main scene of your game (for example going to a new "
"level), you might want to show a loading screen with some indication that"
" progress is being made. The main load method (``ResourceLoader::load`` "
"or just ``load`` from gdscript) blocks your thread while the resource is "
"being loaded, so It's not good. This document discusses the "
"``ResourceInteractiveLoader`` class for smoother load screens."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:15
msgid "ResourceInteractiveLoader"
msgstr ""

#: ../../tutorials/engine/background_loading.rst:17
msgid ""
"The ``ResourceInteractiveLoader`` class allows you to load a resource in "
"stages. Every time the method ``poll`` is called, a new stage is loaded, "
"and control is returned to the caller. Each stage is generally a sub-"
"resource that is loaded by the main resource. For example, if you're "
"loading a scene that loads 10 images, each image will be one stage."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:26
msgid "Usage is generally as follows"
msgstr ""

#: ../../tutorials/engine/background_loading.rst:29
msgid "Obtaining a ResourceInteractiveLoader"
msgstr ""

#: ../../tutorials/engine/background_loading.rst:35
msgid ""
"This method will give you a ResourceInteractiveLoader that you will use "
"to manage the load operation."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:39
msgid "Polling"
msgstr ""

#: ../../tutorials/engine/background_loading.rst:45
msgid ""
"Use this method to advance the progress of the load. Each call to "
"``poll`` will load the next stage of your resource. Keep in mind that "
"each stage is one entire \"atomic\" resource, such as an image, or a "
"mesh, so it will take several frames to load."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:50
msgid ""
"Returns ``OK`` on no errors, ``ERR_FILE_EOF`` when loading is finished. "
"Any other return value means there was an error and loading has stopped."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:54
msgid "Load progress (optional)"
msgstr ""

#: ../../tutorials/engine/background_loading.rst:56
msgid "To query the progress of the load, use the following methods:"
msgstr ""

#: ../../tutorials/engine/background_loading.rst:63
msgid ""
"``get_stage_count`` returns the total number of stages to load. "
"``get_stage`` returns the current stage being loaded."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:67
msgid "Forcing completion (optional)"
msgstr ""

#: ../../tutorials/engine/background_loading.rst:73
msgid ""
"Use this method if you need to load the entire resource in the current "
"frame, without any more steps."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:77
msgid "Obtaining the resource"
msgstr ""

#: ../../tutorials/engine/background_loading.rst:83
msgid "If everything goes well, use this method to retrieve your loaded resource."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:87
#: ../../tutorials/engine/pausing_games.rst:67
msgid "Example"
msgstr ""

#: ../../tutorials/engine/background_loading.rst:89
msgid ""
"This example demostrates how to load a new scene. Consider it in the "
"context of the :ref:`doc_singletons_autoload` example."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:92
msgid ""
"First we setup some variables and initialize the ``current_scene`` with "
"the main scene of the game:"
msgstr ""

#: ../../tutorials/engine/background_loading.rst:106
msgid ""
"The function ``goto_scene`` is called from the game when the scene needs "
"to be switched. It requests an interactive loader, and calls "
"``set_progress(true)`` to start polling the loader in the ``_progress`` "
"callback. It also starts a \"loading\" animation, which can show a "
"progress bar or loading screen, etc."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:128
msgid ""
"``_process`` is where the loader is polled. ``poll`` is called, and then "
"we deal with the return value from that call. ``OK`` means keep polling, "
"``ERR_FILE_EOF`` means load is done, anything else means there was an "
"error. Also note we skip one frame (via ``wait_frames``, set on the "
"``goto_scene`` function) to allow the loading screen to show up."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:134
msgid ""
"Note how use use ``OS.get_ticks_msec`` to control how long we block the "
"thread. Some stages might load really fast, which means we might be able "
"to cram more than one call to ``poll`` in one frame, some might take way "
"more than your value for ``time_max``, so keep in mind we won't have "
"precise control over the timings."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:170
msgid ""
"Some extra helper functions. ``update_progress`` updates a progress bar, "
"or can also update a paused animation (the animation represents the "
"entire load process from beginning to end). ``set_new_scene`` puts the "
"newly loaded scene on the tree. Because it's a scene being loaded, "
"``instance()`` needs to be called on the resource obtained from the "
"loader."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:195
msgid "Using multiple threads"
msgstr ""

#: ../../tutorials/engine/background_loading.rst:197
msgid ""
"ResourceInteractiveLoader can be used from multiple threads. A couple of "
"things to keep in mind if you attempt it:"
msgstr ""

#: ../../tutorials/engine/background_loading.rst:201
msgid "Use a Semaphore"
msgstr ""

#: ../../tutorials/engine/background_loading.rst:203
msgid ""
"While your thread waits for the main thread to request a new resource, "
"use a Semaphore to sleep (instead of a busy loop or anything similar)."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:207
msgid "Not blocking main thread during the polling"
msgstr ""

#: ../../tutorials/engine/background_loading.rst:209
msgid ""
"If you have a mutex to allow calls from the main thread to your loader "
"class, don't lock it while you call ``poll`` on the loader. When a "
"resource is finished loading, it might require some resources from the "
"low level APIs (VisualServer, etc), which might need to lock the main "
"thread to acquire them. This might cause a deadlock if the main thread is"
" waiting for your mutex while your thread is waiting to load a resource."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:218
msgid "Example class"
msgstr ""

#: ../../tutorials/engine/background_loading.rst:220
msgid ""
"You can find an example class for loading resources in threads here: "
":download:`resource_queue.gd </files/resource_queue.gd>`. Usage is as "
"follows:"
msgstr ""

#: ../../tutorials/engine/background_loading.rst:227
msgid "Call after you instance the class to start the thread."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:233
msgid ""
"Queue a resource. Use optional parameter \"p_in_front\" to put it in "
"front of the queue."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:240
msgid "Remove a resource from the queue, discarding any loading done."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:246
msgid "Returns true if a resource is done loading and ready to be retrieved."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:252
msgid ""
"Get the progress of a resource. Returns -1 on error (for example if the "
"resource is not on the queue), or a number between 0.0 and 1.0 with the "
"progress of the load. Use mostly for cosmetic purposes (updating progress"
" bars, etc), use ``is_ready`` to find out if a resource is actually "
"ready."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:262
msgid ""
"Returns the fully loaded resource, or null on error. If the resource is "
"not done loading (``is_ready`` returns false), it will block your thread "
"and finish the load. If the resource is not on the queue, it will call "
"``ResourceLoader::load`` to load it normally and return it."
msgstr ""

#: ../../tutorials/engine/background_loading.rst:268
#: ../../tutorials/matrices_and_transforms.rst:348
msgid "Example:"
msgstr ""

#: ../../tutorials/engine/background_loading.rst:298
msgid ""
"**Note**: this code in its current form is not tested in real world "
"scenarios. Ask punto on IRC (#godotengine on irc.freenode.net) for help."
msgstr ""

#: ../../tutorials/engine/data_paths.rst:4
msgid "数据路径"
msgstr ""

#: ../../tutorials/engine/data_paths.rst:7
msgid "路径分隔符"
msgstr ""

#: ../../tutorials/engine/data_paths.rst:9
msgid "为了尽可能多的支持更多的平台着想, Godot仅接受unix风格路径分融符 (``/``). 包括windows在引擎任何地方都一样的."
msgstr ""

#: ../../tutorials/engine/data_paths.rst:12
msgid "有一个路径: ``C:\\Projects`` 要写成这样 ``C:/Projects``."
msgstr ""

#: ../../tutorials/engine/data_paths.rst:15
msgid "资源路径"
msgstr ""

#: ../../tutorials/engine/data_paths.rst:17
msgid "就像以前说过的. Godot的工程存在于所给的包含\"engine.cfg\"文本文件的目录, 就算这个目录是空的也一样."
msgstr ""

#: ../../tutorials/engine/data_paths.rst:20
msgid ""
"任何可访问的工程文件都可以通过用``res://``这种路径作为根目录. 打个比方, 一个在根目录下的纹理文件可以用这样的路径名打开: "
"``res://sometexture.png``."
msgstr ""

#: ../../tutorials/engine/data_paths.rst:24
msgid "用户路径 (持久化的数据)"
msgstr ""

#: ../../tutorials/engine/data_paths.rst:26
msgid "当一个工程正在运行, 资源路径是只读的, 这是一个很常见的情形, 由于在一个包内, 它本身就包含可执行或者系统范围的安装路径."
msgstr ""

#: ../../tutorials/engine/data_paths.rst:29
msgid "持久化存储的文件通常应该用``user://`` 作为前缀, 举个栗子: ``user://gamesave.txt``."
msgstr ""

#: ../../tutorials/engine/data_paths.rst:31
msgid ""
"在许多设备中 (打个比方, 移动广告终端) 对于app这个路径就是惟一的. 在桌面操作系统中,  在OSX系统和Linux系统中引擎使用经典的 "
"~/.Name (项目设置检查一下), 在windows系统中使用 APPDATA/Name."
msgstr ""

#: ../../tutorials/engine/encrypting_save_games.rst:4
msgid "Encrypting save games"
msgstr ""

#: ../../tutorials/engine/encrypting_save_games.rst:7
msgid "Why?"
msgstr ""

#: ../../tutorials/engine/encrypting_save_games.rst:9
msgid ""
"Because the world today is not the world of yesterday. A capitalist "
"oligarchy runs the world and forces us to consume in order to keep the "
"gears of this rotten society on track. As such, the biggest market for "
"video game consumption today is the mobile one. It is a market of poor "
"souls forced to compulsively consume digital content in order to forget "
"the misery of their every day life, commute, or just any other brief free"
" moment they have that they are not using to produce goods or services "
"for the ruling class. These individuals need to keep focusing on their "
"video games (because not doing so will produce them a tremendous "
"existential angst), so they go as far as spending money on them to extend"
" their experience, and their preferred way of doing so is through in-app "
"purchases and virtual currency."
msgstr ""

#: ../../tutorials/engine/encrypting_save_games.rst:22
msgid ""
"But, imagine if someone was to find a way to edit the saved games and "
"assign the items and currency without effort? This would be terrible, "
"because it would help players consume the content much faster, and as "
"such run out of it sooner than expected. If this happens they will have "
"nothing that avoids them to think, and the tremendous agony of realizing "
"their own irrelevance would again take over their life."
msgstr ""

#: ../../tutorials/engine/encrypting_save_games.rst:29
msgid ""
"No, we definitely do not want this to happen, so let's see how to encrypt"
" savegames and protect the world order."
msgstr ""

#: ../../tutorials/engine/encrypting_save_games.rst:33
msgid "How?"
msgstr ""

#: ../../tutorials/engine/encrypting_save_games.rst:35
msgid ""
"The class :ref:`File <class_File>` is simple to use, just open a location"
" and read/write data (integers, strings and variants). To create an "
"encrypted file, a passphrase must be provided, like this:"
msgstr ""

#: ../../tutorials/engine/encrypting_save_games.rst:46
msgid ""
"This will make the file unreadable to users, but will still not avoid "
"them to share savefiles. To solve this, using the device unique id or "
"some unique user identifier is needed, for example:"
msgstr ""

#: ../../tutorials/engine/encrypting_save_games.rst:57
msgid "This is all! Thanks for your cooperation, citizen."
msgstr ""

#: ../../tutorials/engine/handling_quit_requests.rst:4
msgid "Handling quit requests"
msgstr ""

#: ../../tutorials/engine/handling_quit_requests.rst:7
msgid "Quitting"
msgstr ""

#: ../../tutorials/engine/handling_quit_requests.rst:9
msgid ""
"Most platforms have the option to request the application to quit. On "
"desktops, this is usually done with the \"x\" icon on the window "
"titlebar. On Android, the back button is used to quit when on the main "
"screen (and to go back otherwise)."
msgstr ""

#: ../../tutorials/engine/handling_quit_requests.rst:15
msgid "Handling the notification"
msgstr ""

#: ../../tutorials/engine/handling_quit_requests.rst:17
msgid ""
"The :ref:`MainLoop <class_MainLoop>` has a special notification that is "
"sent to all nodes when quit is requested: MainLoop.NOTIFICATION_WM_QUIT."
msgstr ""

#: ../../tutorials/engine/handling_quit_requests.rst:21
msgid "Handling it is done as follows (on any node):"
msgstr ""

#: ../../tutorials/engine/handling_quit_requests.rst:29
msgid ""
"When developing mobile apps, quitting is not desired unless the user is "
"on the main screen, so the behavior can be changed."
msgstr ""

#: ../../tutorials/engine/handling_quit_requests.rst:32
msgid ""
"It is important to note that by default, Godot apps have the built-in "
"behavior to quit when quit is requested, this can be changed:"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:4
msgid "输入事件(InputEvent)"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:7
msgid "输入事件是什么？"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:9
msgid ""
"不论是什么操作系统、什么平台，管理输入通常都会比较复杂。为了让事情简单一点，Godot提供了一个特殊的内建类：输入事件（:ref:`InputEvent"
" "
"<class_InputEvent>`）。这个数据类型可以被设置为包含几种不同的输入事件。基于包含多种输入的特点，输入事件会在引擎内部传递，可以在很多位置获得。"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:12
msgid "输入事件如何工作？"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:14
msgid ""
"每一个输入事件都是由用户/玩家发出的（不过你也可以直接生成一个输入事件，然后把它传递给引擎，在处理姿势信息时这种做法很有用）。各个平台的系统对象会从输入设备那里读取输入事件，然后把他们传递给主循环（MainLoop）。因为场景树（:ref:`SceneTree"
" "
"<class_SceneTree>`）是默认的主循环执行器，所以输入事件就传递给场景树了。Godot提供了一个方法来获取当前的场景树对象：**get_tree()**。"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:16
msgid ""
"但是场景树并不知道该如何响应输入事件，所以它会把输入事件传递给视窗，从根视窗（:ref:`Viewport "
"<class_Viewport>`）开始一直往下传（根视窗就是场景树的第一个节点）。针对收到的输入事件，视窗会做一系列的工作，顺序如下："
msgstr ""

#: ../../tutorials/engine/inputevent.rst:20
msgid ""
"首先，它会尝试将输入事件传递给GUI，看看有没有哪个控制节点能响应它。如果有，通过调用方法 "
":ref:`Control._input_event() "
"<class_Control__input_event>`，响应的控制节点（:ref:`Control "
"<class_Control>`）会被使用，同时“输入事件”的信号会被发送出去（这个方法在被继承后，可以通过脚本反复执行）。如果响应的控制节点想要“消耗”掉这个输入事件，它可以调用方法"
" :ref:`Control.accept_event() "
"<class_Control_accept_event>`，这样输入事件就不会继续传递了。"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:22
msgid ""
"如果GUI中没有能响应这个事件的节点，那么所有“输入处理”设置为开（通过 :ref:`Node.set_process_input() "
"<class_Node_set_process_input>` 来设置为开，使用方法 :ref:`Node._input() "
"<class_Node__input>` 会自动设置为开）的节点，都会调用标准输入（standard "
"_input）方法。此时，如果有方法可以消耗这个输入事件，它就会调用 :ref:`SceneTree.set_input_as_handled()"
" <class_SceneTree_set_input_as_handled>`，然后，输入事件就不会继续传递了。"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:24
msgid ""
"如果到了这里，还是没有节点消耗这个输入事件，未处理输入回调会被调用（通过 "
":ref:`Node.set_process_unhandled_input() "
"<class_Node_set_process_unhandled_input>` 开启，使用 "
":ref:`Node._unhandled_input() <class_Node__unhandled_input>` "
"会自动开启）。如果有哪个方法消耗掉了这个事件，它会调用 :ref:`SceneTree.set_input_as_handled() "
"<class_SceneTree_set_input_as_handled>`，然后，输入事件就不会继续传递了。"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:26
msgid ""
"如果还是没有节点消耗这个输入事件，那么一个摄像机（:ref:`Camera "
"<class_Camera>`）会被指定到对应的视窗上；同时，会生成一条射线，指向项目的物理世界（从点击处指向世界）。如果这条射线碰撞到了某个对象，它会针对碰撞到的物理对象调用"
" :ref:`CollisionObject._input_event() "
"<class_CollisionObject__input_event>` "
"方法。（默认地，物体（body）会收到这个回调，但是区域（area）收不到；可以通过调整区域节点（:ref:`Area "
"<class_Area>`）的属性，来设置为可以收到回调）"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:28
msgid "最终，如果这个输入事件还是未处理，它会被传递给场景树中的下一个视窗；如果没有下一个视窗了，它会被直接无视掉。"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:31
msgid "输入事件剖析"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:33
msgid ""
"输入事件（:ref:`InputEvent "
"<class_InputEvent>`）只是一个基础的内建类，它只包含一些基本的信息，比如说事件ID（event "
"ID，会随着事件数增加），设备号（device index），等等。"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:35
msgid "输入事件具有“类型（type）”成员。通过指定它的值，输入事件可以代表不同类型的输入。根据角色不同，每种输入事件都有不同的属性。"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:37
msgid "一个设定事件类型的例子：（译注：例子中新建了一个输入事件，然后才设定为鼠标点击事件）"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:48
msgid "下面的表格中，是一些输入事件的类型："
msgstr ""

#: ../../tutorials/engine/inputevent.rst:52
msgid "事件(Event)"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:52
msgid "类型表示(Index)"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:52
msgid "描述(Description)"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:54
msgid ":ref:`InputEvent <class_InputEvent>`"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:54
msgid "NONE"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:54
msgid "空白输入事件"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:56
msgid ":ref:`InputEventKey <class_InputEventKey>`"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:56
msgid "KEY"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:56
msgid "包含键盘扫描码和Unicode编码， 及修饰键情况"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:59
msgid ":ref:`InputEventMouseButton <class_InputEventMouseButton>`"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:59
msgid "MOUSE_BUTTON"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:59
msgid "包含鼠标点击信息，比如按键、修饰键情况等"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:61
msgid ":ref:`InputEventMouseMotion <class_InputEventMouseMotion>`"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:61
msgid "MOUSE_MOTION"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:61
msgid "包含鼠标移动信息，比如相对、绝对位置 和速度"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:64
msgid ":ref:`InputEventJoystickMotion <class_InputEventJoystickMotion>`"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:64
msgid "JOYSTICK_MOTION"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:64
msgid "包含摇杆、手柄的轴相关信息"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:66
msgid ":ref:`InputEventJoystickButton <class_InputEventJoystickButton>`"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:66
msgid "JOYSTICK_BUTTON"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:66
msgid "包含摇杆、手柄的按键相关信息"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:68
msgid ":ref:`InputEventScreenTouch <class_InputEventScreenTouch>`"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:68
msgid "SCREEN_TOUCH"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:68
msgid "包含多点触摸按下/抬起信息（只在移动设备 上可用）"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:71
msgid ":ref:`InputEventScreenDrag <class_InputEventScreenDrag>`"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:71
msgid "SCREEN_DRAG"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:71
msgid "包含多点触控拖拽信息（只在移动设备上 可用）"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:74
msgid ":ref:`InputEventAction <class_InputEventAction>`"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:74
msgid "SCREEN_ACTION"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:74
msgid "包含一般动作。这类事件通常是由程序员设定 作为反馈使用的。（详见下一节）"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:80
msgid "动作(Actions)"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:82
msgid "一个输入事件可能代表（也可能不代表）一种事先设定好的动作。在编写游戏逻辑时，动作是个很有用的概念，因为它们抽象地代表了不同的输入设备。这就带来以下好处："
msgstr ""

#: ../../tutorials/engine/inputevent.rst:84
msgid "同样的代码可以支持不同设备的不同输入装置。（比如，电脑的键盘，主机上的手柄）"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:86
msgid "在运行中，可以重新设置输入方式。"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:88
msgid ""
"动作可以在 ``项目设置(Project Settings)`` 的 ``动作(Actions)`` 标签页创建。可以看一下 :ref"
":`doc_simple_2d_game-input_actions_setup`，这篇文档具体讲解了如何使用动作编辑器。"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:90
msgid ""
"所有输入事件都有 :ref:`InputEvent.is_action() <class_InputEvent_is_action>`, "
":ref:`InputEvent.is_pressed() <class_InputEvent_is_pressed>` 和 "
":ref:`InputEvent <class_InputEvent>`，这三个方法。"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:93
msgid ""
"另外，你可能会需要从代码中产生动作（一个例子就是检测姿势）。场景树（从主循环中产生的）为此提供了一个方法：:ref:`MainLoop.input_event()"
" <class_MainLoop_input_event>`。你可以这样使用这个方法："
msgstr ""

#: ../../tutorials/engine/inputevent.rst:105
msgid "输入映射（InputMap）"
msgstr ""

#: ../../tutorials/engine/inputevent.rst:107
msgid ""
"我们经常需要从代码层面，自定义、重新设置输入的方法。如果你的整个工作流都是基于动作的，那么输入映射（:ref:`InputMap "
"<class_InputMap>`）单例就是最理想的，在运行中重设、新建动作的方式了。这个单例是不会被保存的（必须通过手动更改才能保存），它直接由项目设置来运行（engine.cfg）。这样一来，该类型的所有动态设置，都可以以程序员认为最优的方式来存储。"
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:4
msgid "支持多语言的游戏"
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:9
msgid ""
"Sería excelente que el mundo hablara solo un idioma. Unfortunately for us"
" developers, that is not the case. While not generally a big requirement "
"when developing indie or niche games, it is also very common that games "
"going into a more massive market require localization."
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:14
msgid ""
"Godot offers many tools to make this process more straightforward, so "
"this tutorial is more like a collection of tips and tricks."
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:17
msgid ""
"Localization is usually done by specific studios hired for the job and, "
"despite the huge amount of software and file formats available for this, "
"the most common way to do localization to this day is still with "
"spreadsheets. The process of creating the spreadsheets and importing them"
" is already covered in the :ref:`doc_importing_translations` tutorial, so"
" this one could be seen more like a follow up to that one."
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:25
msgid "Configuring the imported translation"
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:27
msgid ""
"The translations can get updated and re-imported when they change, but "
"they still have to be added to the project. This is done in Scene > "
"Project Settings > Localization:"
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:33
msgid "This dialog allows to add or remove translations project-wide."
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:36
msgid "Localizing resources"
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:38
msgid ""
"It is also possible to instruct Godot to open alternative versions of "
"assets (resources) depending on the current language. For this the "
"\"Remaps\" tab exists:"
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:44
msgid "Select the resource to be remapped, and the alternatives for each locale."
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:48
msgid "Converting keys to text"
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:50
msgid ""
"Some controls such as :ref:`Button <class_Button>`, :ref:`Label "
"<class_Label>`, etc. will automatically fetch a translation each time "
"they are set a key instead of a text. For example, if a label is assigned"
" \"MAIN_SCREEN_GREETING1\" and a key to different languages exists in the"
" translations, this will be automatically converted. This process is done"
" upon load though, so if the project in question has a dialog that allows"
" changing the language in the settings, the scenes (or at least the "
"settings scene) will have to be re-loaded for new text to have effect."
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:59
msgid ""
"For code, the :ref:`Object.tr() <class_Object_tr>` function can be used. "
"This will just look-up the text into the translations and convert it if "
"found:"
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:69
msgid "Making controls resizeable"
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:71
msgid ""
"The same text in different languages can vary greatly in length. For "
"this, make sure to read the tutorial on :ref:`doc_size_and_anchors`, as "
"having dynamically adjusted control sizes may help. :ref:`Container "
"<class_Container>` can be very useful, as well as the multiple options in"
" :ref:`Label <class_Label>` for text wrapping."
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:78
msgid "TranslationServer"
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:80
msgid ""
"Godot has a server for handling the low level translation management "
"called the :ref:`TranslationServer <class_TranslationServer>`. "
"Translations can be added or removed during run-time, and the current "
"language be changed too."
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:86
msgid "Command line"
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:88
msgid ""
"Language can be tested when running Godot from command line. For example,"
" to test a game in french, the following arguments can be supplied:"
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:97
msgid "Translating the project name"
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:99
msgid ""
"The project name becomes the app name when exporting to different "
"operating systems and platforms. To specify the project name in more than"
" one language, create a new setting application/name in the project "
"settings dialog and append the locale identifier to it. For example:"
msgstr ""

#: ../../tutorials/engine/internationalizing_games.rst:106
msgid ""
"As always, If you don't know the code of a language or zone, :ref:`check "
"the list <doc_locales>`."
msgstr ""

#: ../../tutorials/engine/mouse_and_input_coordinates.rst:4
msgid "鼠标和输入坐标(Mouse and input coordinates)"
msgstr ""

#: ../../tutorials/engine/mouse_and_input_coordinates.rst:7
msgid "关于"
msgstr ""

#: ../../tutorials/engine/mouse_and_input_coordinates.rst:9
msgid "这篇短小的教程，主要是为了指出、阐明一些常见的错误，这类错误往往与输入坐标、获取鼠标位置、屏幕分辨率相关。"
msgstr ""

#: ../../tutorials/engine/mouse_and_input_coordinates.rst:12
msgid "硬件显示坐标系(Hardware display coordinates)"
msgstr ""

#: ../../tutorials/engine/mouse_and_input_coordinates.rst:14
msgid "在绘制复杂的、运行在电脑上的UI时，使用硬件坐标系往往是个明智的选择，比如说在绘制编辑器、MMO游戏、工具类软件的UI时。不过，如果你不是要做上述这类东西，那么使用硬件坐标系就不是个好主意了。"
msgstr ""

#: ../../tutorials/engine/mouse_and_input_coordinates.rst:17
msgid "视窗显示坐标系(Viewport display coordinates)"
msgstr ""

#: ../../tutorials/engine/mouse_and_input_coordinates.rst:19
msgid ""
"Godot使用视窗来显示内容，视窗可以通过一些选项来进行缩放（参见 :ref:`doc_multiple_resolutions` "
"教程）。那么，我们也可以使用针对节点的方法，来获得鼠标的坐标和视窗大小，例如："
msgstr ""

#: ../../tutorials/engine/mouse_and_input_coordinates.rst:38
msgid "另外，也可以直接向视窗请求鼠标的位置，如下："
msgstr ""

#: ../../tutorials/engine/multiple_resolutions.rst:4
msgid "多分辨率(Multiple resolutions)"
msgstr ""

#: ../../tutorials/engine/multiple_resolutions.rst:7
msgid "基础分辨率(Base resolution)"
msgstr ""

#: ../../tutorials/engine/multiple_resolutions.rst:9
msgid "项目的基础屏幕分辨率可以在项目设置（project settings）中进行设定。"
msgstr ""

#: ../../tutorials/engine/multiple_resolutions.rst:13
msgid "但是，具体这个设置做了什么，还不是很清晰。当你的项目运行在PC上时，引擎会尝试将分辨率设置为你在项目设置中设定的值（如果这个尝试失败了，引擎就会尝试设定为小一点的分辨率）。当你的项目运行在移动设备、主机或者是有固定分辨率、设置了全屏渲染的设备上时，你在项目设置中设定的分辨率就会被无视，设备原生的分辨率会被使用。为了解决这个问题，Godot提供了很多方法，来控制如何缩放、拉伸项目的屏幕，以适应不同的屏幕大小。"
msgstr ""

#: ../../tutorials/engine/multiple_resolutions.rst:16
msgid "缩放(Resizing)"
msgstr ""

#: ../../tutorials/engine/multiple_resolutions.rst:18
msgid ""
"现在市面上有很多不同类型的设备，它们的屏幕都不一样，当然它们的像素密度和分辨率也不一样。要想适配所有的屏幕，简直比登天都难……所以Godot试着减轻开发者在这方面的困难。视窗节点（:ref:`Viewport"
" "
"<class_Viewport>`）有一系列方法来处理缩放，而且场景树的根节点一定是一个视窗节点（后来加载的场景实例化后，会作为这个根视窗节点的子节点，这个根视窗节点可以通过调用"
" ``get_tree().get_root()`` 或 ``get_node(\"/root\")`` 方法来访问）。"
msgstr ""

#: ../../tutorials/engine/multiple_resolutions.rst:20
msgid "尽管直接修改根视窗节点参数可能是最灵活的处理缩放问题的方式了，但这种处理方式会带来极大的工作量：不仅代码码起来麻烦，还要靠大量的猜和蒙。所以，Godot在项目设置中，提供了一系列更简单的参数来处理多分辨率问题。"
msgstr ""

#: ../../tutorials/engine/multiple_resolutions.rst:23
msgid "拉伸设置(Stretch settings)"
msgstr ""

#: ../../tutorials/engine/multiple_resolutions.rst:25
msgid "拉伸设置位于项目设置中，它由一系列有多个选项的设定值组成："
msgstr ""

#: ../../tutorials/engine/multiple_resolutions.rst:30
msgid "拉伸模式(Stretch mode)"
msgstr ""

#: ../../tutorials/engine/multiple_resolutions.rst:32
msgid "**禁止模式（Disabled）**：第一种拉伸模式。默认地，就是禁止拉伸（无论屏幕或窗口有多大，无论分辨率有多大，总是1:1的展示）。"
msgstr ""

#: ../../tutorials/engine/multiple_resolutions.rst:33
msgid ""
"**2D模式**：在这种模式下，项目设置中的 ``显示/宽度(display/width)`` 和 "
"``显示/高度(display/height)`` "
"所规定的分辨率，会被拉伸到覆盖整个屏幕。这就意味着3D对象不会被影响（仅仅会以高分辨率渲染），而2D也会被以高分辨率渲染，简单来说就是放大了。"
msgstr ""

#: ../../tutorials/engine/multiple_resolutions.rst:34
msgid ""
"**视窗模式(Viewport)**：视窗模式缩放又有所不同。根视窗节点( :ref:`Viewport <class_Viewport>` "
")会被设置为渲染目标，然后仍然精确地以项目设置中 ``显示/（display/）`` "
"部分所规定的分辨率来渲染。最终，这个视窗会被复制，然后缩放到屏幕大小。这种模式对于要求像素精确的游戏很有用；或者你也可以使用这种模式，来将视窗以低像素渲染来提升游戏运行效率，"
msgstr ""

#: ../../tutorials/engine/multiple_resolutions.rst:40
msgid "拉伸宽高(Stretch aspect)"
msgstr ""

#: ../../tutorials/engine/multiple_resolutions.rst:42
msgid "**忽略(Ignore)**：当拉伸屏幕时，忽略宽高比。这意味着，即使屏幕会变宽或变窄，原始分辨率也会被直接拉伸来适应新的分辨率。"
msgstr ""

#: ../../tutorials/engine/multiple_resolutions.rst:43
msgid "**保持(Keep)**：当拉伸屏幕时，保持宽高比。这意味着，在适应新分辨率时，原始分辨率会被保持。上下、左右有可能会被添加黑边。"
msgstr ""

#: ../../tutorials/engine/multiple_resolutions.rst:44
msgid ""
"**保持宽度(Keep "
"Width)**：当拉伸屏幕时，保持宽高比，但是当新屏幕的分辨率比原始分辨率高时，屏幕会在垂直方向上拉长（视窗会适当地增加更多的垂直分辨率）。通常来讲，这个选项用在GUI和HUD的缩放上最好，这样这些控制器就可以锚定在底部了("
" :ref:`doc_size_and_anchors` )。"
msgstr ""

#: ../../tutorials/engine/multiple_resolutions.rst:45
msgid ""
"**保持高度(Keep "
"Height)**：当拉伸屏幕时，保持宽高比，但是当新屏幕的分辨率比原始分辨率宽时，屏幕会在水平方向上拉长（视窗会适当地增加更多的水平分辨率）。通常来讲，这个选项用在水平滚动的2D游戏上最好（比如说，跑酷类和跳台类游戏）。"
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:4
msgid "Pausing games"
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:7
msgid "Pause?"
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:9
msgid ""
"In most games it is desirable to, at some point, interrupt the game to do"
" something else, such as taking a break or changing options. However this"
" is not as simple as it seems. The game might be stopped, but it might be"
" desirable that some menus and animations continue working."
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:15
msgid ""
"Implementing a fine-grained control for what can be paused (and what can "
"not) is a lot of work, so a simple framework for pausing is provided in "
"Godot."
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:20
msgid "How pausing works"
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:22
msgid ""
"To set pause mode, the pause state must be set. This is done by calling "
":ref:`SceneTree.set_pause() <class_SceneTree_set_pause>` with a \"true\" "
"argument:"
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:30
msgid "Doing so will have the following behavior:"
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:32
msgid "2D and 3D physics will be stopped."
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:33
msgid "_process and _fixed_process will not be called anymore in nodes."
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:34
msgid "_input and _input_event will not be called anymore either."
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:36
msgid ""
"This effectively stops the whole game. Calling this function from a "
"script, by default, will result in an unrecoverable state (nothing will "
"work anymore!)."
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:41
msgid "White-listing nodes"
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:43
msgid ""
"Before enabling pause, make sure that nodes that must keep working during"
" pause are white-listed. This is done by editing the \"Pause Mode\" "
"property in a node:"
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:49
msgid ""
"By default all nodes have this property in the \"Inherit\" state. This "
"means, that they will only process (or not) depending on what this same "
"property is set on the parent node. If the parent is set to \"Inherit\" ,"
" then the grandparent will be checked and so on. Ultimately, if a state "
"can't be found in any of the grandparents, the pause state in SceneTree "
"is used. This means that, by default, when the game is paused every node "
"will be paused."
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:57
msgid "So the three possible states for a node are:"
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:59
msgid ""
"**Inherit**: Process depending on the state of the parent, grandparent, "
"etc. The first parent that has a non-Inherit state."
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:61
msgid ""
"**Stop**: Stop the node no matter what (and children in Inherit mode). "
"When paused this node will not process."
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:63
msgid ""
"**Process**: Process the node no matter what (and children in Inherit "
"mode). Paused or not this node will process."
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:69
msgid ""
"An example of this is creating a popup or panel with controls inside, and"
" set it's pause mode to \"Process\" then just hide it:"
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:74
msgid ""
"Just by setting the root of the pause popup to \"Process\", all children "
"and grandchildren will inherit that state. This way, this branch of the "
"scene tree will continue working when paused."
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:78
msgid ""
"Finally, make it so when a pause button is pressed (any button will do), "
"enable the pause and show the pause screen."
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:87
msgid "To remove the pause, just do the opposite when the pause screen is closed:"
msgstr ""

#: ../../tutorials/engine/pausing_games.rst:96
msgid "And that should be all!"
msgstr ""

#: ../../tutorials/engine/project_organization.rst:4
msgid "Project organization"
msgstr ""

#: ../../tutorials/engine/project_organization.rst:9
msgid ""
"This tutorial is aimed to propose a simple workflow on how to organize "
"projects. Since Godot allows the programmer to use the file-system as he "
"or she pleases, figuring out a way to organize the projects when starting"
" to use the engine can be a little challenging. Because of this, a simple"
" workflow will be described, which can be used or not, but should work as"
" a starting point."
msgstr ""

#: ../../tutorials/engine/project_organization.rst:16
msgid ""
"Additionally, using version control can be challenging so this "
"proposition will include that too."
msgstr ""

#: ../../tutorials/engine/project_organization.rst:20
msgid "Organization"
msgstr ""

#: ../../tutorials/engine/project_organization.rst:22
msgid ""
"Other game engines often work by having an asset database, were you can "
"browse images, models, sounds, etc. Godot is more scene-based in nature "
"so most of the time the assets are bundled inside the scenes or just "
"exist as files but are referenced from scenes."
msgstr ""

#: ../../tutorials/engine/project_organization.rst:28
msgid "Importing & game folder"
msgstr ""

#: ../../tutorials/engine/project_organization.rst:30
msgid ""
"It is very often necessary to use asset importing in Godot. As the source"
" assets for importing are also recognized as resources by the engine, "
"this can become a problem if both are inside the project folder, because "
"at the time of export the exporter will recognize them and export both."
msgstr ""

#: ../../tutorials/engine/project_organization.rst:36
msgid ""
"To solve this, it is a good practice to have your game folder inside "
"another folder (the actual project folder). This allows to have the game "
"assets separated from the source assets, and also allows to use version "
"control (such as svn or git) for both. Here is an example:"
msgstr ""

#: ../../tutorials/engine/project_organization.rst:49
msgid "Then also, the game itself is, in this case, inside a game/ folder:"
msgstr ""

#: ../../tutorials/engine/project_organization.rst:61
msgid "Following this layout, many things can be done:"
msgstr ""

#: ../../tutorials/engine/project_organization.rst:63
msgid "The whole project is still inside a folder (myproject/)."
msgstr ""

#: ../../tutorials/engine/project_organization.rst:64
msgid ""
"Exporting the project will not export the .wav and .png files which were "
"imported."
msgstr ""

#: ../../tutorials/engine/project_organization.rst:66
msgid ""
"myproject/ can be put directly inside a VCS (like svn or git) for version"
" control, both game and source assets are kept track of."
msgstr ""

#: ../../tutorials/engine/project_organization.rst:68
msgid ""
"If a team is working on the project, assets can be re-imported by other "
"project members, because Godot keeps track of source assets using "
"relative paths."
msgstr ""

#: ../../tutorials/engine/project_organization.rst:73
msgid "Scene organization"
msgstr ""

#: ../../tutorials/engine/project_organization.rst:75
msgid ""
"Inside the game folder, a question that often arises is how to organize "
"the scenes in the filesystem. Many developers try asset-type based "
"organization and end up having a mess after a while, so the best answer "
"is probably to organize them based on how the game works and not based on"
" asset type. Here are some examples."
msgstr ""

#: ../../tutorials/engine/project_organization.rst:81
msgid ""
"If you were organizing your project based on asset type, it would look "
"like this:"
msgstr ""

#: ../../tutorials/engine/project_organization.rst:95
msgid ""
"Which is generally a bad idea. When a project starts growing beyond a "
"certain point, this becomes unmanageable. It's really difficult to tell "
"what belongs to what."
msgstr ""

#: ../../tutorials/engine/project_organization.rst:99
msgid ""
"It's generally a better idea to use game-context based organization, "
"something like this:"
msgstr ""

#: ../../tutorials/engine/project_organization.rst:119
msgid ""
"This model or similar models allows projects to grow to really large "
"sizes and still be completely manageable. Notice that everything is based"
" on parts of the game that can be named or described, like the settings "
"screen or the valley. Since everything in Godot is done with scenes, and "
"everything that can be named or described can be a scene, this workflow "
"is very smooth and easygoing."
msgstr ""

#: ../../tutorials/engine/project_organization.rst:127
msgid "Cache files"
msgstr ""

#: ../../tutorials/engine/project_organization.rst:129
msgid ""
"Godot uses a hidden file called \".fscache\" at the root of the project. "
"On it, it caches project files and is used to quickly know when one is "
"modified. Make sure to **not commit this file** to git or svn, as it "
"contains local information and might confuse another editor instance in "
"another computer."
msgstr ""

#: ../../tutorials/engine/saving_games.rst:4
msgid "Saving games"
msgstr ""

#: ../../tutorials/engine/saving_games.rst:9
msgid ""
"Save games can be complicated. It can be desired to store more "
"information than the current level or number of stars earned on a level. "
"More advanced save games may need to store additional information about "
"an arbitrary number of objects. This will allow the save function to "
"scale as the game grows more complex."
msgstr ""

#: ../../tutorials/engine/saving_games.rst:16
msgid "Identify persistent objects"
msgstr ""

#: ../../tutorials/engine/saving_games.rst:18
msgid ""
"First we should identify what objects we want to keep between game "
"sessions and what information we want to keep from those objects. For "
"this tutorial, we will use groups to mark and handle objects to be saved "
"but other methods are certainly possible."
msgstr ""

#: ../../tutorials/engine/saving_games.rst:23
msgid ""
"We will start by adding objects we wish to save to the \"Persist\" group."
" As in the :ref:`doc_scripting_continued` tutorial, we can do this "
"through the GUI or through script. Let's add the relevant nodes using the"
" GUI:"
msgstr ""

#: ../../tutorials/engine/saving_games.rst:29
msgid ""
"Once this is done when we need to save the game we can get all objects to"
" save them and then tell them all to save with this script:"
msgstr ""

#: ../../tutorials/engine/saving_games.rst:39
msgid "Serializing"
msgstr ""

#: ../../tutorials/engine/saving_games.rst:41
msgid ""
"The next step is to serialize the data. This makes it much easier to read"
" and store to disk. In this case, we're assuming each member of group "
"Persist is an instanced node and thus has a path. GDScript has helper "
"functions for this, such as :ref:`Dictionary.to_json() "
"<class_Dictionary_to_json>` and :ref:`Dictionary.parse_json() "
"<class_Dictionary_parse_json>`, so we will use a dictionary. Our node "
"needs to contain a save function that returns this data. The save "
"function will look like this:"
msgstr ""

#: ../../tutorials/engine/saving_games.rst:75
msgid ""
"This gives us a dictionary with the style ``{ "
"\"variable_name\":that_variables_value }`` which will be useful when "
"loading."
msgstr ""

#: ../../tutorials/engine/saving_games.rst:80
msgid "Saving and reading data"
msgstr ""

#: ../../tutorials/engine/saving_games.rst:82
msgid ""
"As covered in the :ref:`doc_filesystem` tutorial, we'll need to open a "
"file and write to it and then later read from it. Now that we have a way "
"to call our groups and get their relevant data, let's use to_json() to "
"convert it into an easily stored string and store them in a file. Doing "
"it this way ensures that each line is its own object so we have an easy "
"way to pull the data out of the file as well."
msgstr ""

#: ../../tutorials/engine/saving_games.rst:102
msgid ""
"Game saved! Loading is fairly simple as well. For that we'll read each "
"line, use parse_json() to read it back to a dict, and then iterate over "
"the dict to read our values. But we'll need to first create the object "
"and we can use the filename and parent values to achieve that. Here is "
"our load function:"
msgstr ""

#: ../../tutorials/engine/saving_games.rst:138
msgid ""
"And now we can save and load an arbitrary number of objects laid out "
"almost anywhere across the scene tree! Each object can store different "
"data depending on what it needs to save."
msgstr ""

#: ../../tutorials/engine/saving_games.rst:143
msgid "Some notes"
msgstr ""

#: ../../tutorials/engine/saving_games.rst:145
msgid ""
"We may have glossed over a step, but setting the game state to one fit to"
" start loading data can be very complicated. This step will need to be "
"heavily customized based on the needs of an individual project."
msgstr ""

#: ../../tutorials/engine/saving_games.rst:149
msgid ""
"This implementation assumes no Persist objects are children of other "
"Persist objects. Doing so would create invalid paths. If this is one of "
"the needs of a project this needs to be considered. Saving objects in "
"stages (parent objects first) so they are available when child objects "
"are loaded will make sure they're available for the add_child() call. "
"There will also need to be some way to link children to parents as the "
"nodepath will likely be invalid."
msgstr ""

#: ../../tutorials/engine/viewports.rst:4
msgid "视图(Viewports)"
msgstr ""

#: ../../tutorials/engine/viewports.rst:7
msgid "简介"
msgstr ""

#: ../../tutorials/engine/viewports.rst:9
msgid ""
"Godot有一个小巧却非常有用的特点，称为视图(viewport)。顾名思义，视图就是用来描绘游戏世界的一个长方形区域。视图有三个主要的应用，不过也可以很灵活的应用到更多方面。"
" 所有的应用都是通过视图节点( :ref:`Viewport <class_Viewport>` )实现的。"
msgstr ""

#: ../../tutorials/engine/viewports.rst:14
msgid "上面提到的三个主要应用如下："
msgstr ""

#: ../../tutorials/engine/viewports.rst:16
msgid ""
"**场景根节点(Scence Root)**: "
"当前活跃场景的根总是一个视图。这个视图负责展示用户所创建的场景。（看了前面的教程你应该已经知道这个了！）"
msgstr ""

#: ../../tutorials/engine/viewports.rst:18
msgid ""
"**子视图(Sub-viewport)**: 当视图是控制节点（:ref:`Control "
"<class_Control>`）的子节点时，可以创建子视图。"
msgstr ""

#: ../../tutorials/engine/viewports.rst:20
msgid ""
"**渲染目标(Render Targets)**: "
"视图可以设定为“渲染目标(RenderTarget)”模式。这表示视图不能直接被看到，但是它的内容可以通过材质(:ref:`Texture "
"<class_Texture>`) 获取。"
msgstr ""

#: ../../tutorials/engine/viewports.rst:23
msgid "输入(Input)"
msgstr ""

#: ../../tutorials/engine/viewports.rst:25
msgid ""
"视图还可以用来将调整、缩放过的输入事件传递给它的子节点。根视图和子视图会自动执行这种传达，但是渲染目标模式下的视图不会自动执行。因此，如果需要渲染目标模式的视图也执行这种传递，用户必须手动调用:ref:`Viewport.input()"
" <class_Viewport_input>` 方法来达到目的。"
msgstr ""

#: ../../tutorials/engine/viewports.rst:28
msgid "收听站(Listener)"
msgstr ""

#: ../../tutorials/engine/viewports.rst:30
msgid "Godot支持3D声音（2D节点和3D节点都支持），关于这一点将在另外一篇教程中详细讨论（不知道哪天……）。为了让这类声音能够被人听到，视图需要启用收听站（可以支持2D和3D）。如果你使用自定义的视图来展示你的世界，别忘了启用收听站哦！"
msgstr ""

#: ../../tutorials/engine/viewports.rst:32
msgid "译者注：注意此处listener并非指监听器"
msgstr ""

#: ../../tutorials/engine/viewports.rst:35
msgid "摄像机(2D & 3D)"
msgstr ""

#: ../../tutorials/engine/viewports.rst:37
msgid ""
"当使用2D或者3D的摄像机节点(:ref:`Camera "
"<class_Camera>`/:ref:`Camera2D<class_Camera2D>`)时，该摄像机节点总是会显示在最近的父视图节点上（向根节点方向的最近）。例如，在下面的这种结构中："
msgstr ""

#: ../../tutorials/engine/viewports.rst:39
#: ../../tutorials/engine/viewports.rst:47
#: ../../tutorials/engine/viewports.rst:109
msgid "视图(Viewport)"
msgstr ""

#: ../../tutorials/engine/viewports.rst:41
#: ../../tutorials/engine/viewports.rst:45
msgid "摄像机(Camera)"
msgstr ""

#: ../../tutorials/engine/viewports.rst:43
msgid "上面这个摄像机节点会显示在它的父视图节点上，但是看下面这个例子："
msgstr ""

#: ../../tutorials/engine/viewports.rst:49
msgid "这里的摄像机节点就不会显示在例子中的视图节点上（如果这是一个子场景的话，可能它会显示在根视图节点上）"
msgstr ""

#: ../../tutorials/engine/viewports.rst:51
msgid ""
"每个视图都只能有一个活跃中的摄像机节点，所以如果你的视图有多于一个摄像机 "
"节点，请确保你想用的那个摄像机节点被设置了“当前(current)”属性。 或者，你也可以通过如下方法来设定当前摄像机："
msgstr ""

#: ../../tutorials/engine/viewports.rst:60
msgid "缩放和拉伸(Scale & stretching)"
msgstr ""

#: ../../tutorials/engine/viewports.rst:62
msgid "视图具有\"矩形（rect）\"属性。\"矩形\"属性中的X和Y这两个值不常用（通常只有根视图会使用这两个值；译注：这两个值是用来描述视图位置的），但是宽度（WIDTH）和高度（HEIGHT）这两个值很常用，这两个值是以像素为单位描述视图大小的。对于子视图节点，这些值会被父控制节点的对应值所覆盖；而对于\"渲染目标\"模式的视图，这些值设定了分辨率。"
msgstr ""

#: ../../tutorials/engine/viewports.rst:64
msgid "我们也可以调用一些方法来缩放（视图中的）2D内容，使视图的分辨率不同于在\"矩形\"属性中设定的值。这些方法如下："
msgstr ""

#: ../../tutorials/engine/viewports.rst:71
msgid "根视图可在项目设置（project settings）中，使用这些方法来设置其拉伸选项。"
msgstr ""

#: ../../tutorials/engine/viewports.rst:75
msgid "世界(Worlds)"
msgstr ""

#: ../../tutorials/engine/viewports.rst:77
msgid ""
"对于3D来讲，视图会包含世界（:ref:`World "
"<class_World>`）资源。世界是将物体与渲染绑定在一起的一个宇宙。基于空间的节点，会绑定在离它最近的视图节点的世界上。默认地，新建的视图节点都不包含独立的世界，而是使用其父视图的世界（当然，默认情况下，根视图会带有一个世界，也就是展示出所有对象的那个）。世界可以通过视图的“世界”属性来创建；一旦一个世界被创建在某个视图节点上，该视图的所有子节点都会停止与该视图的父视图的世界进行交互。当你想要强制以3D展示一个独立的角色时，这个特性会非常有用（就像在《星际争霸1》中那样）。"
msgstr ""

#: ../../tutorials/engine/viewports.rst:79
msgid "有时候你想要创建只展示单个对象的视图节点，又不想为它创建世界；视图对此提供了很好的支持，视图可以被设置为使用自己的世界。当你想在2D世界中，实例化3D角色或对象时，这点会非常有用。"
msgstr ""

#: ../../tutorials/engine/viewports.rst:81
msgid ""
"对于2D来讲，，每个视图都会包含自己的世界2D（:ref:`World2D "
"<class_World2D>`）资源。在大多数情况下，这就够用了；不过你可能也会需要（在视图间）分享世界，分享世界可以通过手动调用视图API来实现。"
msgstr ""

#: ../../tutorials/engine/viewports.rst:84
msgid "捕捉(Capture)"
msgstr ""

#: ../../tutorials/engine/viewports.rst:86
msgid "我们也可以捕捉视图节点的内容。对于根视图，实际上就等于截屏。捕捉可以通过调用如下API实现："
msgstr ""

#: ../../tutorials/engine/viewports.rst:93
msgid "在一两帧之后，捕捉就完成了(check _process())。我们可以使用下面的方法来取得捕捉内容："
msgstr ""

#: ../../tutorials/engine/viewports.rst:99
msgid "如果上面方法返回的图像是空的，那捕捉可能还没进行；多等一会再试一下，因为这个API是异步的。"
msgstr ""

#: ../../tutorials/engine/viewports.rst:103
msgid "子视图(Sub-viewport)"
msgstr ""

#: ../../tutorials/engine/viewports.rst:105
msgid "如果视图节点是一个控制节点的子节点，它将活跃起来，展示它所包含的内容。这个布局看起来会像这样："
msgstr ""

#: ../../tutorials/engine/viewports.rst:107
msgid "控制(Control)"
msgstr ""

#: ../../tutorials/engine/viewports.rst:111
msgid "上面的视图节点会完全覆盖其父控制节点的区域。"
msgstr ""

#: ../../tutorials/engine/viewports.rst:116
msgid "渲染目标(Render target)"
msgstr ""

#: ../../tutorials/engine/viewports.rst:118
msgid ""
"只要将视图的“渲染目标(render "
"target)”属性开启，它就被设置成了渲染目标。注意，此时，视图内包含的内容不能在场景编辑器中看到。只有渲染目标贴图被使用了，视图包含的内容才能被看到。可以通过下面的代码，来使用渲染目标贴图（这里只是例子）："
msgstr ""

#: ../../tutorials/engine/viewports.rst:125
msgid "默认地，当渲染目标贴图在一帧中被绘制后，渲染目标就会被重新渲染一次：如果渲染目标被设置为可见，它就会被渲染；如果设置为不可见，它就不会被渲染。上述渲染方式可以变更设置为：手动渲染（一次）；或总是渲染，不管设置为可见或不可见。"
msgstr ""

#: ../../tutorials/engine/viewports.rst:127
msgid "为了让渲染目标针对常见情况使用起来更简便，我们在编辑器内设置了几个类："
msgstr ""

#: ../../tutorials/engine/viewports.rst:129
msgid "视图精灵（:ref:`ViewportSprite <class_ViewportSprite>` ）(针对2D)."
msgstr ""

#: ../../tutorials/engine/viewports.rst:130
msgid ":strike:`ViewportQuad (for 3D).` #2.0中已删除"
msgstr ""

#: ../../tutorials/engine/viewports.rst:131
msgid ":strike:`ViewportFrame (for GUI).` #2.0中已删除"
msgstr ""

#: ../../tutorials/engine/viewports.rst:133
msgid "*TODO：重新编辑文档，ViewportQuad和ViewportFrame在2.0中已删除。*"
msgstr ""

#: ../../tutorials/engine/viewports.rst:135
msgid ""
"别忘了去看看视图的demo！Demo存档中的视图文件夹可以下载，或者访问 "
"https://github.com/godotengine/godot/tree/master/demos/viewport"
msgstr ""

#: ../../tutorials/http_client_class.rst:4
msgid "HTTP client class"
msgstr ""

#: ../../tutorials/http_client_class.rst:6
msgid ""
"Here's an example of using the :ref:`HTTPClient <class_HTTPClient>` "
"class. It's just a script, so it can be run by executing:"
msgstr ""

#: ../../tutorials/http_client_class.rst:13
msgid "It will connect and fetch a website."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:4
msgid "Matrices and transforms"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:9
msgid ""
"Before reading this tutorial, it is advised to read the previous one "
"about :ref:`doc_vector_math` as this one is a direct continuation."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:12
msgid ""
"This tutorial will be about *transformations* and will cover a little "
"about matrices (but not in-depth)."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:15
msgid ""
"Transformations are most of the time applied as translation, rotation and"
" scale so they will be considered as priority here."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:19
msgid "Oriented coordinate system (OCS)"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:21
msgid ""
"Imagine we have a spaceship somewhere in space. In Godot this is easy, "
"just move the ship somewhere and rotate it:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:26
msgid ""
"Ok, so in 2D this looks simple, a position and an angle for a rotation. "
"But remember, we are grown ups here and don't use angles (plus, angles "
"are not really even that useful when working in 3D)."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:30
msgid ""
"We should realize that at some point, someone *designed* this spaceship. "
"Be it for 2D in a drawing such as Paint.net, Gimp, Photoshop, etc. or in "
"3D through a 3D DCC tool such as Blender, Max, Maya, etc."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:35
msgid ""
"When it was designed, it was not rotated. It was designed in it's own "
"*coordinate system*."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:40
msgid ""
"This means that the tip of the ship has a coordinate, the fin has "
"another, etc. Be it in pixels (2D) or vertices (3D)."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:43
msgid "So, let's recall again that the ship was somewhere in space:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:47
msgid ""
"How did it get there? What moved it and rotated it from the place it was "
"designed to it's current position? The answer is... a **transform**, the "
"ship was *transformed* from their original position to the new one. This "
"allows the ship to be displayed where it is."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:52
msgid ""
"But transform is too generic of a term to describe this process. To solve"
" this puzzle, we will superimpose the ship's original design position at "
"their current position:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:58
msgid ""
"So, we can see that the \"design space\" has been transformed too. How "
"can we best represent this transformation? Let's use 3 vectors for this "
"(in 2D), a unit vector pointing towards X positive, a unit vector "
"pointing towards Y positive and a translation."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:65
msgid ""
"Let's call the 3 vectors \"X\", \"Y\" and \"Origin\", and let's also "
"superimpose them over the ship so it makes more sense:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:70
msgid ""
"Ok, this is nicer, but it still does not make sense. What do X,Y and "
"Origin have to do with how the ship got there?"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:73
msgid "Well, let's take the point from top tip of the ship as reference:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:77
msgid ""
"And let's apply the following operation to it (and to all the points in "
"the ship too, but we'll track the top tip as our reference point):"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:84
msgid "Doing this to the selected point will move it back to the center:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:88
msgid ""
"This was expected, but then let's do something more interesting. Use the "
"dot product of X and the point, and add it to the dot product of Y and "
"the point:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:96
msgid ""
"Then what we have is.. wait a minute, it's the ship in it's design "
"position!"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:101
msgid ""
"How did this black magic happen? The ship was lost in space, and now it's"
" back home!"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:104
msgid ""
"It might seem strange, but it does have plenty of logic. Remember, as we "
"have seen in the :ref:`doc_vector_math`, what happened is that the "
"distance to X axis, and the distance to Y axis were computed. Calculating"
" distance in a direction or plane was one of the uses for the dot "
"product. This was enough to obtain back the design coordinates for every "
"point in the ship."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:111
msgid ""
"So, what he have been working with so far (with X, Y and Origin) is an "
"*Oriented Coordinate System\\*. X an Y are the **Basis**, and \\*Origin* "
"is the offset."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:116
msgid "Basis"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:118
msgid ""
"We know what the Origin is. It's where the 0,0 (origin) of the design "
"coordinate system ended up after being transformed to a new position. "
"This is why it's called *Origin*, But in practice, it's just an offset to"
" the new position."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:123
msgid ""
"The Basis is more interesting. The basis is the direction of X and Y in "
"the OCS from the new, transformed location. It tells what has changed, in"
" either 2D or 3D. The Origin (offset) and Basis (direction) communicate "
"\"Hey, the original X and Y axes of your design are *right here*, "
"pointing towards *these directions*.\""
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:129
msgid ""
"So, let's change the representation of the basis. Instead of 2 vectors, "
"let's use a *matrix*."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:134
msgid ""
"The vectors are up there in the matrix, horizontally. The next problem "
"now is that.. what is this matrix thing? Well, we'll assume you've never "
"heard of a matrix."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:139
msgid "Transforms in Godot"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:141
msgid ""
"This tutorial will not explain matrix math (and their operations) in "
"depth, only its practical use. There is plenty of material for that, "
"which should be a lot simpler to understand after completing this "
"tutorial. We'll just explain how to use transforms."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:147
msgid "Matrix32"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:149
msgid ""
":ref:`Matrix32 <class_Matrix32>` is a 3x2 matrix. It has 3 Vector2 "
"elements and it's used for 2D. The \"X\" axis is the element 0, \"Y\" "
"axis is the element 1 and \"Origin\" is element 2. It's not divided in "
"basis/origin for convenience, due to it's simplicity."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:161
msgid ""
"Most operations will be explained with this datatype (Matrix32), but the "
"same logic applies to 3D."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:165
msgid "Identity"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:167
msgid "By default, Matrix32 is created as an \"identity\" matrix. This means:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:169
msgid "'X' Points right: Vector2(1,0)"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:170
msgid "'Y' Points up (or down in pixels): Vector2(0,1)"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:171
msgid "'Origin' is the origin Vector2(0,0)"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:175
msgid ""
"It's easy to guess that an *identity* matrix is just a matrix that aligns"
" the transform to it's parent coordinate system. It's an *OCS* that "
"hasn't been translated, rotated or scaled. All transform types in Godot "
"are created with *identity*."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:181
msgid "Operations"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:186
msgid "Rotating Matrix32 is done by using the \"rotated\" function:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:196
msgid "Translation"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:198
msgid ""
"There are two ways to translate a Matrix32, the first one is just moving "
"the origin:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:210
msgid "This will always work in global coordinates."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:212
msgid ""
"If instead, translation is desired in *local* coordinates of the matrix "
"(towards where the *basis* is oriented), there is the "
":ref:`Matrix32.translated() <class_Matrix32_translated>` method:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:227
msgid "Scale"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:229
msgid ""
"A matrix can be scaled too. Scaling will multiply the basis vectors by a "
"vector (X vector by x component of the scale, Y vector by y component of "
"the scale). It will leave the origin alone:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:241
msgid ""
"These kind of operations in matrices are accumulative. It means every one"
" starts relative to the previous one. For those that have been living on "
"this planet long enough, a good reference of how transform works is this:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:248
msgid ""
"A matrix is used similarly to a turtle. The turtle most likely had a "
"matrix inside (and you are likely learning this may years *after* "
"discovering Santa is not real)."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:255
msgid ""
"Transform is the act of switching between coordinate systems. To convert "
"a position (either 2D or 3D) from \"designer\" coordinate system to the "
"OCS, the \"xform\" method is used."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:263
msgid "And only for basis (no translation):"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:269
msgid "Post - multiplying is also valid:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:276
msgid "Inverse transform"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:278
msgid ""
"To do the opposite operation (what we did up there with the rocket), the "
"\"xform_inv\" method is used:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:285
msgid "Only for Basis:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:291
msgid "Or pre-multiplication:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:298
msgid "Orthonormal matrices"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:300
msgid ""
"However, if the Matrix has been scaled (vectors are not unit length), or "
"the basis vectors are not orthogonal (90°), the inverse transform will "
"not work."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:304
msgid ""
"In other words, inverse transform is only valid in *orthonormal* "
"matrices. For this, these cases an affine inverse must be computed."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:307
msgid ""
"The transform, or inverse transform of an identity matrix will return the"
" position unchanged:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:316
msgid "Affine inverse"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:318
msgid ""
"The affine inverse is a matrix that does the inverse operation of another"
" matrix, no matter if the matrix has scale or the axis vectors are not "
"orthogonal. The affine inverse is calculated with the affine_inverse() "
"method:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:330
msgid "If the matrix is orthonormal, then:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:340
msgid "Matrix multiplication"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:342
msgid ""
"Matrices can be multiplied. Multiplication of two matrices \"chains\" "
"(concatenates) their transforms."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:345
msgid "However, as per convention, multiplication takes place in reverse order."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:354
msgid "To make it a little clearer, this:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:361
msgid "Is the same as:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:368
msgid "However, this is not the same:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:375
msgid "Because in matrix math, A + B is not the same as B + A."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:378
msgid "Multiplication by inverse"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:380
msgid "Multiplying a matrix by it's inverse, results in identity"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:388
msgid "Multiplication by identity"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:390
msgid "Multiplying a matrix by identity, will result in the unchanged matrix:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:398
msgid "Matrix tips"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:400
msgid ""
"When using a transform hierarchy, remember that matrix multiplication is "
"reversed! To obtain the global transform for a hierarchy, do:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:407
msgid "For 3 levels:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:414
msgid ""
"To make a matrix relative to the parent, use the affine inverse (or "
"regular inverse for orthonormal matrices)."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:422
msgid "Revert it just like the example above:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:429
msgid ""
"OK, hopefully this should be enough! Let's complete the tutorial by "
"moving to 3D matrices."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:433
msgid "Matrices & transforms in 3D"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:435
msgid ""
"As mentioned before, for 3D, we deal with 3 :ref:`Vector3 "
"<class_Vector3>` vectors for the rotation matrix, and an extra one for "
"the origin."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:439
msgid "Matrix3"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:441
msgid ""
"Godot has a special type for a 3x3 matrix, named :ref:`Matrix3 "
"<class_Matrix3>`. It can be used to represent a 3D rotation and scale. "
"Sub vectors can be accessed as:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:452
msgid "Or, alternatively as:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:461
msgid "Matrix3 is also initialized to Identity by default:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:466
msgid "Rotation in 3D"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:468
msgid ""
"Rotation in 3D is more complex than in 2D (translation and scale are the "
"same), because rotation is an implicit 2D operation. To rotate in 3D, an "
"*axis*, must be picked. Rotation, then, happens around this axis."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:472
msgid ""
"The axis for the rotation must be a *normal vector*. As in, a vector that"
" can point to any direction, but length must be one (1.0)."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:484
msgid ""
"To add the final component to the mix, Godot provides the :ref:`Transform"
" <class_Transform>` type. Transform has two members:"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:487
msgid "*basis* (of type :ref:`Matrix3 <class_Matrix3>`"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:488
msgid "*origin* (of type :ref:`Vector3 <class_Vector3>`"
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:490
msgid ""
"Any 3D transform can be represented with Transform, and the separation of"
" basis and origin makes it easier to work translation and rotation "
"separately."
msgstr ""

#: ../../tutorials/matrices_and_transforms.rst:494
msgid "An example:"
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:4
msgid "Mesh generation with heightmap and shaders"
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:9
msgid ""
"This tutorial will help you to use Godot shaders to deform a plane mesh "
"so it appears like a basic terrain. Remember that this solution has pros "
"and cons."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:13
msgid "Pros:"
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:15
msgid "Pretty easy to do."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:16
msgid "This approach allows computation of LOD terrains."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:17
msgid "The heightmap can be used in Godot to create a normal map."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:19
msgid "Cons:"
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:21
msgid ""
"The Vertex Shader can't re-compute normals of the faces. Thus, if your "
"mesh is not static, this method will **not** work with shaded materials."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:24
msgid ""
"This tutorial uses a plane mesh imported from Blender to Godot Engine. "
"Godot is able to create meshes as well."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:27
msgid ""
"See this tutorial as an introduction, not a method that you should employ"
" in your games, except if you intend to do LOD. Otherwise, this is "
"probably not the best way."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:31
msgid ""
"However, let's first create a heightmap,or a 2D representation of the "
"terrain. To do this, I'll use GIMP, but you can use any image editor you "
"like."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:35
msgid "The heightmap"
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:37
msgid ""
"We will use a few functions of GIMP image editor to produce a simple "
"heightmap. Start GIMP and create a square image of 512x512 pixels."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:42
msgid "You are now in front of a new, blank, square image."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:46
msgid "Then, use a filter to render some clouds on this new image."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:50
msgid ""
"Parameter this filter to whatever you want. A white pixel corresponds to "
"the highest point of the heightmap, a black pixel corresponds to the "
"lowest one. So, darker regions are valleys and brighter are mountains. If"
" you want, you can check \"tileable\" to render a heightmap that can be "
"cloned and tiled close together with another one. X and Y size don't "
"matter a lot as long as they are big enough to provide a decent ground. A"
" value of 4.0 or 5.0 for both is nice. Click on the \"New Seed\" button "
"to roll a dice and GIMP will create a new random heightmap. Once you are "
"happy with the result, click \"OK\"."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:62
msgid ""
"You can continue to edit your image if you wish. For our example, let's "
"keep the heightmap as is, and let's export it to a PNG file, say "
"\"heightmap.png\". Save it in your Godot project folder."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:67
msgid "The plane mesh"
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:69
msgid "Now, we will need a plane mesh to import in Godot. Let's run Blender."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:73
msgid "Remove the start cube mesh, then add a new plane to the scene."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:77
msgid ""
"Zoom a bit, then switch to Edit mode (Tab key) and in the Tools "
"buttongroup at the left, hit \"Subdivide\" 5 or 6 times."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:82
msgid ""
"Your mesh is now subdivided, which means we added vertices to the plane "
"mesh that we will later be able to move. Job's not finished yet: in order"
" to texture this mesh a proper UV map is necessary. Currently, the "
"default UV map contains only the 4 corner vertices we had at the "
"beginning. However, we now have more, and we want to be able to texture "
"over the whole mesh correctly."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:89
msgid ""
"If all the vertices of your mesh are not selected, select them all (hit "
"\"A\"). They must appear orange, not black. Then, in the Shading/UVs "
"button group to the left, click the \"Unwrap\" button (or simply hit "
"\"U\") and select \"Smart UV Project\". Keep the default options and hit "
"\"Ok\"."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:97
msgid "Now, we need to switch our view to \"UV/Image editor\"."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:101
msgid ""
"Select all the vertices again (\"A\") then in the UV menu, select "
"\"Export UV Layout\"."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:106
msgid ""
"Export the layout as a PNG file. Name it \"plane.png\" and save it in "
"your Godot project folder. Now, let's export our mesh as an OBJ file. Top"
" of the screen, click \"File/Export/Wavefront (obj)\". Save your object "
"as \"plane.obj\" in your Godot project folder."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:112
msgid "Shader magic"
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:114
msgid "Let's now open Godot Editor."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:116
msgid ""
"Create a new project in the folder you previously created and name it "
"what you want."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:121
msgid ""
"In our default scene (3D), create a root node \"Spatial\". Next, import "
"the mesh OBJ file. Click \"Import\", choose \"3D Mesh\" and select your "
"plane.obj file, set the target path as \"/\" (or wherever you want in "
"your project folder)."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:128
msgid ""
"I like to check \"Normals\" in the import pop-up so the import will also "
"consider faces normals, which can be useful (even if we don't use them in"
" this tutorial). Your mesh is now displayed in the FileSystem in "
"\"res://\"."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:135
msgid ""
"Create a MeshInstance node. In the Inspector, load the mesh we just "
"imported. Select \"plane.msh\" and hit ok."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:140
msgid "Great! Our plane is now rendered in the 3D view."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:144
msgid ""
"It is time to add some shader stuff. In the Inspector, in the \"Material "
"Override\" line, add a \"New ShaderMaterial\". Edit it by clicking the "
"\">\" button just right to it."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:150
msgid ""
"You have two ways to create a shader: by code (MaterialShader), or using "
"a shader graph (MaterialShaderGraph). The second one is a bit more "
"visual, but we will not cover it for now. Create a \"New "
"MaterialShader\"."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:157
msgid ""
"Edit it by clicking the \">\" button just right to it. The Shaders editor"
" opens."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:162
msgid ""
"The Vertex tab is for the Vertex shader, and the Fragment tab is for the "
"Fragment shader. No need to explain what both of them do, right? If so, "
"head to the :ref:`doc_shading_language` page. Else, let's start with the "
"Fragment shader. This one is used to texture the plane using an image. "
"For this example, we will texture it with the heightmap image itself, so "
"we'll actually see mountains as brighter regions and canyons as darker "
"regions. Use this code:"
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:176
msgid ""
"This shader is very simple (it actually comes from the "
":ref:`doc_shading_language` page). What it basically does is take 2 "
"parameters that we have to provide from outside the shader (\"uniform\"):"
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:180
msgid "the texture file"
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:181
msgid ""
"a color Then, we multiply every pixel of the image given by ``tex(source,"
" UV).rgb`` by the color defined ``col`` and we set it to DIFFUSE "
"variable, which is the rendered color. Remember that the ``UV`` variable "
"is a shader variable that returns the 2D position of the pixel in the "
"texture image, according to the vertex we are currently dealing with. "
"That is the use of the UV Layout we made before. The color ``col`` is "
"actually not necessary to display the texture, but it is interesting to "
"play and see how it does, right?"
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:191
msgid ""
"However, the plane is displayed black! This is because we didn't set the "
"texture file and the color to use."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:196
msgid ""
"In the Inspector, click the \"Previous\" button to get back to the "
"ShaderMaterial. This is where you want to set the texture and the color. "
"In \"Source\", click \"Load\" and select the texture file "
"\"heightmap.png\". But the mesh is still black! This is because our "
"Fragment shader multiplies each pixel value of the texture by the ``col``"
" parameter. However, this color is currently set to black (0,0,0), and as"
" you know, 0\\*x = 0 ;) . Just change the ``col`` parameter to another "
"color to see your texture appear:"
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:207
msgid "Good. Now, the Vertex Shader."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:209
msgid ""
"The Vertex Shader is the first shader to be executed by the pipeline. It "
"deals with vertices."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:212
msgid "Click the \"Vertex\" tab to switch, and paste this code:"
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:223
msgid ""
"This shader uses two \"uniform\" parameters. The ``source`` parameter is "
"already set for the fragment shader. Thus, the same image will be used in"
" this shader as the heightmap. The ``height_range`` parameter is a "
"parameter that we will use to increase the height effect."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:228
msgid ""
"At line 3, we save the x and z position of the SRC_VERTEX, because we do "
"not want them to change : the plane must remain square. Remember that Y "
"axis corresponds to the \"altitude\", which is the only one we want to "
"change with the heightmap."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:233
msgid ""
"At line 4, we compute an ``h`` variable by multiplying the pixel value at"
" the UV position and the ``height_range``. As the heightmap is a "
"greyscale image, all r, g and b channels contain the same value. I used "
"``g``, but any of r, g and b have the same effect."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:238
msgid ""
"At line 5, we set the current vertex' position at (xz.x, h, xz.y) "
"position. Concerning xz.y remember that its type is \"vec2\". Thus, its "
"components are x and y. The y component simply contains the z position we"
" set at line 3."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:243
msgid ""
"Finally, at line 6, we multiply the vertex by the model/view matrix in "
"order to set its position according to camera position. If you try to "
"comment this line, you'll see that the mesh behaves weird as you move and"
" rotate the camera."
msgstr ""

#: ../../tutorials/mesh_generation_with_heightmap_and_shaders.rst:248
msgid ""
"That's all good, but our plane remains flat. This is because the "
"``height_range`` value is 0. Increase this value to observe the mesh "
"distort and take to form of the terrain we set before:"
msgstr ""

#: ../../tutorials/ray-casting.rst:4
msgid "Ray-casting"
msgstr ""

#: ../../tutorials/ray-casting.rst:9
msgid ""
"One of the most common tasks in game development is casting a ray (or "
"custom shaped object) and checking what it hits. This enables complex "
"behaviors, AI, etc. to take place. This tutorial will explain how to do "
"this in 2D and 3D."
msgstr ""

#: ../../tutorials/ray-casting.rst:14
msgid ""
"Godot stores all the low level game information in servers, while the "
"scene is just a frontend. As such, ray casting is generally a lower-level"
" task. For simple raycasts, node such as :ref:`RayCast <class_RayCast>` "
"and :ref:`RayCast2D <class_RayCast2D>` will work, as they will return "
"every frame what the result of a raycast is."
msgstr ""

#: ../../tutorials/ray-casting.rst:21
msgid ""
"Many times, though, ray-casting needs to be a more interactive process so"
" a way to do this by code must exist."
msgstr ""

#: ../../tutorials/ray-casting.rst:25
msgid "Space"
msgstr ""

#: ../../tutorials/ray-casting.rst:27
msgid ""
"In the physics world, Godot stores all the low level collision and "
"physics information in a *space*. The current 2d space (for 2D Physics) "
"can be obtained by calling :ref:`CanvasItem.get_world_2d().get_space() "
"<class_CanvasItem_get_world_2d>`. For 3D, it's "
":ref:`Spatial.get_world().get_space() <class_Spatial_get_world>`."
msgstr ""

#: ../../tutorials/ray-casting.rst:33
msgid ""
"The resulting space :ref:`RID <class_RID>` can be used in "
":ref:`PhysicsServer <class_PhysicsServer>` and :ref:`Physics2DServer "
"<class_Physics2DServer>` respectively for 3D and 2D."
msgstr ""

#: ../../tutorials/ray-casting.rst:38
msgid "Accessing space"
msgstr ""

#: ../../tutorials/ray-casting.rst:40
msgid ""
"Godot physics runs by default in the same thread as game logic, but may "
"be set to run on a separate thread to work more efficiently. Due to this,"
" the only time accessing space is safe is during the "
":ref:`Node._fixed_process() <class_Node__fixed_process>` callback. "
"Accessing it from outside this function may result in an error due to "
"space being *locked*."
msgstr ""

#: ../../tutorials/ray-casting.rst:47
msgid ""
"To perform queries into physics space, the "
":ref:`Physics2DDirectSpaceState <class_Physics2DDirectSpaceState>` and "
":ref:`PhysicsDirectSpaceState <class_PhysicsDirectSpaceState>` must be "
"used."
msgstr ""

#: ../../tutorials/ray-casting.rst:52
msgid "In code, for 2D spacestate, this code must be used:"
msgstr ""

#: ../../tutorials/ray-casting.rst:60
msgid "Of course, there is a simpler shortcut:"
msgstr ""

#: ../../tutorials/ray-casting.rst:67
msgid "For 3D:"
msgstr ""

#: ../../tutorials/ray-casting.rst:75
msgid "Raycast query"
msgstr ""

#: ../../tutorials/ray-casting.rst:77
msgid ""
"For performing a 2D raycast query, the method "
":ref:`Physics2DDirectSpaceState.intersect_ray() "
"<class_Physics2DDirectSpaceState_intersect_ray>` must be used, for "
"example:"
msgstr ""

#: ../../tutorials/ray-casting.rst:88
msgid ""
"Result is a dictionary. If the ray didn't hit anything, the dictionary "
"will be empty. If it did hit something it will contain collision "
"information:"
msgstr ""

#: ../../tutorials/ray-casting.rst:96
msgid "The collision result dictionary, when something hit, has this format:"
msgstr ""

#: ../../tutorials/ray-casting.rst:113
msgid "Collision exceptions"
msgstr ""

#: ../../tutorials/ray-casting.rst:115
msgid ""
"It is a very common case to attempt casting a ray from a character or "
"another game scene to try to infer properties of the world around it. The"
" problem with this is that the same character has a collider, so the ray "
"can never leave the origin (it will keep hitting it's own collider), as "
"evidenced in the following image."
msgstr ""

#: ../../tutorials/ray-casting.rst:123
msgid ""
"To avoid self-intersection, the intersect_ray() function can take an "
"optional third parameter which is an array of exceptions. This is an "
"example of how to use it from a KinematicBody2D or any other "
"collisionobject based node:"
msgstr ""

#: ../../tutorials/ray-casting.rst:136
msgid "The extra argument is a list of exceptions, can be objects or RIDs."
msgstr ""

#: ../../tutorials/ray-casting.rst:139
msgid "3D ray casting from screen"
msgstr ""

#: ../../tutorials/ray-casting.rst:141
msgid ""
"Casting a ray from screen to 3D physics space is useful for object "
"picking. There is not much of a need to do this because "
":ref:`CollisionObject <class_CollisionObject>` has an \"input_event\" "
"signal that will let you know when it was clicked, but in case there is "
"any desire to do it manually, here's how."
msgstr ""

#: ../../tutorials/ray-casting.rst:147
msgid ""
"To cast a ray from the screen, the :ref:`Camera <class_Camera>` node is "
"needed. Camera can be in two projection modes, perspective and "
"orthogonal. Because of this, both the ray origin and direction must be "
"obtained. (origin changes in orthogonal, while direction changes in "
"perspective):"
msgstr ""

#: ../../tutorials/ray-casting.rst:155
msgid "To obtain it using a camera, the following code can be used:"
msgstr ""

#: ../../tutorials/ray-casting.rst:168
msgid ""
"Of course, remember that during ``_input()``, space may be locked, so "
"save your query for ``_fixed_process()``."
msgstr ""

#: ../../tutorials/ssl_certificates.rst:4
msgid "SSL certificates"
msgstr ""

#: ../../tutorials/ssl_certificates.rst:9
msgid ""
"It is often desired to use SSL connections for communications to avoid "
"\"man in the middle\" attacks. Godot has a connection wrapper, "
":ref:`StreamPeerSSL <class_StreamPeerSSL>`, which can take a regular "
"connection and add security around it. The :ref:`HTTPClient "
"<class_HTTPClient>` class also supports HTTPS by using this same wrapper."
msgstr ""

#: ../../tutorials/ssl_certificates.rst:16
msgid ""
"For SSL to work, certificates need to be provided. A .crt file must be "
"specified in the project settings:"
msgstr ""

#: ../../tutorials/ssl_certificates.rst:21
msgid ""
"This file should contain any number of public certificates in "
"http://en.wikipedia.org/wiki/Privacy-enhanced_Electronic_Mail format."
msgstr ""

#: ../../tutorials/ssl_certificates.rst:24
msgid ""
"Of course, remember to add .crt as filter so the exporter recognizes this"
" when exporting your project."
msgstr ""

#: ../../tutorials/ssl_certificates.rst:29
msgid "There are two ways to obtain certificates:"
msgstr ""

#: ../../tutorials/ssl_certificates.rst:32
msgid "Approach 1: self signed cert"
msgstr ""

#: ../../tutorials/ssl_certificates.rst:34
msgid ""
"The first approach is the simplest, just generate a private and public "
"key pair, and put the public pair in the .crt file (again, in PEM "
"format). The private key should go to your server."
msgstr ""

#: ../../tutorials/ssl_certificates.rst:38
msgid ""
"OpenSSL has `some documentation "
"<https://www.openssl.org/docs/HOWTO/keys.txt>`__ about this. This "
"approach also **does not require domain validation** nor requires you to "
"spend a considerable amount of money in purchasing certificates from a "
"CA."
msgstr ""

#: ../../tutorials/ssl_certificates.rst:45
msgid "Approach 2: CA cert"
msgstr ""

#: ../../tutorials/ssl_certificates.rst:47
msgid ""
"The second approach consists of using a certificate authority (CA) such "
"as Verisign, Geotrust, etc. This is a more cumbersome process, but it's "
"more \"official\" and ensures your identity is clearly represented."
msgstr ""

#: ../../tutorials/ssl_certificates.rst:52
msgid ""
"Unless you are working with large companies or corporations, or need to "
"connect to someone else's servers (i.e., connecting to Google or some "
"other REST API provider via HTTPS) this method is not as useful."
msgstr ""

#: ../../tutorials/ssl_certificates.rst:56
msgid ""
"Also, when using a CA issued cert, **you must enable domain validation**,"
" to ensure the domain you are connecting to is the one intended, "
"otherwise any website can issue any certificate in the same CA and it "
"will work."
msgstr ""

#: ../../tutorials/ssl_certificates.rst:61
msgid ""
"If you are using Linux, you can use the supplied certs file, generally "
"located in:"
msgstr ""

#: ../../tutorials/ssl_certificates.rst:68
msgid ""
"This file allows HTTPS connections to virtually any website (i.e., "
"Google, Microsoft, etc.)."
msgstr ""

#: ../../tutorials/ssl_certificates.rst:71
msgid ""
"Or just pick any of the more specific certificates there if you are "
"connecting to a specific one."
msgstr ""

#: ../../tutorials/step_by_step/_step_by_step.rst:2
msgid "循序渐进"
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:4
msgid "动画(Animations)"
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:9
msgid "这篇教程将会解释Godot中一切是怎样被编成动画的。Godot的动画系统是极其的强大且灵活。"
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:11
msgid ""
"首先，我们就来使用上一篇教程的场景(:ref:`doc_splash_screen`)，目标是加入一些简单的动画。以防万一，这里还有个拷贝： "
":download:`robisplash.zip </files/robisplash.zip>`."
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:15
msgid "创建动画"
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:17
msgid ""
"首先，添加一个 :ref:`动画播放器(AnimationPlayer) "
"<class_AnimationPlayer>`节点(译注：AnimationPlayer作为节点名或类时不予翻译)到场景中作为bg(根节点)的一个子节点："
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:21
msgid "当这种类型的一个节点被选定时，动画编辑器面板(Animation Editor Panel)将会出现："
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:25
msgid "那么，是时候去创建一个新动画了！按下新建动画(New Animation)按钮，并将动画命名为\"intro\"。"
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:29
msgid "在动画被创建之后，那就该编辑它了，通过按下编辑(Edit)按钮："
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:34
msgid "编辑动画"
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:36
msgid ""
"现在就是见证奇迹的时刻(翻译组卖萌：@刘谦)！在编辑按钮被按下时，发生了一些事情，首先就是动画编辑器(Animation "
"Editor)出现在了动画面板的上方。"
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:40
msgid ""
"而第二个最重要，就是属性编辑器(Property Editor)进入了动画编辑(Animation "
"Editing)模式。在这个模式下，一个钥匙的图标出现在了属性编辑器中的每一个属性旁边。这就意味着，在Godot中，*任意对象的任意属性*都是可补间的："
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:45
msgid "让logo出现"
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:47
msgid "接下来，logo将会从屏幕顶端出现。在选定了动画播放器之后，编辑器面板将始终可见直至手动隐藏(或者动画节点被消除)。利用这一点，选择\"logo\"节点然后来到\"pos\"属性，让他动起来，运动到：114,-400。"
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:49
msgid "一到达了这个位置，就按下这个属性旁边的钥匙按钮："
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:53
msgid "由于动画轨(Animation Track)是新的，因此会出现一个询问是否创建这条轨。确定！"
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:57
msgid "然后，这个关键帧(Keyframe)就被添加到了动画编辑器中："
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:61
msgid "接着，移动编辑器的光标(Cursor)到顶端，通过点击这里："
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:65
msgid "改变logo的位置到114,0并再一次添加一个关键帧。有了两个关键帧，动画就产生了。"
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:69
msgid "按下动画面板的播放(Play)按钮将会使得logo下降出来。为了在运行场景时检验这一点，自动播放(Autoplay)按钮将会把动画标记为场景开始时就自动开始的动画："
msgstr ""

#: ../../tutorials/step_by_step/animations.rst:73
msgid "最后，当运行场景时，动画应该看起来像这样："
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:4
msgid "文件系统(File System)"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:9
msgid "文件系统是引擎开发中又一个热门的话题。文件系统管理了资源当如何储存和获取的问题。一个设计精良的文件系统也允许了多个开发者在协作开发时编辑相同的源文件和资源。"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:11
msgid "Godot引擎的早期版本(以及在被命名为Godot之前的前代版本)使用了一个数据库(Database)。资源被存在其中并被分配一个ID。其他方式也尝试过，比如本地数据库、带有元数据(Metadata)的文件等。最终还是简单的方式胜出了而且现在Godot把所有的资源作为文件存在文件系统中。"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:14
msgid "实现"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:16
msgid ""
"文件系统在磁盘上存储了资源。任何事物，上至一个脚本下至一个场景或者一个PNG图像都可以是引擎的一个资源。如果一个资源包含的属性引用着磁盘上其他资源，那么那些资源的路径也会被包含进去。如果一个资源有内置的子资源，那么这些资源会和所有捆绑的子资源一同存在一个单独的文件中。比如说，一个字体(Font)经常和一个字体贴图(Font"
" Textures)捆绑在一起。"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:18
msgid ""
"总的来说，Godot的文件系统避免使用元数据文件。原因很简单，因为有资源管理器(Asset Manager)和版本控制器(VCS,Version "
"Controlling "
"System)比我们能实现的其他东西都要好，因此Godot尽最大努力去和SVN、Git、Mercurial、Perforce等一同工作。"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:20
msgid "一个文件系统内容的例子："
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:31
msgid "engine.cfg"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:33
msgid ""
"engine.cfg文件是工程的描述文件(Project Description "
"File)，并且它总能在工程的根目录下被找到，事实上它的位置决定了根目录的位置。它是Godot在打开一个工程时首先查找的文件。"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:35
msgid ""
"这个文件以纯文本(Plain "
"Text)的形式涵盖了工程的配置(Configuration)，以一个win.ini的格式。即使是一个空的engine.cfg也能够充当一个空白工程的基本定义。"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:38
msgid "路径分隔符(Path delimiter)"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:40
msgid "Godot只支持\"/\"作为路径分隔符。这是出于可移植性的原因。所有的操作系统都支持这一点，即使是Windows，所以像\"C:\\project\\engine.cfg\"这样的路径应当改为\"C:/project/engine.cfg\"。"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:43
msgid "资源路径(Resource Path)"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:45
msgid "当尝试获取一个资源时，使用主操作系统的文件系统布局可谓是非常的笨拙而且不可移植。为了解决这个问题，一个特殊的路径\"res://\"诞生了。"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:47
msgid "路径\"res://\"将总是指向工程的根目录(engine.cfg所在的位置，因此事实上，\"res://engine.cfg\"总是有效的)。"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:49
msgid ""
"当工程局部地从编辑器运行的时候，文件系统只支持读取(Read)和写入(Write)。当被导出或者在不同的设备(比如电话或者控制台或者DVD"
"上)上运行时文件将变为只读(Read-only)的而写入不再被允许。"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:52
msgid "用户路径(User Path)"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:54
msgid "向磁盘写入通常依旧是必要的因为各种任务诸如保存游戏状态或者下载内容包等。为此，引擎确保了一个特殊的路径\"user://\"总是可写入(Writable)的。"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:57
msgid "主文件系统(Host File System,也称主机文件系统)"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:59
msgid "此外，主文件系统路径也可用，但并不推荐这样做因为对于一个被发布的产品我们无法保证在其他所有平台上都有这些路径。然而在Godot中编写开发工具的时候使用主文件系统非常有用！"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:62
msgid "缺点"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:64
msgid "这种简单的文件系统设计有一些局限性。第一个问题就是移动资源(重命名或者从一个路径移动到另一个)将会破坏这些资源的引用。这些引用必须被重新定义指向新的资源位置。"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:66
msgid "第二个就是在Windows和OSX下文件和路径名是对大小写不敏感的。如果一个工作在一个对大小写不敏感的主机文件系统的开发者保存了一个\"myfile.PNG\"但是把它当成\"myfile.png\"，这可能在他们的平台上正常运行，但在其他平台，比如Linux、Android上不一定能正常运行。这也同样适用于使用一个压缩包来存储所有文件导出的二进制文件。"
msgstr ""

#: ../../tutorials/step_by_step/filesystem.rst:68
msgid "在使用Godot时，推荐你的团队为文件清晰地定义一个命名惯例！最不济就只允许小写的文件和路径名。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:4
msgid "GUI教程"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:9
msgid ""
"如果有一个东西让程序员又爱又恨，那就是编写图形用户界面(GUI，Graphical User "
"Interface)。这很枯燥、乏味还没有挑战性。还有几个方面使得事情更糟，比如："
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:11
msgid "像素对齐的UI元素很困难(所以它看起来就像是设计师的所拟定的)。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:12
msgid "UI会因为测试期间出现的设计和实用性的问题上一直在变。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:13
msgid "要为不同的显示分辨率处理适当的屏幕缩放。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:14
msgid "为一些屏幕组件制作动画，来让它看起来不是那样的呆板。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:16
msgid ""
"GUI编写是让程序员筋疲力尽的主要原因之一。在Godot(和前代引擎)的开发期间很多为UI开发打造的技巧和理论得以实现，比如速成模式(Immediate"
" "
"Mode)、容器(Container)、锚点(Anchor)、脚本等。以减轻不得不把用户界面整合到一起的程序员的压力为主要目标，这些应时刻被做到。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:18
msgid "最终，Godot的最终UI分系统是一个解决这一问题的高效解决方案。，并且通过混合一些不同的方式来运作。虽然比别的工具套组的学习曲线更加的陡峭，但开发者能够在短时间内把复杂的用户界面编排到一起，通过和设计师和动画师共用同一套工具。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:21
msgid "控件(Control)"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:23
msgid ""
"(*译注：Control作为Godot节点和GDScript的基本类时不予翻译) UI元素的基本节点是 :ref:`Control "
"<class_Control>` "
"(有时候在其他工具套组中被称为“小部件”(Widget)或者“框”(Box))。每个提供用户界面功能的节点都是由他继承而来的。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:27
msgid "当Control被放在场景树中作为其他Control的子，它的坐标(位置、大小)都是相对于父级的。这为快速地可视地编辑复杂用户界面打下基础。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:30
msgid "输入和绘制"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:32
msgid ""
"控件以 :ref:`Control._input_event() <class_Control__input_event>` 回调 "
"接收一个输入事件。只有一个控件，在焦点中的那个，将会接收键盘/手柄事件。(见：:ref:`Control.set_focus_mode() "
"<class_Control_set_focus_mode>` 和 :ref:`Control.grab_focus() "
"<class_Control_grab_focus>`)。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:37
msgid "鼠标活动事件被在鼠标指针下方的控件直接接收。当一个控件接收到一个鼠标按钮按下事件时，所有接下来的活动事件都由被按下的控件接收直至按钮松开，即使是指针已经跑到控件边界以外了。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:39
msgid ""
"像所有继承了 :ref:`CanvasItem <class_CanvasItem>` (Control也继承)的类那样，一个 "
":ref:`CanvasItem._draw() <class_CanvasItem__draw>` "
"回调将会在最开始和每次控件需要重绘(Redraw)的时候被接收(程序员需要调用 :ref:`CanvasItem.update() "
"<class_CanvasItem_update>` "
"来入队(enqueue)供重绘的控件)。如果控件是不可见的(CanvasItem的另一种属性)，那么这个控件不接受任何的输入。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:44
msgid ""
"但总体上，程序员在搭建UI时不需要直接处理绘制和输入事件，(那对于创建自定义控件时更有用)。取而代之地，控件发射各种带有对于事件何时发生的构造信息的信号(Signals)。比如说一个按钮("
" :ref:`Button <class_Button>` )在被按下时发射了一个\"pressed\"信号，一个滚动条( "
":ref:`Slider <class_Slider>` )将会在被拖动时发射\"value_changed\"信号等。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:47
msgid "自定义控件小教程"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:49
msgid "在深入之前，创建一个自定义控件将会是一个好的方式来掌握控件工作的基本图样，因为它们也许不像看起来那样复杂。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:51
msgid "此外，尽管Godot有很多用于不同目的的控件，但通常都是通过创建一个新的会更容易获取到特定的功能。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:53
msgid "首先，创建一个单节点场景。节点类型为Control，并且在2D编辑器屏幕中有某一个区域，像这样："
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:57
msgid "为那个节点添加一个脚本，写下如下代码："
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:79
msgid "然后运行场景。当矩形被点击/触击时，它将从蓝色变为红色。这种在事件和绘制之间的配合更多的是大多数控件之间如何工作。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:86
msgid "UI复杂度"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:88
msgid "正如前文所述，Godot准备了一系列控件用于一个用户界面中。这些控件被分为两类。一个是一小部分对于创建大多数游戏用户界面都能良好运作的控件。另一种(绝大多数控件属于这个类型)是打算用于复杂的用户界面和一致包装的风格。下文所呈现的描述帮助理解了哪一个应当在什么场合下使用。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:91
msgid "简化的UI控件"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:93
msgid "这组控件对于大多数游戏是足够的，其中复杂的互动或者呈现信息的方式并不是必要的。它们能够被常规的贴图轻而易举的包装起来。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:95
msgid "标签( :ref:`Label <class_Label>`)：用于显示文本。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:96
msgid "贴图框( :ref:`TextureFrame <class_TextureFrame>`)：显示单张贴图，既可以拉伸也可以保持固定。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:97
msgid ""
"贴图按钮( :ref:`TextureButton "
"<class_TextureButton>`)：显示一个简单的带有贴图的按钮，可以设置的状态有按下(Pressed)、悬停(Hover)和禁用(Disabled)等。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:98
msgid "贴图进度条( :ref:`TextureProgress <class_TextureProgress>`)：显示一个简单的带有贴图的进度条。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:100
msgid "此外，在这种情况下重新放置控件的位置利用锚点可以更高效地完成。(详情见教程 :ref:`doc_size_and_anchors` )。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:102
msgid ""
"在任何情况下，通常会有即使是对于简单的游戏，也需要更复杂的UI行为。其中一个范例就是一个滚动的元素列表(比如对于一个高分列表)，这可能需要一个滚动容器("
" :ref:`ScrollContainer <class_ScrollContainer>`)和一个纵向容器框( "
":ref:`VBoxContainer "
"<class_VBoxContainer>`)。这种更为高级的控件可以和常规的控件天衣无缝地结合在一起(不管怎么说他们都是控件)。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:105
msgid "复杂的UI控件"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:107
msgid "其余的控件(有一大堆呢！)是为另一系列场合准备的，最通常地："
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:109
msgid ""
"需要复杂UI的游戏，比如PC RPG(Role Playing Game角色扮演)游戏、MMO(Massively Multiplayer "
"Online，大型多人在线)游戏、策略类游戏、模拟类游戏等。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:110
msgid "创建自定义的开发工具可以加速内容创作。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:111
msgid "创建Godot编辑器插件(Editor Plugins)来扩展引擎的功能。"
msgstr ""

#: ../../tutorials/step_by_step/gui_tutorial.rst:113
msgid "为这些类型的界面重新布置控件通常由容器完成(详情见教程 :ref:`doc_size_and_anchors`)。"
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:4
msgid "实例化"
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:7
msgid "基本理论"
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:9
msgid "先弄一个场景然后把节点丢进去可能对一个小工程会起作用，但随着工程的增大，越来越多的节点被使用，并且很快它们就会变得难以管理。为了解决这一问题，Godot允许一个工程被分成几个场景。然而，这样和其他游戏引擎的工作方式并不一样。事实上是差别很大，所以请不要跳过本教程！"
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:11
msgid "来回顾一下：一个场景是被组织成树形图的节点的集合，其中它们只能有唯一的节点作为树的根。"
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:15
msgid "在Godot中，一个场景可以被创建并保存在磁盘上，你可以随心所欲尽可能多的创建并保存场景。"
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:19
msgid "之后，当编辑一个存在的或者新的场景，其他场景能够被实例化为它的一部分："
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:23
msgid "在上图中，场景B被添加到场景A而成为一个实例。这起初似乎有点诡异，但是在本篇教程的结尾，这将相当的有意义！"
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:26
msgid "实例化，从一点一滴开始"
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:28
msgid ""
"要学习如何进行实例化，让我们先以下载一个范例工程开始：:download:`instancing.zip "
"</files/instancing.zip>`."
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:30
msgid "解压这个场景到你喜欢的任意一个位置。然后把这个场景用“导入”（Import）选项添加到工程管理器中："
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:34
msgid "简单地浏览一下工程位置的内部然后打开engine.cfg文件。这个新的工程将会出现在工程列表中。通过使用“编辑”（Edit）选项来编辑工程。"
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:36
msgid "这个工程包含两个场景“ball.scn”和\"container.scn\"。这个ball场景只是一个带有物理性质的球，而container场景则是有一个塑形精良的碰撞形体，以备球能够被扔进这里。"
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:42
msgid "打开container场景，然后选择根节点："
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:46
msgid "之后，按下“+”形状的按钮，这是实例化按钮（Instancing Button）！"
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:50
msgid "选择场景ball（ball.scn），这个球应当出现在原点（Origin）(0,0)处，把他移到场景中心附近，像这样："
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:54
msgid "按下运行，然后瞧！"
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:58
msgid "这个被实例化的球跌入了坑的底部。"
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:61
msgid "更多内容"
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:63
msgid ""
"在场境内可以根据需求有尽可能多的实例，那就尝试实例化更多的球，或者复制（Duplicate）它们（Ctrl+D或者复制按钮（Duplicate "
"Button））："
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:67
msgid "然后尝试再次运行场景："
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:71
msgid "很酷，是不是？这就是实例化的工作方式。"
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:74
msgid "编辑实例"
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:76
msgid ""
"选择众多球的拷贝当中的一个然后来到属性编辑器（Property "
"Editor）。我们来让它更具有弹性，那就来找到弹性（Bounce）参数然后把他设成1.0："
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:80
msgid "接下来会发生的就是一个绿色的“复原”（Revert）按钮出现了。当这个按钮出现的时候，这就意味着我们从被实例化的场景中修改了一个属性（Property）来让这个值替换掉原来的在实例中的值。即使是属性值在源场景中被修改，自定义的值也总能覆盖它。按下复原按钮将会把属性恢复到来自于场景的原始值。"
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:83
msgid "总结"
msgstr ""

#: ../../tutorials/step_by_step/instancing.rst:85
msgid "实例化似乎很便利，但是比起眼前的这些，它还有更多的内容。实例化教程的下一部分就会包含剩下的东西……"
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:4
msgid "实例化(续)"
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:7
msgid "回顾"
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:9
msgid "实例化有很多便捷的用途。大致扫一眼，用实例化你会有："
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:11
msgid "细分场景并使其更简单去管理的能力。"
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:12
msgid "预设（Prefab）的一个更灵活的替代品（并且在很多水平上，给定的实例工作起来更强大）。"
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:13
msgid "一种方式来设计更复杂的游戏流程或者甚至是UI（用户界面）（UI元素在Godot中也是节点）。"
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:16
msgid "设计语言"
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:18
msgid "但是实例化场景的真正重点是它作为一个优秀的设计语言来工作。这也是使得Godot特别并且不同于其他游戏引擎的相当主要的东西。整个引擎从基本往上都是围绕这个概念设计的。"
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:20
msgid "当使用Godot制作游戏时，推荐的方法是把其他的设计风格例如MVC（模型-视图-控制器模式）或者实体关系图（E-R图）抛开，并且开始以一种自然的方式思考游戏。开始想象游戏中的所有可视元素，那些能够不止被一个程序员，而是能被任何人命名的东西。"
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:22
msgid "比如说，有一个简单的射击游戏可以被想象："
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:26
msgid "对于几乎任意类型的游戏来说想到一个像这样的图标是相当简单的。只需要写下脑海中的元素，然后还有表达它们所属关系的箭头。"
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:28
msgid "一旦这个图表形成了，制作一个游戏大概就是为每个节点创建一个场景然后使用实例（或者是通过代码，或者通过编辑器）来代表所属关系。"
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:30
msgid "编写一个游戏（或者是通用的软件）的绝大部分时间被花费在设计一个结构以及把游戏组件适配到那个结构当中。基于场景的设计替代了那件事并且使得开发更加的快也更加的直接,允许关注游戏的自身。基于场景/实例化的设计非常高效，在于节省了大量的工作，因为大部分被设计的组件一一映射到一个场景。这样，就很少或不再需要的结构代码。"
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:32
msgid "下面是一个更加复杂的实例，一个开放世界类型的游戏会有很多互动的资源和组件："
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:36
msgid "制作一些带有家具的房间，然后把他们连接起来。然后做一个房子，并用这些房间作为内容物。"
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:38
msgid "房子可以是一个城堡，有很多的房子。最终这个营垒可以被放倒世界地图地形上，再把守卫和其他的NPC（非玩家角色）添加到城堡通过在这之前创建他们的场景。"
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:40
msgid "使用Godot，游戏可以如需求般快速的成长，因为只需要做更多的场景并将其实例化。编辑器UI也被设计得让非程序员来使用，所以一个平常的团队开发进程会包含3D或2D美工、关卡设计师、游戏设计师、动画师等都能够用这个编辑器界面工作。"
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:43
msgid "信息过载！"
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:45
msgid "别太担心，这篇教程的重要部分是去建立一种关于场景和实例化在现实生活中是如何被使用的意识。做一些游戏是理解这一切的最佳方略。"
msgstr ""

#: ../../tutorials/step_by_step/instancing_continued.rst:47
msgid "当涉足实践，一切都将变得清晰，所以，请不要抓心挠肝焦头烂额，然后继续下一篇教程！"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:4
msgid "资源(Resource)"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:7
msgid "节点和资源"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:9
msgid ""
"到目前为止， :ref:`Node <class_Node>` "
"已经成为了Godot中最重要的数据类型（Datatype），因为引擎的绝大多数行为和特性都是通过他们实现的。尽管如此，还有另外一种数据类型也是同样地重要，那就是"
" :ref:`Resource <class_Resource>`."
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:13
msgid "节点关注在行为上，比如绘制一个精灵、绘制一个3D模型、物理、GUI控制等，"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:15
msgid "**资源** 仅仅是 **数据容器(Data Container)**，这意味着他们既没有任何动作也不生成任何信息。资源仅仅包含着数据而已。"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:17
msgid ""
"资源的样本有： :ref:`Texture <class_Texture>`, :ref:`Script <class_Script>`, "
":ref:`Mesh <class_Mesh>`, :ref:`Animation <class_Animation>`, "
":ref:`Sample <class_Sample>`, :ref:`AudioStream <class_AudioStream>`, "
":ref:`Font <class_Font>`, :ref:`Translation <class_Translation>`, 等等。"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:28
msgid ""
"当Godot（从硬盘）保存或载入一个场景（.scn或者.xml）、一个图片（png，jpg "
"）、一个脚本（.gd）或者其他什么类似的东西，那个文件就被称为一个资源。"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:31
msgid "当一个资源被从磁盘里载入时，**它永远只被载入一次**。那也就意味着，如果在内存中已经有一份该资源被载入了，尝试再次载入该资源将只返回相同的那份资源。这与资源只是数据容器这一事实相对应，因此没必要去让他们存在多个副本。"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:33
msgid ""
"通常地，Godot中每一个对象（节点、资源或者别的东西）都能够导出属性（Properties），属性可以是许多种类型（例如一个字符串（String）、整数（Integers）、2D向量（Vector2）等）并且这些类型中每一个都能成为一个资源。这意味着节点和资源都可以包含资源作为属性。"
" 为了使它更加的直观一点："
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:39
msgid "外部与内置"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:41
msgid "资源属性可以以两种方式引用资源，*外部*（磁盘）或**内置**。"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:43
msgid ""
"为了更具体一些，在一个 :ref:`Sprite <class_Sprite>` 节点中有一个 :ref:`Texture "
"<class_Texture>`："
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:47
msgid "按下预览右侧的\">\"按钮将允许查看并编辑资源属性。其中有一个属性（即path属性）显示了它来自于哪里。在这个案例中，它来自于一个png图片。"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:51
msgid ""
"当资源来自于一个文件时，它被认为是一个*外部*的资源。如果这个 "
"path（路径）属性被擦除了（或者开始就没有一个路径），那么他就被认为是一个内置的资源。"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:53
msgid "比如说，如果路径\\`\"res://robi.png\"\\`从上述范例中\"path\"属性被抹消，那么接下来当这个场景被保存，资源就会被存到.scn场景文件里，不再引用外部的\"robi.png\"。然而，即使被存为内置资源，尽管这个场景可以被实例化多次，资源将仍然只载入一次。那意味着，同时被实例化的不同的Robi机器人场景将分享相同的图片。"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:56
msgid "使用代码载入资源"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:58
msgid "使用代码载入资源非常简单，有两种方式都能够完成此事。第一种是使用 load() 函数，就像这样："
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:66
msgid "第二种方式要更理想，但是参数必须是一个字符串常量才能工作，因为它将在编译时载入资源。"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:75
msgid "加载场景"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:77
msgid ""
"场景同样也是资源，但有点特别。场景会以 :ref:`PackedScene <class_PackedScene>` "
"这种资源类型保存到硬盘。这意味着场景会被打包进一份资源之内。"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:79
msgid ""
"如果想要获得场景的实例(instance)，必须使用这个方法：:ref:`PackedScene.instance() "
"<class_PackedScene_instance>`"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:87
msgid "这个方法能创建场景树每一层的节点，初始化它们(包括设定所有属性)同时返回 场景的根节点。根节点能被添加为其他任意节点的子节点。"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:90
msgid ""
"下面这个方法有若干优点：:ref:`PackedScene.instance() <class_PackedScene_instance>` "
"函数执行地非常快，能够高效的往场景里添加额外内容(extra "
"content)。新的敌人、子弹、特效等等能够被快速添加或移除，而不需要每次都从硬盘上读取。记住这点，这非常重要：同样的，图片、网格(meshes)以及其他全部都是在场景实例间共享的。"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:94
msgid "释放资源"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:96
msgid ""
"资源类(Resource)都继承自 :ref:`Reference <class_Reference>` "
"。因此，当一个资源不再使用的时候，他将自动被释放。因为在大多数情况下资源被包含在节点、脚本或者其他资源中，当一个节点被移除或者释放时，作为其子节点的资源也跟着被释放了。"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:99
#: ../../tutorials/step_by_step/scripting.rst:4
#: ../../tutorials/step_by_step/simple_2d_game.rst:54
msgid "脚本"
msgstr ""

#: ../../tutorials/step_by_step/resources.rst:101
msgid "如同 Godot 中的其他对象（而不仅仅是Nodes）一般，资源也是可以附加脚本的。 但这通常没什么卵用，因为资源只是数据容器罢了。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:4
msgid "场景树(Scene Tree)"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:8
msgid "(译注：SceneTree作为类名时不予翻译) 从这里开始事情开始越来越抽象，但是别担心，因为深奥的东西也不过如此了。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:11
msgid "在上篇教程中，所有东西都围绕着节点(Node)的概念，场景(Scene)由它们构成，并且它们一旦进入了\"场景树\"中它们就开始变得活跃了。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:13
msgid "这应该更深入一些。事实上，场景系统甚至都不是Godot中的核心部分，因为它是可以被跳过然后做个脚本(或者C++代码)直接访问伺服器(Server,本篇的Server只指代伺服器，而不指代网络上的服务器，网络服务器会在联网等相关章节中具体标注)。但是那样制作游戏将会有很大工作量并且也是为其他用途预留的。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:16
msgid "主循环(MainLoop类)"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:18
msgid ""
"Godot内部工作原理如下。有一个 :ref:`OS <class_OS>` "
"类(Class)，是唯一一个在最开始就运行的实例。之后所有的驱动器、伺服器、脚本语言、场景系统等都被载入了。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:20
msgid ""
"当初始化完成后 :ref:`OS <class_OS>` 需要被提供一个 :ref:`MainLoop <class_MainLoop>` "
"来运行。截止到此，所有的这些是在内部完成的(如果你对内部工作原理感兴趣的话，你可以检验源代码中的main/main.cpp文件)"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:22
msgid ""
"用户系统，或者游戏，在MainLoop中开始。这个类有一些方法(Method)，用于初始化(Initialization)、闲置(Idle"
")(帧同步回调,freame-synchronized "
"callback)、以及输入(Input)。同样地，这很低级而且在Godot中制作游戏时，写你自己的MainLoop根本没什么意义。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:25
#: ../../tutorials/step_by_step/scene_tree.rst:62
msgid "场景树"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:27
msgid "解释Godot如何工作的方式之一，那就是它是一个在一个低级中间件基础上的高级游戏引擎。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:29
msgid ""
"场景系统就是游戏引擎，而 :ref:`OS <class_OS>`和伺服器就是低级应用程序接口(API,Application Plugin "
"Interface)。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:31
msgid "无论何时，场景系统为OS、 :ref:`SceneTree <class_SceneTree>` 提供了自己的主循环。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:33
msgid "在运行一个场景时，这是被自动实例化并设定的，无需再做额外的事情。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:35
msgid "知道一个类的存在是很重要的因为它有如下重要的用处："
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:37
msgid ""
"它包含了根 :ref:`Viewport <class_Viewport>`，当一个场景第一次被打开时，它被添加为它的一个子并成为了 *场景树* "
"的一部分。(具体内容在后文)"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:38
msgid "它包含了关于组(Group)的信息，并且能够调用组内的所有节点，或者获取到它们的列表。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:39
msgid "它还包含一些全局级别的功能，比如设定暂停模式或者退出进程等。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:41
msgid ""
"当一个节点是场景树的一部分时， :ref:`SceneTree <class_SceneTree>` 单例类能够通过只调用 "
":ref:`Node.get_tree() <class_Node_get_tree>`来被获取到。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:47
msgid "根视区(Root Viewport)"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:49
msgid "根:ref:`视区(Viewport) <class_Viewport>` 总是在场景的最顶端，通过一个节点它能够以两种不同的方式被获取到。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:57
msgid ""
"这个节点包含了主要视区，所有作为:ref:`Viewport "
"<class_Viewport>`子的东西默认被绘制在它里面，所以所有节点的顶端总是这个类型是有很重要的，否则什么也看不见！"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:59
msgid "比较于其他的视区能够被创建在场景中(用来做分屏效果和此类的东西)，这个根视区是永远不会被用户所创建的。它在场景树中被自动创建。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:64
msgid "当一个节点被直接地或间接地连接到根视区时，它就成为 *场景树* 的一部分。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:66
msgid "这也就意味着，正如在之前教程中所诠释的那样，将会得到_enter_tree()和_ready()的回调(还有_exit_tree())。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:70
msgid ""
"当节点进入 *场景树* "
"中时，他们变得活跃了。他们开始获取他们需要处理的一切事物，获取输入、2D和3D显示、通告(Notification)、播放音乐、组等。当他们从*场景树*中被移除时，他们将失去它。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:73
msgid "场景树顺序"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:75
msgid "在Godot中大多数节点操作，比如2D绘制(Drawing)、处理(Processing)或者获取通告都以场景树完成的。这也就是说低阶的父级和姊妹级将会在当前节点之前被通告(Notificated)。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:80
msgid "通过进入 *场景树* 来活跃化"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:82
msgid "一个场景通过撰写代码来创建或从磁盘导入。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:83
msgid "这个场景的根节点(只有一个，还记得么？)被添加作为一个根视区(来自于场景树)的子级或者是被添加到它别的子级以及隔代子级。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:84
msgid "新添加的场景中每一个节点都会自上而下接收\"enter_tree\"通告(在GDScript中的 _enter_tree() 回调)。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:85
msgid "又一个通告\"ready\"(GDScript中的 _ready() 回调)为方便起见被提供，这时一个节点和它的所有子节点都进入了这个活动场景中。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:86
msgid ""
"当一个场景(或者它的一部分)被移除时，它们将会自下而上地接收到\"exit scene\"通告(GDScript中的 _exit_tree() "
"回调)。"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:89
msgid "改变当前场景"
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:91
msgid ""
"一个场景被载入以后，我们通常都要把一个场景改变为另一个。简单的方法就是使用 :ref:`SceneTree.change_scene() "
"<class_SceneTree_change_scene>` 函数："
msgstr ""

#: ../../tutorials/step_by_step/scene_tree.rst:100
msgid ""
"这是切换场景的一个快速有效的方式，但是有一个缺点：在新场景被载入并运行之前，游戏将被搁置挂起。在你游戏中的一些情况下，我们可能想要创建带有进度条的合适的载入画面、动态指示物或者线程(背景)载入。这必须通过使用AutoLoad(自动载入)和"
" :ref:`doc_background_loading` 来手动地实现。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:4
msgid "场景与节点"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:11
msgid "试想一秒钟你不再是一个游戏开发者。取而代之地，你是一个大厨！把你时髦的衣服换成一个无檐帽和一个双排扣夹克。现在，你是在为你的宾客打造一个美味的菜肴而不是在做游戏。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:13
msgid "所以，一个伙夫如何打造一个菜品呢？菜谱被分为两部分，第一个是成分，第二个是关于准备它的说明。以这种方式，任何人都能够遵照菜谱并调制出你的绝佳创意。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:15
msgid "在Godot中制作游戏和这种方式非常相同。使用这个引擎感觉就像是在厨房里。在这个厨房里，“节点（Nodes）”就是装满了用于烹饪的新鲜材料的冰箱。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:17
msgid "有很多种类型的节点，有的显示图像、有的播放声音、有的节点显示3D模型等等。有很多。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:20
msgid "节点（Nodes）"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:22
msgid "但先让我们来走基础。一个节点是创建一个游戏的基本元素，它具有一下性质："
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:24
msgid "有名字（Name）"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:25
msgid "具有可编辑的属性（Editable Properties）。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:26
msgid "每帧（Frame）都能接收对进程的回调（Callback）。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:27
msgid "能够被扩展（Extended）（来具有更多的功能（Functions））。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:28
msgid "能够加入其他的节点作为子（Child）。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:32
msgid "最后一个很重要。节点能够使其他节点作为子类。当以这种方式编排的时候，节点会变成一个“树”。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:34
msgid "在Godot中，以这种方式来编排节点的能力为组织整理工程创造了一个强有力的工具。因为不同的节点有不同的功能，将他们结合起来则允许了创建更多复杂的功能。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:36
msgid "这可能还不甚清晰并且几乎没什么意义。但是过了几节后一切都将大白。目前要记住最重要的一点是有节点这个东西存在，并且能够按这种方式来编排。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:39
msgid "场景（Scene）"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:43
msgid "既然节点的存在已经被定义了，下一个逻辑步骤就是解释什么是场景了。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:45
msgid "一个场景由一组（以树形图的方式）被分层组织的节点组成，它具有以下属性："
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:47
msgid "一个场景有且只能有一个根节点（Root Node）。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:48
msgid "场景能够被保存到磁盘上，也能被载入回来。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:49
msgid "场景能够被“实例化”（Instanced）（后文说明原因）。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:50
msgid "运行一个游戏意味着运行一个场景。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:51
msgid "一个工程中可以有几个场景，但是要开始，它们中的一个必须被选定来首先载入。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:53
msgid ""
"基本上，Godot编辑器就是一个“场景编辑器”（Scene Editor）。它有很多工具来编辑2D和3D场景以及用户界面（UI，User "
"Interface），但是编辑器的所有内容都是围绕着编辑构成它的场景和节点的概念展开的。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:56
msgid "创建一个新工程（Project）"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:58
msgid "理论是枯燥的，所以我们来转换话题走向实际。按照教程类文章的长期传统，第一个工程将会是一个Hello World。为了这件事，编辑器将会被使用。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:60
msgid "当Godot可执行程序脱离一个工程运行，工程管理器（Project Manager）就出现了，它帮助开发者管理他们的工程。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:64
msgid "要创建一个新工程，“新建工程”（New Project）选项肯定被使用。给选择并创建一个路径（Path）然后指定工程的名字（Name）："
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:69
msgid "编辑器（Editor）"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:71
msgid "一旦这个“新工程”被创建，下一步就是打开它。这将会打开Godot编辑器。下图展示了刚打开编辑器时它的样子："
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:75
msgid ""
"如前文所述，在Godot中制作游戏就像是在厨房里一样，所以我们来打开冰箱然后加入一些新鲜的节点到工程中。我们将会以一个Hello "
"World!开始。为了做到这一点，肯定要按下“新建节点”（New Node）按钮："
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:79
msgid "这将会打开创建节点（Create Node）对话框，展示了一长串能够被创建的节点列表："
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:83
msgid "从这里，先选择“标签”（Label）节点。直接搜索它可能是最快捷的方式："
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:87
msgid "并且最终，我们创建了一个标签（Label）！当创建被按下时，很多事情就发生了："
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:91
msgid "首先，场景变成了一个2D编辑器（因为Label是一个2D节点类型），并且当Label出现时，选定，在视图（Viewport）的左上角。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:93
msgid ""
"这个节点出现在了场景树编辑器（Scene Tree "
"Editor）（左上方的一栏里），而且标签的属性（Property）出现在了检查工具（Inspector）中（右侧的一栏）。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:95
msgid "下一步就是去改变标签的“文本”（Text）属性了，我们来把它改成“Hello,World!”："
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:99
msgid "好了，一切都已就绪来运行场景了！在顶栏按下“运行场景”（Play Scene）按钮（或敲击F6）："
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:103
msgid "然……然后，噢天哪！"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:107
msgid "场景需要被保存才能运行，所以在场景→保存（Scene->Save）菜单中把场景保存成hello.scn："
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:111
msgid ""
"然后，有趣的事情发生了。这个文件对话框是一个特别的文件对话框，只允许在工程内保存。工程根目录是“res://”，意味着“资源路径”（Resource"
" "
"Path）。这也就意味着，文件只可以被保存到工程的内部。日后，当进行文件操作的时候记住，“res://”就是资源的路径，并且无论平台和安装位置，它都是游戏中的资源文件所在的一种定位方式。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:113
msgid "在保存场景并再一次按下运行场景之后，“Hello, World!”演示应该被执行："
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:117
msgid "成功了！"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:122
msgid "配置（Configuring）工程"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:124
msgid ""
"好了，是时候去给工程做点配置（Configuration）了。就是现在，唯一运行某些东西的方式就是执行当前的场景。然而，工程有多个场景，因此其中一个必须被设定为主场景（Main"
" Scene）。这个场景是将会在工程运行时被载入的场景。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:126
msgid ""
"这些设定将全部被存在engine.cfg文件中，一个win.ini格式的普通文本文件，以便编辑。有一些设定可以在这个文件中被设定，来更改工程的执行方式，所以为了让情况更简单，工程设定（Project"
" Setting）对话框，一种编辑engine.cfg的前端，诞生了。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:128
msgid "为了通向这个对话框，只需要走场景→工程设定（Scene -> Project Settings）。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:130
msgid "一旦这个窗口打开了，任务就是选一个主场景。这可以很轻易的完成通过改变应用/主场景属性（Application/main_scene）然后选择\"hello.scn\"。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:134
msgid "伴随这个改变，按下常规运行（Play）按钮（或者F5）将会运行这个工程，无论场景是否正在被编辑。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:136
msgid "回到场景设定对话框，这个对话框提供了许多能够被加到engine.cfg的选项并且显示出了他们的默认值，如果默认值就可以，那就无需改变它。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:138
msgid "当一个值改变时，一个对勾被标记在名字的左侧。这意味着这个属性将被保存到engine.cfg文件中并且会被记住。"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:140
msgid ""
"附注，对于后文的引用以及超出上文的内容（毕竟这是第一篇教程啊喂！），添加自定义的配置属性又使用:ref:`全局（Globals） "
"<class_Globals>` 实例来在运行期间读取它们是可行的."
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:143
msgid "未完待续……"
msgstr ""

#: ../../tutorials/step_by_step/scenes_and_nodes.rst:145
msgid "这篇教程谈论了“场景和节点”，但是目前为止，还只有一个场景和一个节点！别担心，下一篇教程将会解决这个问题……"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:9
msgid "正如我们之前所说的那样，我们希望游戏开发工具可以不需要编程就可以创作电子游戏。然而，目前不需要学习编码就能开发游戏这仍然是不太现实的，这种无编程的游戏设计流程还有很长的路要走。因为在很多情况下我们需要使用程序来控制游戏中的各种逻辑和整个游戏的流程不是么？"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:11
msgid "许多引擎和开发工具宣称不需要编程就能够设计作品，但这些工具往往半途而废或者过于复杂。因此，编程在游戏开发这项工作中仍然存在，并将在很长一段时间内难以被取代。事实上，现在都游戏引擎都朝着提供各种实用的工具来尽量减少开发过程中的代码量，以此解放开发者来提高游戏开发效率。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:13
msgid "同样，Godot也是朝着这个方向来设计的，其中最明显也是最重要的便是它的场景系统。它的用途可能不那么直观，但是一旦你掌握它之后，将长期从中收益。它能够将程序员从无限的架构游戏场景的编码工作中解放出来。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:15
msgid "使用场景系统设计游戏时，整个游戏项目被分为若干个相互补充的场景（并非独立的场景）。这些场景是相互补充而不是彼此分离的，后面的教程将会有大量的例子来介绍这个场景系统。现在，请记住这一点，因为它是很重要的概念。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:17
msgid ""
"对于那些有丰富经验的老码农来说，这意味着现在的场景系统与你所熟知的MVC设计模式有很大的区别。现在我们需要你暂时将你的这些习惯扔掉，来尝试一下*场景补充*设计模式（Scenes"
" As a "
"Complement，没有一个确定的官翻，目前先译做场景补充吧）。Godot向你保证，这种设计模式的效用是值得让你在游戏设计中丢弃MVC的。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:20
msgid ""
"Godot的脚本支持继承(`extend "
"<http://c2.com/cgi/wiki?EmbedVsExtend>`__)，允许脚本继承自所有引擎中可以使用的类。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:23
msgid "GDScript"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:25
msgid ":ref:`doc_gdscript` 是一门专门为Godot引擎设计的动态数据类型的脚本语言。它坚持以下设计原则："
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:27
msgid "首要任务是尽可能简单、易于学习。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:29
msgid "让脚本代码容易理解，并且安全、容错高。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:31
msgid "语法在很大程度上借鉴自Python。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:33
msgid "一般程序员只需花几天时间来学习它，两周左右即可得心应手地使用它进行游戏编程。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:35
msgid "正如大多数动态类型的语言一样，产能高的脚本（容易学习、编写快速、没有完整类型这类语言）的执行效率都在一定程度上有所折扣。GDScript中的绝大多数核心代码（诸如向量、物理库、数学库等等）都是使用C++编写的，这使得Godot的脚本执行效率远高于其他游戏引擎的脚本。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:37
msgid "任何情况下，对于对性能要求较高的程序，都可将性能影响较高的核心部分使用C++来写，然后在导出给脚本使用。Godot允许你不必变更已经设计好的游戏就能使用C++来替换任何一个GDScript类来提升游戏性能。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:40
msgid "为场景编写脚本"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:42
msgid "在你继续下面的内容之前，请确认你已经看过:ref:`doc_gdscript`这篇文档。GDScript是一门简单的脚本语言，因此这篇文档并不长，你应该花几分钟过一遍。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:45
msgid "建立场景"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:47
msgid "这段教程将带你为一个简单的GUI场景编写脚本。使用添加节点对话框来创建如下节点层次："
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:49
msgid "Panel"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:51
msgid "Label"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:52
msgid "Button"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:54
msgid "你的节点树窗口看起来应该像这样子"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:58
msgid "在2D编辑器中尝试将这个场景调整成类似下面这样："
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:62
msgid "最后，保存场景，将其保存在名为“sayhello.tscn”的文件中。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:65
msgid "添加脚本"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:67
msgid "鼠标右键点击Panl节点，选中“Add Script”选项"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:71
msgid "创建脚本的对话框将会弹出。这个对话框允许你选择脚本语言、类名等。GDScript并不在脚本文件中定义类名，因此类名是无法编辑的。如下图所示，脚本继承自Panel类（Panel继承自Node，这个输入框一般是自动帮你填好的）。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:75
msgid "现在选择保存脚本的文件名（如果你之前保存过场景，那么将会填充生产与场景文件相同的文件名，这里应该是sayhello.gd）然后按下“Create”按钮。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:77
msgid "这样我们就创建了一个脚本，并将其添加到了Panel节点上。你可以通过点击节点上的脚本图标或者通过Inspector窗口中的\"script\"属性来查看这个脚本。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:81
msgid "要编辑脚本，只需要按照上面的操作即可打开脚本编辑窗口。下图是创建脚本的对话框自动为我们填写的脚本内容："
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:85
msgid "这儿并没有太多内容。“_ready()”函数将会在Panel节点（以及其所有子孙节点）添加到场景后被调用。（请记住，这个函数并不是该类的构造函数，构造函数是\"_init()\"）。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:88
msgid "脚本编写规则"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:90
msgid "一般脚本用于为节点添加一些基本的控制操作，这些控制或操作往往是针对该节点或者是其他节点（可能是其子孙节点、父节点、兄弟节点等）。同其他语言的继承机制一样，脚本的作用域是在它所属的节点，同时脚本能够重写其父类的虚函数。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:95
msgid "处理信号（Signal）"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:97
msgid ""
"信号（Signal）在GUI节点中被大量使用（其他节点同样能使用，请参考GDScript文档）。信号在发生特定事件时被触发（emit），能够被绑定（connect）到任何脚本的任何函数上。在这里，我们将Panel节点下按钮Button节点的“pressed”信号连接到一个函数。右键点击Button节点，选择“Edit"
" Connections”弹出信号绑定对话框："
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:101
msgid "这个对话框中列出了所有Button类能够触发的信号。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:105
msgid "但在这里我们并不使用它，你知道这里能够绑定信号和脚本中的函数就可以了。我们不想搞得太过简单，因此关闭对话框，我带你装逼！"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:107
msgid "为了更高的逼格，哦不，是为了让代码看上去更有条理，让别人阅读我们的脚本时能够清楚“pressed”信号触发时我们干了什么事，我们需要用脚本来绑定这个信号。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:109
msgid ""
"这里我们需要用到Godot中最常用的:ref:`Node.get_node() "
"<class_Node_get_node>`函数，这个函数通过节点路径来获取与这个脚本被绑定到的节点相关的其他节点(有点绕口，请在读一遍)。要获取到Button节点，我们这样用它："
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:115
msgid "然后我们添加一个回调函数来处理按钮被按下时触发的\"pressed\"信号，在按下时修改Label节点的文本。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:122
msgid ""
"最后在_ready()函数中使用 :ref:`Object.connect() <class_Object_connect>` "
"函数将Button节点的“pressed”信号绑定到这个回调函数上。"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:129
msgid "最终，这个脚本的内容将是这样子的："
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:146
msgid "执行这个场景，如果没有出错的话，你将得到预期的效果，是不是很棒啊！"
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:150
msgid "**注意**：本节中常见的错误是很多同学可能没有按照教程中的节点次序创建Button节点，把Button节点放到了Label下面。这是因为在创建Button时你选中的是Label对象造成的。这会导致在脚本中通过get_node(\"Button\")获取不到Button这个对象，因为它并不是我们的脚本绑定的Panel的子对象（他是个孙子～）。因此，我们需要下面的方式获取到这个孙子："
msgstr ""

#: ../../tutorials/step_by_step/scripting.rst:158
msgid "最后，再啰嗦一句，记住我们是通过名称获取节点的，而不是通过节点的类型，尽管这里节点的名称就是它们的类型名。"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:4
msgid "脚本(续)"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:7
msgid "处理"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:9
msgid ""
"在Godot中一些动作由回调函数或虚函数触发，所以没必要去检查持续执行的代码。不仅如此，很多都能够用动画播放器（Animation "
"Player）来完成。"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:11
msgid ""
"然而，有一个脚本在每一帧进行处理依旧是一个常见情况。有两种处理方式，空闲处理（Idle Processing）和固定处理（Fixed "
"Processing）。"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:13
msgid ""
"空闲处理由 :ref:`Node.set_process() <class_Node_set_process>` 函数激活。一旦激活， "
":ref:`Node._process() <class_Node__process>` 回调将会在每一帧被调用。举个例子"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:25
msgid "参数delta描述了从上一次回调_process()到现在的持续时间（以秒为单位，为浮点数）。固定处理也是相似的，但只在和物理引擎同步的时候才会用到。"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:27
msgid "验证这件事的一个简单方式就是去创建一个包含一个带有如下脚本的标签节点的场景："
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:42
msgid "这将会显示一个每秒递增的计数器。"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:45
msgid "组（Groups）"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:47
msgid ""
"节点可以被添加到组里（每个节点根据需要可以尽可能多的添加）。这对于组织大型场景是一个简单的但是很有用的特性。有两种方式能够做到这点，第一个就是通过UI，在Groups按钮（Groups"
" button）中："
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:51
msgid "而另一种就是通过代码。比如，下面就一个很有用的范例来标记作为敌人的场景。"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:58
msgid ""
"以这种方式，如果在秘密基地里乱跑的玩家被发现了，通过使用 :ref:`SceneTree.call_group() "
"<class_SceneTree_call_group>`: ，所有的敌人都能够注意到警报的响起，"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:67
msgid "上述代码将会调用在组\"guards\"里面所有成员上的函数\"player_was_discovered\"。"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:69
msgid ""
"可选地，你也可以获取到\"guards\"节点的完整列表，通过调用 :ref:`SceneTree.get_nodes_in_group() "
"<class_SceneTree_get_nodes_in_group>`:"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:76
msgid "更多关于 :ref:`SceneTree <class_SceneTree>` 的内容将会在后面加入"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:81
msgid "通告（Notifications）"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:83
msgid ""
"Godot还有一个通告系统，这通常不需要从脚本中调用，因为他们太低层了并且虚函数能够提供他们中的绝大部分。你只消知道他们存在就可以了。在你的脚本中单纯添加一个"
" :ref:`Object._notification() <class_Object__notification>` 函数："
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:96
msgid ""
"在 :ref:`Class Reference <toc-class-ref>` 中 "
"关于每个类（Class）的文档显示了他能接收到的通告。然而，还是，对于大多数的情形下，脚本提供了更简单的可重载函数。"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:100
msgid "可重载函数（Overrideable Functions）"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:102
msgid ""
"正如前文所述，最好去使用这些函数。节点提供了许多有用的可重载函数，其被如下描述： As mentioned before, it's better"
" to use these functions. Nodes provide many useful overrideable "
"functions, which are described as follows:"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:162
msgid "创建节点"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:164
msgid ""
"为了通过代码来创建一个节点，只需要调用.new()方法即可，（就像其余的基于类的数据类型），比如说： To create a node from "
"code, just call the .new() method, (like for any other class based "
"datatype). Example:"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:175
msgid "欲删除一个节点，无论在场景内外，free()都必须被使用："
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:182
msgid ""
"当节点被释放（Free）后，它也将释放所有的子节点。由于这一点，手动删除节点比让它出现是更简单的。只需要释放基节点（Base "
"Node）继而在分支树下的所有东西都将随之消失。"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:184
msgid "然而，这可能是一种普遍情况，我们可能想要去删除一个当前被“封锁”的节点，就是这个节点正在发射信号（Signals）或者在调用一个函数。这就会导致游戏崩溃。在调试器（Debugger）中运行Godot通常会捕获（Catch）这个情况并且警告你。"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:186
msgid ""
"删除节点的最安全的方式就是去使用 :ref:`Node.queue_free() <class_Node_queue_free>` "
"作为替代。这会在闲置时安全地擦除这个节点。"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:196
msgid "场景的实例化"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:198
msgid "通过代码来实例化一个场景是相当简单的并且在两步内就能完成。第一步就是从磁盘载入场景。"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:204
msgid "有时预加载会更方便，因为它发生在语义解析（Parse）期间。"
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:210
msgid ""
"但是 'scene' 依旧不是一个包含着子节点的节点。它被封装在一个特殊的资源叫做 :ref:`封装场景 <class_PackedScene>`"
" 。 为了创建实际的节点，函数 :ref:`PackedScene.instance() "
"<class_PackedScene_instance>` 必须被调用。这将会返回可以添加到活动场景中的节点树："
msgstr ""

#: ../../tutorials/step_by_step/scripting_continued.rst:220
msgid "这两步处理的优势在于一个封装的场景可能会持续地加载并准备就绪，所以它可以被用于创建尽可能多的实例。这特别地有用，比如说，用来在活动场景中快速地实例化一些敌人、子弹等。"
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:4
msgid "简单2D游戏"
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:7
msgid "Pong"
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:9
msgid "在这个简单的教程中，我们将创建一个基础的游戏Pong（对板弹球）。引擎一并包含了很多更加复杂的范例和演示，但是这个应该可以为一个人介绍2D游戏的基本设计目的。"
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:12
msgid "资源"
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:14
msgid "这里包含了这个教程需要的资源： :download:`pong_assets.zip </files/pong_assets.zip>`."
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:18
msgid "场景建立"
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:20
msgid ""
"由于过去时代的原因，游戏将以640×480的像素分辨率运行。这可以在工程设定（Project Setting）中配置（详情参见 :ref"
":`doc_scenes_and_nodes-configuring_the_project` ）。默认背景颜色应当被设置为黑色："
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:24
msgid ""
"创建一个 :ref:`class_Node2D` 节点作为工程的根基。Node2D是2D引擎的基本类型。在此之后，添加一些精灵（Sprites， "
":ref:`class_Sprite` "
"节点）并且为每一个精灵设定对应的贴图（Textures）。最终场景布局应当看起来像下面那样（注意：小球在中央！）："
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:29
msgid "那么，场景树应当看起来像这样："
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:33
msgid "保存场景为\"pong.scn\"然后在工程属性（Project Properties）中把它设置为主场景。"
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:38
msgid "输入动作建立"
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:40
msgid "对于电子游戏会有很多的输入方法……键盘、手柄、鼠标、触控屏（多点触控）。好在这只是Pong。唯一重要的输入就是给板子上下移动的。"
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:42
msgid ""
"处理所有可能的输入方法会使非常令人恼火的并且还会需要大量代码。大多数游戏允许控制器自定义按键这一事实更是雪上加霜。对于这一点，Godot创建了“输入动作”（Input"
" Actions）。一个动作被定义，那么触发它的输入方式就被添加。"
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:45
msgid "再次打开工程属性对话框，但这次调到“输入映射”（Input Map）选项卡。"
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:47
msgid ""
"在这上面加入4个动作： ``left_move_up``, ``left_move_down``, ``right_move_up``, "
"``right_move_down``. "
"分配你想要的按键。A/Z（对于惯用左手的玩家）和上/下（对于惯用右手的玩家）作为在绝大多数情形中工作的键位。"
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:56
msgid ""
"为场景的根节点创建一个脚本然后打开它（正如在 :ref:`doc_scripting-"
"adding_a_script`中解释得那样）。这个脚本将会继承Node2D类："
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:65
msgid "在构造器（Constructor）中，必须完成两件事情。第一个就是去处理，然后第二个存储一些有用的值。这些值就是屏幕或者挡板的尺寸："
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:80
msgid "然后添加用于游戏内部处理的代码："
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:94
msgid "最终，process函数："
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:100
msgid ""
"获得到有用的值用于计算。首先是球的位置（从代码），第二个就是每个挡板的矩形区域（“Rect2”）。默认地精灵居中于他们的贴图。所以加入一个小的调整“pad_size"
" / 2”。"
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:108
msgid "由于球的位置已经获知，把它们累加起来应当不是问题："
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:114
msgid "然后，既然球拥有了一个新的位置。它倚在所有东西上都应该被检测。先是底部和顶部："
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:121
msgid "如果一个挡板被触碰，改变方向然后轻微加速。"
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:131
msgid "如果游戏飞出屏幕外部，游戏结束。游戏重启："
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:140
msgid "一旦球上的所有事情都做完了，节点就应当以一个新的位置更新："
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:146
msgid "只根据用户输入来更新挡板。Input类此时很有用："
msgstr ""

#: ../../tutorials/step_by_step/simple_2d_game.rst:170
msgid "这就成了！一个用几行代码写出来的简单的对板弹球。"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:4
msgid "单例(Singletons)(自动载入)"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:9
msgid "场景单例(Scene Singletons)是非常有用的东西，因为它们代表一个非常普遍的使用情形，但是在最开始他们的价值在哪里不甚清晰。"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:11
msgid "场景系统非常的有用，但是它自己还有一些缺点："
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:13
msgid "两个场景之间没有存储信息(比如核心(core)、包含的物件)的\"共同\"位置。"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:14
msgid "当持有那些信息时，我们可以去创建一个载入其他场景作为子级并释放它们的场景，但接下来如果完成了，我们不可以单独运行一个场景并期待它能够工作。"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:15
msgid "我们还可以在磁盘中的 \\`user://\\` 下存储持续性的信息并让场景总载入它，但是在切换场景时载入/保存是相当笨拙的。"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:18
msgid "所以在使用Godot一会之后，这就变得明晰了，有必要具备场景的局部："
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:20
msgid "总被装在，无论场景何时从编辑器被打开。"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:21
msgid "能够存留全局变量(Global Variables)，比如玩家信息、物品、金钱等。"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:22
msgid "能够处理场景的切换和切换效果。"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:23
msgid "就是一种行为上类似于一个单例类的东西，因为GDScript有意地不支持全局变量。"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:25
msgid "基于这些原因，自动载入节点的选项和脚本就存在了。"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:28
msgid "自动载入(AutoLoad)"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:30
msgid ""
"AutoLoad 可以是一个场景、或者一个继承了一个节点（一个将要被创建然后会为它设置脚本的节点）的脚本。它们可以在 Scene > "
"Project Settings > AutoLoad标签页下被添加到工程中。 AutoLoad can be a scene, or a "
"script that inherits from Node (a Node will be created and the script "
"will be set to it). They are added to the project in the Scene > Project "
"Settings > AutoLoad tab."
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:35
msgid ""
"每一个自动载入项 Each autoload needs a name, this name will be the node name, and"
" the node will be always added to the root viewport before any scene is "
"loaded."
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:42
msgid ""
"This means, that a for a singleton named \"playervariables\", any node "
"can access it by requesting:"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:50
msgid "Custom scene switcher"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:52
msgid ""
"This short tutorial will explain how to make a scene switcher by using "
"autoload. For simple scene switching, the :ref:`SceneTree.change_scene() "
"<class_SceneTree_change_scene>` method suffices (described in "
":ref:`doc_scene_tree`), so this method is for more complex behaviors when"
" switching scenes."
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:58
msgid ""
"First download the template from here: :download:`autoload.zip "
"</files/autoload.zip>`, then open it."
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:61
msgid ""
"Two scenes are present, scene_a.scn and scene_b.scn on an otherwise empty"
" project. Each are identical and contain a button connected to a callback"
" for going to the opposite scene. When the project runs, it starts in "
"scene_a.scn. However, this does nothing and pressing the button does not "
"work."
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:68
msgid "global.gd"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:70
msgid ""
"First of all, create a global.gd script. The easier way to create a "
"resource from scratch is from the resources tab:"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:75
msgid "Save the script to a file global.gd:"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:79
msgid ""
"The script should be opened in the script editor. Next step will be "
"adding it to autoload, for this, go to: Scene [STRIKEOUT:> Project "
"Settings]> AutoLoad and add a new autoload with name \"global\" that "
"points to this file:"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:86
msgid "Now, when any scene is run, the script will be always loaded."
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:88
msgid ""
"So, going back to it, In the _ready() function, the current scene will be"
" fetched. Both the current scene and global.gd are children of root, but "
"the autoloaded nodes are always first. This means that the last child of "
"root is always the loaded scene."
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:93
msgid ""
"Also, make sure that global.gd extends from Node, otherwise it won't be "
"loaded."
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:106
msgid ""
"Next, is the function for changing scene. This function will erase the "
"current scene and replace it by the requested one."
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:143
msgid ""
"As mentioned in the comments above, we really want to avoid the situation"
" of having the current scene being deleted while being used (code from "
"functions of it being run), so using :ref:`Object.call_deferred() "
"<class_Object_call_deferred>` is desired at this point. The result is "
"that execution of the commands in the second function will happen at an "
"immediate later time when no code from the current scene is running."
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:151
msgid ""
"Finally, all that is left is to fill the empty functions in scene_a.gd "
"and scene_b.gd:"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:161
msgid "and"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:170
msgid ""
"Finally, by running the project it's possible to switch between both "
"scenes by pressing the button!"
msgstr ""

#: ../../tutorials/step_by_step/singletons_autoload.rst:173
msgid ""
"(To load scenes with a progress bar, check out the next tutorial, "
":ref:`doc_background_loading`)"
msgstr ""

#: ../../tutorials/step_by_step/splash_screen.rst:4
msgid "启动画面(Splash Screen)"
msgstr ""

#: ../../tutorials/step_by_step/splash_screen.rst:7
msgid "教程"
msgstr ""

#: ../../tutorials/step_by_step/splash_screen.rst:9
msgid "这将是一个简单的教程来巩固关于GUI子系统如何工作的基本想法。目标是去创建一个十足简单的、静态的启动画面(译注：启动画面一说溅射屏幕，本文统一译为启动画面)。"
msgstr ""

#: ../../tutorials/step_by_step/splash_screen.rst:11
msgid "下图是一个包含着接下来要用的资源的文件。这些东西可以直接添加到你的工程文件夹中——无需导入它们："
msgstr ""

#: ../../tutorials/step_by_step/splash_screen.rst:13
msgid ":download:`robisplash_assets.zip </files/robisplash_assets.zip>`."
msgstr ""

#: ../../tutorials/step_by_step/splash_screen.rst:16
msgid "建立"
msgstr ""

#: ../../tutorials/step_by_step/splash_screen.rst:18
msgid "在工程设定中设定显示分辨率为800×450，然后像这样建立一个新场景："
msgstr ""

#: ../../tutorials/step_by_step/splash_screen.rst:24
msgid ""
"节点\"background\"和\"logo\"属于 :ref:`贴图框(TextureFrame) <class_TextureFrame>`"
" 类型。这些东西有一个特殊的属性来设定待显示的贴图，只需要载入相应的文件。"
msgstr ""

#: ../../tutorials/step_by_step/splash_screen.rst:29
msgid ""
"节点\"start\"是一个 :ref:`贴图按钮(TextureButton) "
"<class_TextureButton>`，它为自己的不同状态取得几张图像，但在这个范例中，我们只提供正常的和按下的："
msgstr ""

#: ../../tutorials/step_by_step/splash_screen.rst:33
msgid ""
"最后，节点\"copyright\"是一个 :ref:`标签(Label) "
"<class_Label>`。标签可以通过下面的属性被设定一个自定义字体："
msgstr ""

#: ../../tutorials/step_by_step/splash_screen.rst:37
msgid "附注，字体由一个TTF文件导入进来，见 :ref:`doc_importing_fonts`。"
msgstr ""

#: ../../tutorials/vector_math.rst:4
msgid "向量数学"
msgstr ""

#: ../../tutorials/vector_math.rst:9
msgid ""
"这篇小教程意在对向量数学(Vector "
"Mathematics)进行简短和实用的介绍，在2D和3D游戏中都非常有用。再说一遍，向量数学不仅是对3D有用， *而且* "
"对2D游戏也有用。一旦你掌握了它那么它是一个很棒的工具并能让复杂行为的编写更加简单。"
msgstr ""

#: ../../tutorials/vector_math.rst:11
msgid "通常地，新手程序员太依赖于 *不正确* 的数学来解决一大堆问题，比如说在2D游戏中只用三角几何学而不用向量。"
msgstr ""

#: ../../tutorials/vector_math.rst:13
msgid "这篇教程将关注于实用的用途，以及对游戏编程行业的快速应用。"
msgstr ""

#: ../../tutorials/vector_math.rst:16
msgid "2D坐标系(2D Coordinate System)"
msgstr ""

#: ../../tutorials/vector_math.rst:18
msgid "通常地，我们用有序数对(Pairs)(x,y)来定义坐标，x代表了水平偏移量而y代表了竖直偏移量。这在给定了一个二维矩形的屏幕时是有意义的。举个例子，在2D空间中有一个位置:"
msgstr ""

#: ../../tutorials/vector_math.rst:22
msgid ""
"位置可以是空间内的任意地方。位置(0,0)有一个名字，叫做 **原点(Origin)** "
"。牢记这一点因为接下来它会有很多隐含的用法。一个n维坐标系中，(0,0)就是 **原点** "
"(译注：此处说法似乎有问题，一个3D坐标系的原点是(0,0,0)，一个4D坐标系原点应当是(0,0,0,0)，一个n维坐标系的原点应当是(0,0,...,0))"
msgstr ""

#: ../../tutorials/vector_math.rst:24
msgid ""
"在向量数学中，坐标有两种用途，这两者都很重要。它们既被用于代表一个 *位置(Position)* 又被用来代表一个 *向量(Vector)* "
"。位置用途同之前所述，而当视为向量时，它却有另外一番含义。"
msgstr ""

#: ../../tutorials/vector_math.rst:28
msgid ""
"当被视为向量时，我们就可以推测出两个属性， **方向(Direction)** 和 "
"**模(Magnitude，又称为长度，与向量的范数(norm)相等)** 。空间中的每一个位置都可以是一个向量，除了 **原点** "
"（译注：在数学中，这种情况也是向量，但被叫做零向量）。这是因为坐标(0,0)无法代表方向(模为0)（译注：在数学中，零向量的方向是任意的）"
msgstr ""

#: ../../tutorials/vector_math.rst:33
msgid "方向(Direction)"
msgstr ""

#: ../../tutorials/vector_math.rst:35
msgid ""
"方向就和向量指向是一致的。试想一个箭头从 **原点** "
"出发然后朝向一个[STRIKEOUT:位置]（译注：这里STRIKEOUT格式意义不明）。箭头的末梢在一个位置中，因此它总是指向原点外的。把向量视为箭头会大有裨益。"
msgstr ""

#: ../../tutorials/vector_math.rst:40
msgid "模(Magnitude)"
msgstr ""

#: ../../tutorials/vector_math.rst:42
msgid ""
"最终，向量的长度就是原点到这个位置的距离。获取这个距离很容易，用 `勾股定理 "
"<http://en.wikipedia.org/wiki/Pythagorean_theorem>`__ (Gou-gu "
"Theorem，国外称毕达哥拉斯定理(Pythagorean Theorem))就可以了。"
msgstr ""

#: ../../tutorials/vector_math.rst:50
msgid "但是……角度呢?"
msgstr ""

#: ../../tutorials/vector_math.rst:52
msgid "但为什么不用一个 *角度* 呢？毕竟我们也能够把一个向量想成一个角度和一个模来替换一个方向和一个模。角度也是更加为人所熟知概念。"
msgstr ""

#: ../../tutorials/vector_math.rst:54
msgid "说实话，在向量数学中，角度不是那么有用，并且绝大多数时候它们也不是直接被处理的。也许它们在2D中还能运作，但到了3D中，很多能够用角度解决的问题就不再能用了。"
msgstr ""

#: ../../tutorials/vector_math.rst:56
msgid "还是，角度使用依然不是一个托辞，即使对于2D来说。在2D中绝大多数大量依靠角度的事物，在向量数学中也能很自然很容易的被解决。在向量数学中，角度只在作为一个量度的时候有用，而在其中不占多大成分。所以尽早放弃三角几何学，准备好去拥抱向量吧！"
msgstr ""

#: ../../tutorials/vector_math.rst:58
msgid ""
"任何情况下，获得一个向量的角度是十足简单的，可以用三角几……唉，那是什么鬼？我想说的是， :ref:`atan2() "
"<class_@GDScript_atan2>` 函数。"
msgstr ""

#: ../../tutorials/vector_math.rst:62
msgid "Godot中的向量类型"
msgstr ""

#: ../../tutorials/vector_math.rst:64
msgid ""
"为了方便举例子，这里有必要解释一下GDScript中向量是如何实现的。GDScript既有 :ref:`Vector2 "
"<class_Vector2>` 类型又有 :ref:`Vector3 "
"<class_Vector3>`，分别对应2D数学和3D数学。Godot使用Vector类既作为位置又作为方向。他们也包含x和y(2D中)以及x、y和z(3D中)成员变量(Member"
" Variables)。"
msgstr ""

#: ../../tutorials/vector_math.rst:76
msgid "当执行向量运算时，我们没必要去直接操作成员变量(事实上，这更慢)。向量支持常规的算术运算符："
msgstr ""

#: ../../tutorials/vector_math.rst:84
msgid "除了前者是更有效且更具有可读性以外，这等效于："
msgstr ""

#: ../../tutorials/vector_math.rst:92
msgid "常规的算术运算符如加(Addition)、减(Subtraction)、乘(Multiplication)、除(Division)都是支持的"
msgstr ""

#: ../../tutorials/vector_math.rst:94
msgid "向量的相乘和相除也可以结合单一的数字，这个数字也被叫做 **标量(Scalar)**。(也被称为向量的数乘运算，结果为一个向量)"
msgstr ""

#: ../../tutorials/vector_math.rst:102
msgid "还是，除了前者更加的高效且具有可读性以外，等效于："
msgstr ""

#: ../../tutorials/vector_math.rst:111
msgid "正交向量(Perpendicular Vectors，即相互垂直的向量)"
msgstr ""

#: ../../tutorials/vector_math.rst:113
msgid "将一个2D向量向左右任意一边旋转90°，是相当简单的，只需要交换x和y，然后为x或y中的一个取相反数即可(方向取决于谁变负的了)"
msgstr ""

#: ../../tutorials/vector_math.rst:117
msgid "举例："
msgstr ""

#: ../../tutorials/vector_math.rst:127
msgid "这是一个很常用的手边技巧。但是这对于3D是不可能的，因为有无穷多个正交向量。"
msgstr ""

#: ../../tutorials/vector_math.rst:130
msgid "单位向量(Unit Vectors，即模量为1的向量)"
msgstr ""

#: ../../tutorials/vector_math.rst:132
msgid ""
"好的，那么我们知道了向量是什么。它有 **方向** 和 **模** 。我们还知道如何在Godot中使用它们。下一步就是了解 **单位向量** "
"了。任意一个 **模**为1的向量都被认为是一个 "
"**单位向量**。在2D中，试想画一个半径为1的圆(被称作单位圆)。这个圆包含了在二维中存在的所有单位向量"
msgstr ""

#: ../../tutorials/vector_math.rst:136
msgid "那么，单位向量的特殊之处在哪呢？单位向量很厉害。换句话说，单位有 **一些很有用的属性**。"
msgstr ""

#: ../../tutorials/vector_math.rst:138
msgid "我们迫不及待要去了解关于单位向量的优良属性的更多内容了，但是还是要一步一步来。那么如何由一个常规向量创建一个单位向量呢？"
msgstr ""

#: ../../tutorials/vector_math.rst:141
msgid "归一化向量(Normalization)"
msgstr ""

#: ../../tutorials/vector_math.rst:143
msgid ""
"取得任何一个向量然后把 **模量**削减为1.0而保持它的 **方向** 的过程被称之为 "
"**向量的归一化**。归一化通过用一个向量的x和y(3D中还有z)分量(Component)除以向量的模："
msgstr ""

#: ../../tutorials/vector_math.rst:152
msgid ""
"(注意：前方官方文档严重卖萌，与翻译组无关) 正如你所猜到的那样，如果一个向量的模量为0时(意味着不是一个向量而是 **原点**或者也叫做 "
"*零向量(Null "
"Vector)*)，一个除以0的除法式将发生，然后宇宙将经历又一次大爆炸(译注：没这么危险，作者只不过是在玩(mài)笑(méng)，意在说明这种错误对于程序运行是灾难性的)，除非在倒转极性下它又回来了。结果人类还健在但Godot将会输出一个错误。记住！向量(0,0)不能被归一化！"
msgstr ""

#: ../../tutorials/vector_math.rst:155
msgid "当然，Vector2和Vector3已经提供了一个方法(Method)来做这件事："
msgstr ""

#: ../../tutorials/vector_math.rst:162
msgid "点积运算(Dot Production，又称数量积运算、点乘运算)"
msgstr ""

#: ../../tutorials/vector_math.rst:164
msgid ""
"好了， "
"**点积**是向量数学中最重要的部分。没有点积的话，雷神之锤(Quake)就不可能被做出来。这是本教程最重要的一节，所以确保能够适当地掌握它。绝大多数尝试去理解向量数学的人都在此放弃了，因为无论它有多简单，他们从中也做不出个头尾。为什么呢？因为……"
msgstr ""

#: ../../tutorials/vector_math.rst:166
msgid "点积取两个向量进行运算并返回一个 **标量** ："
msgstr ""

#: ../../tutorials/vector_math.rst:172
msgid "是的，基本就是这样。用 **a**向量的 **x**乘以 **b**向量的 **x**。对y再进行一次然后相加。在3D中基本还是这样："
msgstr ""

#: ../../tutorials/vector_math.rst:178
msgid "我知道，这一点意义都没有，你甚至都可以用内置函数来完成："
msgstr ""

#: ../../tutorials/vector_math.rst:184
msgid "两个向量的顺序 **没有**影响(因为点积遵循交换律)， ``a.dot(b)``和 ``b.dot(a)``返回相同的值。"
msgstr ""

#: ../../tutorials/vector_math.rst:186
msgid "这正是绝望的开始，教科书和教程都会给你下面这个公式："
msgstr ""

#: ../../tutorials/vector_math.rst:190
msgid ""
"然后你就意识到你该放弃制作3D或者复杂的2D游戏了。那么为什么会有这么个既简单又复杂的东西呢？别人将不得不去做塞尔达(Zelda)或者使命召唤(Call"
" of Duty)。顶视角RPG(Top Down RPG,TDRPG)毕竟看起来不那么糟糕。是的，我听到有人 And you realize "
"it's time to give up making 3D games or complex 2D games. How can "
"something so simple be so complex? Someone else will have to make the "
"next Zelda or Call of Duty. Top down RPGs don't look so bad after all. "
"Yeah I hear someone did pretty will with one of those on Steam..."
msgstr ""

#: ../../tutorials/vector_math.rst:197
msgid ""
"所以这是属于你的时刻，这是你闪耀的时间。 **不要怂，就是上！** 在这一问题上，这篇教程将会来一个大转弯然后关注什么使得点积这么的有用。也就是，"
" **为什么**它很有用。我们将会逐一关注点积的使用情形，以及现实中的应用。世上没有毫无意义的公式。 *一旦你了解了* "
"它们用于什么，公式们将会有意义。"
msgstr ""

#: ../../tutorials/vector_math.rst:201
msgid "Siding"
msgstr ""

#: ../../tutorials/vector_math.rst:203
msgid ""
"点积第一个有用的也是最重要的性质就是去检测旁边事物在看什么。我们试想一下有任意两个向量 **a**和 **b**。任意的 **方向**或 "
"**模**(不能是 **原点**)。。这些并不会影响它们，但是让我们试想我们对它们实施点积运算。"
msgstr ""

#: ../../tutorials/vector_math.rst:209
msgid ""
"运算将会返回一个单精度浮点型的数(但是既然我们在向量的世界中，我们叫它们 "
"**标量**，从现在起我们将持续沿用这个概念)。这个数(译者吐槽：说好的从现在起持续沿用呢！！)将会告诉我们以下内容："
msgstr ""

#: ../../tutorials/vector_math.rst:211
msgid "如果这个数大于0，则两者皆面向同一方向(两者夹角小于90°，为锐角)。"
msgstr ""

#: ../../tutorials/vector_math.rst:212
msgid "如果这个数小于0，两者面向相反的方向(两者夹角大于90°，为钝角)。"
msgstr ""

#: ../../tutorials/vector_math.rst:213
msgid "如果这个数就是0，向量将会按L形垂直排列(两者夹角为90°，为直角)。"
msgstr ""

#: ../../tutorials/vector_math.rst:217
msgid ""
"那么，让我们想象一个真实的使用案例。想象一条蛇正在穿过一个森林，然后附近有一个敌人。我们如何快速的辨别敌人是否已经发现了蛇呢？为了发现他，敌人必须能够"
" *看到*蛇。然后我们说："
msgstr ""

#: ../../tutorials/vector_math.rst:219
msgid "蛇在位置 **A**。"
msgstr ""

#: ../../tutorials/vector_math.rst:220
msgid "敌人在位置 **B**。"
msgstr ""

#: ../../tutorials/vector_math.rst:221
msgid "敌人正 *面向*向量 **F**的方向。"
msgstr ""

#: ../../tutorials/vector_math.rst:225
msgid "那么，我们就来创建新向量 **BA**，从守卫( **B**)指向蛇( **A**)，通过两者坐标相减(末减初)："
msgstr ""

#: ../../tutorials/vector_math.rst:233
msgid ""
"理想地，如果守卫正好直视着蛇，为了发生眼神接触，它将会以和向量BA同向方向做这件事 (译者注：最后一句it would do "
"it没看懂，暂留原文以备修改)Ideally, if the guard was looking straight towards snake, "
"to make eye to eye contact, it would do it in the same direction as "
"vector BA."
msgstr ""

#: ../../tutorials/vector_math.rst:237
msgid "如果 **F**和 **BA**的数量积大于0，那么蛇就被发现了。这发生了因为我们将可以判断这个正面向他："
msgstr ""

#: ../../tutorials/vector_math.rst:244
msgid "目前来看，蛇似乎还很安全。"
msgstr ""

#: ../../tutorials/vector_math.rst:247
msgid "支持单位向量"
msgstr ""

#: ../../tutorials/vector_math.rst:249
msgid "好了，那么我们现在知道了两个向量的点积将会告诉我们它们看向了同侧、异侧还是干脆彼此垂直。"
msgstr ""

#: ../../tutorials/vector_math.rst:251
msgid "这对于所有向量都适用，和模量无关，因此 **单位向量** 也不例外。然而，对单位向量使用相同的属性会产生一个更有趣的结果，因为多了一个附加属性："
msgstr ""

#: ../../tutorials/vector_math.rst:253
msgid "如果两个向量都面向了完全相同的方向（彼此平行(Parallel，在向量中也被称为共线)，夹角是0°(同向)），标量结果为 **1** 。"
msgstr ""

#: ../../tutorials/vector_math.rst:255
msgid "如果两个向量都面向了完全相同的方向（彼此平行，夹角却是180°(反向)），标量结果为 **-1** 。"
msgstr ""

#: ../../tutorials/vector_math.rst:257
msgid "这也就意味着，单位向量的点积结果将总在范围[-1,1]之间。那么又……"
msgstr ""

#: ../../tutorials/vector_math.rst:259
msgid "如果夹角为 **0°** 点积为 **1** 。"
msgstr ""

#: ../../tutorials/vector_math.rst:261
msgid "如果夹角为 **90°** 点积为 **0** 。"
msgstr ""

#: ../../tutorials/vector_math.rst:263
msgid "如果夹角为 **180°** 点积为 **-1** 。"
msgstr ""

#: ../../tutorials/vector_math.rst:265
msgid "额……这有点莫名的熟悉……好像在哪见过……哪呢？"
msgstr ""

#: ../../tutorials/vector_math.rst:267
msgid "我们来引入两个单位向量，第一个向上指，第二个也一样但是我们将会全程让它从上(0°)到下(180°)旋转……"
msgstr ""

#: ../../tutorials/vector_math.rst:271
msgid "当测算标量结果时！"
msgstr ""

#: ../../tutorials/vector_math.rst:275
msgid "啊哈！一切都明朗了，这是 `余弦 <http://mathworld.wolfram.com/Cosine.html>`__ 函数！"
msgstr ""

#: ../../tutorials/vector_math.rst:277
msgid "我们于是就能说，作为一个准则……"
msgstr ""

#: ../../tutorials/vector_math.rst:279
msgid "两个 **单位向量** 的 **点积** 是两个向量 **夹角** 的 **余弦值** 。因此，欲获取两个向量的夹角，我们必须要："
msgstr ""

#: ../../tutorials/vector_math.rst:285
msgid ""
"这对什么有用呢？直接获取向量的夹角可能不那么有用， What is this useful for? Well obtaining the "
"angle directly is probably not as useful, but just being able to tell the"
" angle is useful for reference. One example is in the `Kinematic "
"Character "
"<https://github.com/godotengine/godot/blob/master/demos/2d/kinematic_char/player.gd#L879>`__"
" demo, when the character moves in a certain direction then we hit an "
"object. How to tell if what we hit is the floor?"
msgstr ""

#: ../../tutorials/vector_math.rst:293
msgid ""
"By comparing the normal of the collision point with a previously computed"
" angle."
msgstr ""

#: ../../tutorials/vector_math.rst:296
msgid ""
"The beauty of this is that the same code works exactly the same and "
"without modification in `3D "
"<https://github.com/godotengine/godot/blob/master/demos/3d/kinematic_char/cubio.gd#L57>`__."
" Vector math is, in a great deal, dimension-amount-independent, so adding"
" or removing an axis only adds very little complexity."
msgstr ""

#: ../../tutorials/vector_math.rst:303
msgid "平面"
msgstr ""

#: ../../tutorials/vector_math.rst:305
msgid ""
"The dot product has another interesting property with unit vectors. "
"Imagine that perpendicular to that vector (and through the origin) passes"
" a plane. Planes divide the entire space into positive (over the plane) "
"and negative (under the plane), and (contrary to popular belief) you can "
"also use their math in 2D:"
msgstr ""

#: ../../tutorials/vector_math.rst:313
msgid ""
"Unit vectors that are perpendicular to a surface (so, they describe the "
"orientation of the surface) are called **unit normal vectors**. Though, "
"usually they are just abbreviated as \\*normals. Normals appear in "
"planes, 3D geometry (to determine where each face or vertex is siding), "
"etc. A **normal** *is* a **unit vector**, but it's called *normal* "
"because of it's usage. (Just like we call Origin to (0,0)!)."
msgstr ""

#: ../../tutorials/vector_math.rst:320
msgid ""
"It's as simple as it looks. The plane passes by the origin and the "
"surface of it is perpendicular to the unit vector (or *normal*). The side"
" towards the vector points to is the positive half-space, while the other"
" side is the negative half-space. In 3D this is exactly the same, except "
"that the plane is an infinite surface (imagine an infinite, flat sheet of"
" paper that you can orient and is pinned to the origin) instead of a "
"line."
msgstr ""

#: ../../tutorials/vector_math.rst:329
msgid "到平面的距离"
msgstr ""

#: ../../tutorials/vector_math.rst:331
msgid ""
"Now that it's clear what a plane is, let's go back to the dot product. "
"The dot product between a **unit vector** and any **point in space** "
"(yes, this time we do dot product between vector and position), returns "
"the **distance from the point to the plane**:"
msgstr ""

#: ../../tutorials/vector_math.rst:340
msgid ""
"But not just the absolute distance, if the point is in the negative half "
"space the distance will be negative, too:"
msgstr ""

#: ../../tutorials/vector_math.rst:345
msgid "This allows us to tell which side of the plane a point is."
msgstr ""

#: ../../tutorials/vector_math.rst:348
msgid "离开原点"
msgstr ""

#: ../../tutorials/vector_math.rst:350
msgid ""
"I know what you are thinking! So far this is nice, but *real* planes are "
"everywhere in space, not only passing through the origin. You want real "
"*plane* action and you want it *now*."
msgstr ""

#: ../../tutorials/vector_math.rst:354
msgid ""
"Remember that planes not only split space in two, but they also have "
"*polarity*. This means that it is possible to have perfectly overlapping "
"planes, but their negative and positive half-spaces are swapped."
msgstr ""

#: ../../tutorials/vector_math.rst:358
msgid ""
"With this in mind, let's describe a full plane as a **normal** *N* and a "
"**distance from the origin** scalar *D*. Thus, our plane is represented "
"by N and D. For example:"
msgstr ""

#: ../../tutorials/vector_math.rst:364
msgid ""
"For 3D math, Godot provides a :ref:`Plane <class_Plane>` built-in type "
"that handles this."
msgstr ""

#: ../../tutorials/vector_math.rst:367
msgid ""
"Basically, N and D can represent any plane in space, be it for 2D or 3D "
"(depending on the amount of dimensions of N) and the math is the same for"
" both. It's the same as before, but D is the distance from the origin to "
"the plane, travelling in N direction. As an example, imagine you want to "
"reach a point in the plane, you will just do:"
msgstr ""

#: ../../tutorials/vector_math.rst:377
msgid ""
"This will stretch (resize) the normal vector and make it touch the plane."
" This math might seem confusing, but it's actually much simpler than it "
"seems. If we want to tell, again, the distance from the point to the "
"plane, we do the same but adjusting for distance:"
msgstr ""

#: ../../tutorials/vector_math.rst:386
msgid "The same thing, using a built-in function:"
msgstr ""

#: ../../tutorials/vector_math.rst:392
msgid "This will, again, return either a positive or negative distance."
msgstr ""

#: ../../tutorials/vector_math.rst:394
msgid ""
"Flipping the polarity of the plane is also very simple, just negate both "
"N and D. This will result in a plane in the same position, but with "
"inverted negative and positive half spaces:"
msgstr ""

#: ../../tutorials/vector_math.rst:403
msgid ""
"Of course, Godot also implements this operator in :ref:`Plane "
"<class_Plane>`, so doing:"
msgstr ""

#: ../../tutorials/vector_math.rst:410
msgid "Will work as expected."
msgstr ""

#: ../../tutorials/vector_math.rst:412
msgid ""
"So, remember, a plane is just that and it's main practical use is "
"calculating the distance to it. So, why is it useful to calculate the "
"distance from a point to a plane? It's extremely useful! Let's see some "
"simple examples.."
msgstr ""

#: ../../tutorials/vector_math.rst:418
msgid "在2D中构建平面"
msgstr ""

#: ../../tutorials/vector_math.rst:420
msgid ""
"Planes clearly don't come out of nowhere, so they must be built. "
"Constructing them in 2D is easy, this can be done from either a normal "
"(unit vector) and a point, or from two points in space."
msgstr ""

#: ../../tutorials/vector_math.rst:424
msgid ""
"In the case of a normal and a point, most of the work is done, as the "
"normal is already computed, so just calculate D from the dot product of "
"the normal and the point."
msgstr ""

#: ../../tutorials/vector_math.rst:433
msgid ""
"For two points in space, there are actually two planes that pass through "
"them, sharing the same space but with normal pointing to the opposite "
"directions. To compute the normal from the two points, the direction "
"vector must be obtained first, and then it needs to be rotated 90° "
"degrees to either side:"
msgstr ""

#: ../../tutorials/vector_math.rst:449
msgid ""
"The rest is the same as the previous example, either point_a or point_b "
"will work since they are in the same plane:"
msgstr ""

#: ../../tutorials/vector_math.rst:459
msgid ""
"Doing the same in 3D is a little more complex and will be explained "
"further down."
msgstr ""

#: ../../tutorials/vector_math.rst:463
msgid "平面的使用举例"
msgstr ""

#: ../../tutorials/vector_math.rst:465
msgid ""
"Here is a simple example of what planes are useful for. Imagine you have "
"a `convex <http://www.mathsisfun.com/definitions/convex.html>`__ polygon."
" For example, a rectangle, a trapezoid, a triangle, or just any polygon "
"where faces that don't bend inwards."
msgstr ""

#: ../../tutorials/vector_math.rst:470
msgid ""
"For every segment of the polygon, we compute the plane that passes by "
"that segment. Once we have the list of planes, we can do neat things, for"
" example checking if a point is inside the polygon."
msgstr ""

#: ../../tutorials/vector_math.rst:474
msgid ""
"We go through all planes, if we can find a plane where the distance to "
"the point is positive, then the point is outside the polygon. If we "
"can't, then the point is inside."
msgstr ""

#: ../../tutorials/vector_math.rst:480 ../../tutorials/vector_math.rst:505
msgid "Code should be something like this:"
msgstr ""

#: ../../tutorials/vector_math.rst:491
msgid ""
"Pretty cool, huh? But this gets much better! With a little more effort, "
"similar logic will let us know when two convex polygons are overlapping "
"too. This is called the Separating Axis Theorem (or SAT) and most physics"
" engines use this to detect collision."
msgstr ""

#: ../../tutorials/vector_math.rst:496
msgid ""
"The idea is really simple! With a point, just checking if a plane returns"
" a positive distance is enough to tell if the point is outside. With "
"another polygon, we must find a plane where *all the **other** polygon "
"points* return a positive distance to it. This check is performed with "
"the planes of A against the points of B, and then with the planes of B "
"against the points of A:"
msgstr ""

#: ../../tutorials/vector_math.rst:541
msgid ""
"As you can see, planes are quite useful, and this is the tip of the "
"iceberg. You might be wondering what happens with non convex polygons. "
"This is usually just handled by splitting the concave polygon into "
"smaller convex polygons, or using a technique such as BSP (which is not "
"used much nowadays)."
msgstr ""

#: ../../tutorials/vector_math.rst:548
msgid "叉积(Cross Product，又称向量的向量积、叉乘运算)"
msgstr ""

#: ../../tutorials/vector_math.rst:550
msgid ""
"Quite a lot can be done with the dot product! But the party would not be "
"complete without the cross product. Remember back at the beginning of "
"this tutorial? Specifically how to obtain a perpendicular (rotated 90 "
"degrees) vector by swapping x and y, then negating either of them for "
"right (clockwise) or left (counter-clockwise) rotation? That ended up "
"being useful for calculating a 2D plane normal from two points."
msgstr ""

#: ../../tutorials/vector_math.rst:557
msgid ""
"As mentioned before, no such thing exists in 3D because a 3D vector has "
"infinite perpendicular vectors. It would also not make sense to obtain a "
"3D plane from 2 points, as 3 points are needed instead."
msgstr ""

#: ../../tutorials/vector_math.rst:561
msgid ""
"To aid in this kind stuff, the brightest minds of humanity's top "
"mathematicians brought us the **cross product**."
msgstr ""

#: ../../tutorials/vector_math.rst:564
msgid ""
"The cross product takes two vectors and returns another vector. The "
"returned third vector is always perpendicular to the first two. The "
"source vectors, of course, must not be the same, and must not be parallel"
" or opposite, else the resulting vector will be (0,0,0):"
msgstr ""

#: ../../tutorials/vector_math.rst:571
msgid "The formula for the cross product is:"
msgstr ""

#: ../../tutorials/vector_math.rst:580
msgid "This can be simplified, in Godot, to:"
msgstr ""

#: ../../tutorials/vector_math.rst:586
msgid ""
"However, unlike the dot product, doing ``a.cross(b)`` and ``b.cross(a)`` "
"will yield different results. Specifically, the returned vector will be "
"negated in the second case. As you might have realized, this coincides "
"with creating perpendicular vectors in 2D. In 3D, there are also two "
"possible perpendicular vectors to a pair of 2D vectors."
msgstr ""

#: ../../tutorials/vector_math.rst:592
msgid ""
"Also, the resulting cross product of two unit vectors is *not* a unit "
"vector. Result will need to be renormalized."
msgstr ""

#: ../../tutorials/vector_math.rst:596
msgid "三角形区域"
msgstr ""

#: ../../tutorials/vector_math.rst:598
msgid ""
"Cross product can be used to obtain the surface area of a triangle in 3D."
" Given a triangle consisting of 3 points, **A**, **B** and **C**:"
msgstr ""

#: ../../tutorials/vector_math.rst:603
msgid ""
"Take any of them as a pivot and compute the adjacent vectors to the other"
" two points. As example, we will use B as a pivot:"
msgstr ""

#: ../../tutorials/vector_math.rst:613
msgid ""
"Compute the cross product between **BA** and **BC** to obtain the "
"perpendicular vector **P**:"
msgstr ""

#: ../../tutorials/vector_math.rst:622
msgid ""
"The length (magnitude) of **P** is the surface area of the parallelogram "
"built by the two vectors **BA** and **BC**, therefore the surface area of"
" the triangle is half of it."
msgstr ""

#: ../../tutorials/vector_math.rst:631
msgid "三角形所在平面"
msgstr ""

#: ../../tutorials/vector_math.rst:633
msgid ""
"With **P** computed from the previous step, normalize it to get the "
"normal of the plane."
msgstr ""

#: ../../tutorials/vector_math.rst:640
msgid ""
"And obtain the distance by doing the dot product of P with any of the 3 "
"points of the **ABC** triangle:"
msgstr ""

#: ../../tutorials/vector_math.rst:647
msgid "Fantastic! You computed the plane from a triangle!"
msgstr ""

#: ../../tutorials/vector_math.rst:649
msgid ""
"Here's some useful info (that you can find in Godot source code anyway). "
"Computing a plane from a triangle can result in 2 planes, so a sort of "
"convention needs to be set. This usually depends (in video games and 3D "
"visualization) to use the front-facing side of the triangle."
msgstr ""

#: ../../tutorials/vector_math.rst:654
msgid ""
"In Godot, front-facing triangles are those that, when looking at the "
"camera, are in clockwise order. Triangles that look Counter-clockwise "
"when looking at the camera are not drawn (this helps to draw less, so the"
" back-part of the objects is not drawn)."
msgstr ""

#: ../../tutorials/vector_math.rst:659
msgid ""
"To make it a little clearer, in the image below, the triangle **ABC** "
"appears clock-wise when looked at from the *Front Camera*, but to the "
"*Rear Camera* it appears counter-clockwise so it will not be drawn."
msgstr ""

#: ../../tutorials/vector_math.rst:665
msgid ""
"Normals of triangles often are sided towards the direction they can be "
"viewed from, so in this case, the normal of triangle ABC would point "
"towards the front camera:"
msgstr ""

#: ../../tutorials/vector_math.rst:671
msgid "So, to obtain N, the correct formula is:"
msgstr ""

#: ../../tutorials/vector_math.rst:682
msgid "3D中的碰撞检测"
msgstr ""

#: ../../tutorials/vector_math.rst:684
msgid ""
"This is another bonus bit, a reward for being patient and keeping up with"
" this long tutorial. Here is another piece of wisdom. This might not be "
"something with a direct use case (Godot already does collision detection "
"pretty well) but It's a really cool algorithm to understand anyway, "
"because it's used by almost all physics engines and collision detection "
"libraries :)"
msgstr ""

#: ../../tutorials/vector_math.rst:691
msgid ""
"Remember that converting a convex shape in 2D to an array of 2D planes "
"was useful for collision detection? You could detect if a point was "
"inside any convex shape, or if two 2D convex shapes were overlapping."
msgstr ""

#: ../../tutorials/vector_math.rst:695
msgid ""
"Well, this works in 3D too, if two 3D polyhedral shapes are colliding, "
"you won't be able to find a separating plane. If a separating plane is "
"found, then the shapes are definitely not colliding."
msgstr ""

#: ../../tutorials/vector_math.rst:699
msgid ""
"To refresh a bit a separating plane means that all vertices of polygon A "
"are in one side of the plane, and all vertices of polygon B are in the "
"other side. This plane is always one of the face-planes of either polygon"
" A or polygon B."
msgstr ""

#: ../../tutorials/vector_math.rst:704
msgid ""
"In 3D though, there is a problem to this approach, because it is possible"
" that, in some cases a separating plane can't be found. This is an "
"example of such situation:"
msgstr ""

#: ../../tutorials/vector_math.rst:710
msgid ""
"To avoid it, some extra planes need to be tested as separators, these "
"planes are the cross product between the edges of polygon A and the edges"
" of polygon B"
msgstr ""

#: ../../tutorials/vector_math.rst:716
msgid "So the final algorithm is something like:"
msgstr ""

#: ../../tutorials/vector_math.rst:792
msgid ""
"This was all! Hope it was helpful, and please give feedback and let know "
"if something in this tutorial is not clear! You should be now ready for "
"the next challenge... :ref:`doc_matrices_and_transforms`!"
msgstr ""

